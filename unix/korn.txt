**************************
* KORN SHELL PROGRAMMING *
**************************

*************
* VARIABLES *
*************

Assigning values to local variables			x=5
Assigning variable attributes				typeset
Assigning values to environment variables		export NAME=bob 
Accessing variables					echo $NAME


************************************************
* VARIABLE EXPRESSIONS AND EXPANSION MODIFIERS *
************************************************


${variable:-word}		If variable is set and non-null, substitute its value;
				otherwise, substitute "word"

${variable:=word}		If variable is not set or is null, set it to "word";
				the value is substituted permanently. Positional variable may not
				be assigned in this way. eg if [[ "${uid:=0}" -ne 0 ]]

${variable:+word}		If variable is set and is non-null, substitute "word"; otherwise
				substitute nothing.

${variable:?word}		If variable is set and is non null; substitute it value; otherwise,
				print "word" and exit from the shell. If word is ommitted, the message
				"parameter null or not set is printed."


************************************
* VARIABLE EXPANSION OF SUBSTRINGS *
************************************

${variable%pattern}		Matches the "smallest trailing portion" of the value of variable
				to pattern and removes it.

${variable%%pattern}		Matches the "largest trailing portion" of the value of variable to
				pattern and removes it.

${variable#pattern}		Matches the "smallest leading portion" of the value of variable to
				pattern and removes it.

${variable##pattern}		Matches the "largest leading portion" of the value of variable to
				pattern and removes it.

e.g. 
$ pathname="/usr/bin/local/bin"
$ print ${pathname%/bin/*}
$ /usr/bin/local

$ print ${pathname%%/bin/*}
$ /usr
------
$ pathname="/home/lilliput/jake/.cshrc"
$ print ${pathname#/home}
$ /lilliput/jake/.cshrc

$ print ${pathname##*/}
$ .cshrc


************************************************
* COMMAND LINE ARGUMENTS AND SPECIAL VARIABLES *
************************************************


set a b c	Setting positional parameters
$0		References the name of the current shell script
$1-$9		Positional parameters 1-9
${10}		Positional parameter 10
$#		Evaluates to the number of positional paramters
$*		Evaluates to all the positional parameters
$@		Same as $*, except when double quoted
"$*"		Evaluates to "$1 $2 $3" ect
"$@"		Evaluates to "$1" "$2" "$3" etc
$$		PID of this process
$?		Exit status
$!		Last background job


******************
* STRING TESTING *
******************

string1 = string2		string1 is equal to string2(new version uses == sign)
string1 != string		string1 is not equal to string2
string1 < string2		ASCII value of string1 is less than string2
string1 > string2		ASCII value of string1 is greater than string2
string				string is not null
-z string			length of string is zero, null parameter
-n string			length of string is nonzero, non null parameter

e.g.
read answer
if [[ $answer = [Yy]* ]]
then
  commands
fi

file=/etc/passwd
if [[ -f $file && (-r $file || -w $file) ]]
then
   print $file is a plain file and is either readable or writeable
fi


********************************************
* INTEGER TESTING (OLD STYLE BOURNE SHELL) *
********************************************

int1 -eq int2			int1 is equal to int2
int1 -ne int2			int1 is not equal to int2
int1 -gt int2			int1 is greater than int2
int1 -ge int2			int1 is greater than or equal to int2
int1 -lt int2			int1 is less than int2
int1 -le int2			int1 is less than or equal to int2



********************************
* LOGICAL OPERATOR (OLD STYLE) *
********************************

!	NOT operator
-a	AND operator
-o	OR operator


eg.1

#!/usr/bin/ksh

print "Are you OK (y/n)?"
read answer
if [ "$answer" = Y -o "$answer" = y ]	 # if [[ "$answer" = [Yy]* ]]  new style test
then  # old style test
   print "Glad to hear it"
fi

eg.2

if [ $# -lt 1 ]
then
  print "$0: Insufficient arguments" 1>&2
  exit 1
fi



****************************
* FILE TESTING (OLD STYLE) *
****************************

-b filename		block special file
-c filename		character special file
-d filename		directory existence
-f filename		file existence and not a directory
-g filename		set-group-id is set
-h filename		symbolic link
-k filename		sticky bit is set
-p filename		file is a named pipe
-r filename		file is a readable
-s filename		file is non-zero size
-u filename		set-user-id bit is set
-w filename		file is writeable
-x filename		file is executable
file1 -nt file2		file1 is newer than file2 (cf modification times)
file1 -ot file2		file1 is older than file2

********************************
* FILE TESTING KORN SHELL ONLY *
********************************

-a filename		file exists
-e filename		file exists (version newer than 1988)
-L filename		file exists and is a symbolic link
-O filename		You are the owner of the file
-G filename		Your group id is the same as file's
-S filename		file exists and is a socket



*********************************
* ARRAYS (index starts at zero) *
*********************************

					y[0]=a; y[1]=b; y[2]=c;
Assigning array 			set -A fruit apples pears plums

Accessing array elements		print ${y[0]}${y[*]}

All elements				print ${y[*]}

The number of elements			print ${#y[*]}

e.g.

$ array[0]=tom
$ array[1]=dan
$ array[2]=bill

$ print ${array[0]}   # curly braces are required
$ print ${array[*]}   # display all elements
$ print ${#array[*]}  # display the number of elements

$ typeset -i ints[4]	# declare an array of four integers
$ ints[0]=50
$ ints[1]=75
$ ints[2]=100
$ ints[3]=125



************************
* COMMAND SUBSTITUTION *
************************

Assigning output of command to variable			d=$(date) or d=`date`
Accessing values					print $d


*****************************************
* METACHARACTERS FOR FILENAME EXPANSION *
*****************************************

Single character					?
Zero or more characters					*
One character from a set				[abc]
One character from a range of characters in a set	[a-c]
One character not in the set				[!abc]

E.g.

abc?(2|9)1 - ? matches zero or one occurrences of any pattern in the parenthesis.
The vertical bar represents an OR condition; either a 2 or 9. Matches abc21, abc91, or abc1.


*****************************
* I/O REDIRECTION AND PIPES *
*****************************

Command o/p						cmd > file
Command i/p redirected from a file			cmd < file
Command errors redirected to a file			cmd 2> errors
Output and errors redirected to a file			cmd >file 2>&1
Assigning o/p and ignore noclobber			cmd >|file
Here document						cmd << EOF
							statement
							EOF
Pipe o/p of one command to i/p of another command	cmd | cmd
Pipe o/p and error to a command				cmd |& cmd
Conditional statement					cmd && cmd  (cmd || cmd)
Co-process						cmd |&



*************************
* READING FROM KEYBOARD *
*************************

							read var
							read var1 var2 ...
Reading a line of i/p and store into variables		read
							read var?"Enter value"


**************
* ARITHMETIC *
**************

Perform calculation					((var=5+1)) or let var=5+1



*******************
* TILDE EXPANSION *
*******************

Represent home directory of user			~username
Represent home directory				~
Represent present working directory			~+
Represent previous working directory			~-


***********
* ALIASES *
***********

Create an alias						alias m=more
List aliases						alias, alias -t
Remove an alias						unalias m



***********
* HISTORY *
***********

Set history						automatic or HISTSIZE=25
Display numbered history list				history, fc -l
Display portion of list selected by number		history 5 10; history -5
Re-execute a command					r (last command), r5 (5th command), 
							rv (last command starting with v)
set interactive editor					set -o vi or set -o emacs



***********
* SIGNALS *
***********

Command						trap



************************
* INITIALISATION FILES *
************************

Executed at login				.profile
Executed everytime a new shell is invoked	ENV=.kshrc (or another name)



*************
* BACKSLASH *
*************

1) Precedes a character and escape that character
2) Same as putting single quotes around one character



*****************
* SINGLE QUOTES *
*****************

1) Must be matched
2) Protect all metacharacters from interpretation except
	a) itself
	b) exclamation point (csh only)
	c) backslash
e.g.
	BOURNE shell			KORN shell
	------------			----------
	echo '$*&!><?'			echo '$*&!><?'
	echo 'I need \$5.00!'		echo 'I need \$5.00!'
	echo 'She cried, "Help"'	echo 'She cried, "Help"'
	echo '\\\\' -> \\		echo '\\\\' -> \\


*****************
* DOUBLE QUOTES *
*****************

1) Must be matched
2) Protect all metacharacters from interpretation except
	a) Itself
	b) Exclamation point (csh only)
	c) $ used for variable substitution
	d) `` backquotes for command substitution
e.g.
	BOURNE shell			KORN shell
	------------			----------
	echo "Hello $LOGNAME!"		print "Hello $LOGNAME!"
	echo "I don't care"		print "I don't care"
	echo "The date is `date`"	print "The date is $(date)"
	echo "\\\\" -> \		print "\\\\" -> \




*************************************
* REGULAR EXPRESSION METACHARACTERS *
*************************************

METACHARACTER	FUNCTION			EXAMPLE		WHAT IT MATCHES
-------------	--------			-------		---------------
^		beginning of line anchor	/^love/		matches all lines beginning with "love"

$		end of line anchor		/love$/		matches all lines ending with love

.		matches one character		/l..e/		matches all lines containing an l,
								followed by 2 characters, followed by an e.

*		matches zero or more of		/ *love/	matches lines with zero or more
		of the preceding characters			spaces, followed by the pattern "love"

[]		matches one in the set		/[Ll]ove/	matches lines containing love or Love.

[x-y]		matches one character within	/[A-Z]ove/	matches letters A to Z followed by ove.
		a range in the set

[^]		matches one character not	/[^A-Z]/	matches lines not containing capital A to Z.
		in the set				

\		Used to escape a metacharacter	/love\./	matches line containing love, followed by a
								literal period. Normally a period matches one
								of any character.

\<		beginning of word anchor	/\<love/	matches lines containing a word that begins
								with love (supported by vi & grep).

\>		end of word anchor		/love\>/	matches lines containing a word that ends
								with love (supported by vi & grep).

\(..\)		Tags match metacharacter	/\(love\)able	may use upto 9 tags, starting with the 1st tag
		to be used later.		\1er/		at the leftmost part of the pattern. For example,
								the pattern love is saved as tag 1, to be used
								for referenced later as \1; in this example, the
								search pattern consists of loveable, followed by 
								lover (supported by sed, vi & grep).

x\{m\}		repetition of character		o\{5,10\}	matches if line contains between 5 & 10 consecutive
		x m times					o's (supported by vi and grep).

x\{m,\}		at least m times		

x\{m,n\}	at least m and not more than n times


****************
* GREP OPTIONS *
****************

OPTION		WHAT IT DOES
------		------------
-b		precedes each line by the block number on which it was found. This is sometimes useful in
		locating disk block numbers by context.

-c		displays a count of matching lines rather than displaying the lines that matches.

-h		does not display filenames.

-i		case insensitive.

-l		list only the names of files with match lines (once), separated by newline characters.

-n		precedes each line by its relative line number in the file.

-s		work silently, i.e. displays nothing except error messages. This is useful for checking exit status.

-v		inverts the search to display only lines that do not match.

-w		search for the expression as a word, as if surround by \< and \>. This applies to grep only.
		(not SCO Unix)
*********
* EGREP *
*********

METACHARACTER	FUNCTION			EXAMPLE		WHAT IT MATCHES
-------------	--------			-------		---------------
+		matches one or more of		'[a-z]+ove'	matches one or more lower case letters, followed
		the preceding characters			by ove. Would find move, approve, love, behoove, etc.

?		matches zero or one of		'lo?ve'		matches for an l followed by either one or not any o's
		the preceding characters			at all. Would find love or lve.

a|b		matches either a or b		'love|hate'	matches either love or hate.

()		group characters		'love(able|ly)'	matches for loveable, or lovely.
						'(ov)+'		Matches for one or more occurrences of ov.

EGREP COMMAND				WHAT IT DOES
-------------				------------
egrep '^ +' file			prints lines beginning with 1 or more space.
egrep '^ *' file			prints lines beginning with zero or more spaces.
egrep '(Tom| Dan) Savage' file		prints lines containing Tom Savage or Dan Savage.
egrep '^X[0-9]?' file			prints lines beginning with X followed by zero or one single digit.
egrep '(ab)+' file			prints lines with one or more ab's
egrep '[A-Z]+' file			prints lines containing one or more capital letters.
egrep '[0-9]' file			prints lines containing a number.


*******
* SED *
*******


COMMAND		FUNCTION
-------		--------
a\		appends 1 or more lines of text to the current line.
c\		changes (replaces) text in the current line with new text.
d		deletes lines.
i\		insert text above the current line.
h		copies the contents of the pattern space to a holding buffer.
H		appends the contents of the pattern space to a holding buffer.
g		getswhat is in the holding buffer and copies it into the pattern buffer, overwriting what was there.
G		gets what is in the holding buffer & copies it into the pattern buffer, appending to what was there.
l		list non printing characters.
p		prints lines.
n		reads the next i/p line & starts processing the newline with the next command rather than the 1st 
		command.
q		quits or exits sed.
r		reads lines from a file.
!		applies the command to all lines "except" the selected ones.
s		substitutes one string for another.


**********************
* SUBSTITUTION FLAGS *
**********************

g		globally substitutes on a line.
p		prints line.
w		writes lines out to a file.
x		exchanges contents of the holding buffer with the pattern space
y		translates one character to another (cannot use regular expression metacharacters with y).


***************
* SED OPTIONS *
***************

OPTIONS		FUNCTION
-------		--------
-e		allow multiple edits.
-n		suppress default o/p.
-f		precedes a sedscript filename.

************
* EXAMPLES *
************

1) sed '1,3 d' datafile - all lines of "file" are printed, except lines 1,2,and 3 or deletes lines 1,2 and 3.

2) sed -n '/[Jj]ohn/p' datafile - only lines matching the pattern John or john in "file" are printed.

3) sed '/Tom/d' datafile - deletes all line containing the pattern Tom.

4) sed '/Tom/!d' datafile - deletes lines NOT containing Tom.

5) sed -n '/north/p' datafile - only lines containing the pattern north are printed.

6) sed '3,$ d' datafile - third line through last line are deleted.

7) sed 's/west/north/g' datafile - all occurrences of west are replaced by north.

8) sed -n 's/^west/north/p' datafile 
if west is found at the beginning of the line, then replaced by north and only those lines are printed.

9) sed 's/[0-9][0-9]$/&.5/' datafile 
   the ampersand (&) in the replacement string represents exactly what was found in the search string. 
   Each line that ends in 2 digits will be replaced by itself, and .5 will be appended to it.

10) sed -n 's/Hemenway/Jones/g p' datafile 
    all occurrences of Hemenway are replaced with Jones, and only the lines that changed are printed. 
    The -n option combined with the p command suppresses the default output. The g stands for global 
    substitution across the line.

11) sed -n 's/\(Mar\)got/\1ianne/p' datafile 
    the pattern Mar is enclosed in parentheses and saved as tag 1 in a special register. It will be 
    referenced in the replacement string as \1. Margot is the replaced with Marianne.

12) sed 's#3#88#g' datafile - the character after the s command is the delimiter between the search string and
    the replacement string. The delimiter character is a forward slash by default, but can be changed 
    (only when the s command is used). Whatever character follows the s command is the new string delimiter. 
    This technique can be useful when searching for patterns containing forward slash, such as pathnames or dates.

13) sed -n '/west/,/east/p' datafile - all lines in the ranger of patterns between west and east are printed.
    If west were to appear on a line after east, the lines from west to the next east or to the end of the file, 
    whichever comes first, would be printed.

14) sed -n '5,/^northeast/p' datafile - prints the lines from line 5 through the first line that begins with northeast.

15) sed '/west/,/east/s/$/**VACA**/' datafile - for lines in the range between the pattern west and east, the end of line
    ($) is replaced with the string **VACA**. The new line is moved over to the end of the new string.

16) sed -e 1,3d' -e 's/Hemenway/Jones/' datafile - the -e option allows multiple edits. The first edit removes lines
    1 through 3. The second edit substitutes Hemenway with Jones. Since both edits are done on a per-line basis 
    (i.e., both commands are executed on the current line in the pattern space), the order of the edits may affect 
    the outcome differently. For example, if both commands had performed substitution on the line, the first
    substitution could affect the second substitution.

17) 

$ cat newfile
	*** Welcome to the world of SED ***
$ sed '/Tony/r newfile' datafile

western		WE	Will Spittle	3.0	3	34
southern	SO	Sharon Grey	5.3	5	23
southeast	SE	John Lewis	2.7	2	18
northeast	NE	Tony Black	5.1	4	15
	*** Welcome to the world of SED ***
eastern		EA	Ann King	4.0	4	17
north		NO	Mark Jones	4.4	5	20

The r command reads specified lines from a file. The contents of "newfile" are read into the input file "datafile",
after the line where the pattern Tony is matched, the contents of newfile would read. If Tony had appeared on more
than 1 line, the content of newfile would have been read in under each occurrence.

18) sed -n '/north/w newfile' datafile

The w command writes specified lines to a file. All lines containing the pattern "north" are written to a file
    called "newfile".

19) sed '/^north /a\\
---> The north region is closed down <---' datafile

The "a" command is the append command. After the lines beginning with the pattern north, when north is followed
by a space. The above text will be appended after that line.

20) sed 'eastern/i\\
New England Region\\
------------------' datafile

The i command is the insert command. If the pattern eastern is matched, the i command causes the text following
the backslash to be inserted above the line containing eastern. A backslash is required after each line to be
inserted, except the last one.(The extra backslash is for the C shell)

21) sed '/eastern/{n; s/AM/Archie/;}' datafile

If the pattern eastern is matched on a line, the n command causes sed to get the next line of i/p (the line with AM),
replace the pattern space with this line, substitutes(s) AM with Archie, print the line, and continue.

22) sed '1,3 y /abcdefghijklmnopqrstwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/' datafile

For lines 1 through through 3, the y command translates all lowercase letters to uppercase letters. Regular
expression metacharacters do not work with this command.

23) sed '5q' datafile

After the line 5 is printed, the q command causes sed program to quit.

24) sed '/Lewis/{s/Lewis/Joseph/;q;}' datafile

When the pattern Lewis is matched on a line, first the substitution command (s) replaces Lewis with Joseph,
and then the q command causes sed program to quit

25) sed -e '/northeast/h' -e '$G' datafile

As sed processes the file, each line is stored in a temporary buffer called the "pattern space". Unless the
line is deleted or suppress from printing the line will be printed to the screen after it is processed.
The pattern space is then cleared and the next line of input is stored there for processing.

In this example, after the line containing the pattern northeast is found, it is placed in the pattern
space and the h command copies it and places it into another special buffer called the "holding buffer".
In the 2nd sed instruction, when the last line is reached ($) the G command tells sed to get the line
from the holding buffer and put it back in the pattern space buffer, appending it to the line that is 
currently stored there, in this case the last line. Simply stated: Any line containing the pattern 
northeast will be copied and appended to the end of the file.

26) sed -e '/WE/{h;d;}' -e '/CT/{G;}' datafile

If the pattern WE is found on a line, the h command causes the line to be copied from the pattern space
into a holding buffer. When stored in the holding buffer, the line can be retrieved (G or g command) at a
later time. In this example, when the pattern WE is found; the line in which it was found is stored in
the pattern buffer first. The h command then puts a copy of the line in the holding buffer. The d command
deletes the copy in the pattern buffer. The 2nd command searches for CT in a line, and when it is found,
sed gets (G) the line that was stored in the holding buffer and appends it to the line currently in the 
pattern space. Simply stated: the line containing WE is moved and appended after the line containing CT.

27) sed -e '/WE/{h;d;}' -e '/CT/{g;}' datafile

If the pattern WE is found, the h command copies the line into the "holding buffer"; the d command 
deletes the line in the pattern space. When the pattern CT is found, the g command gets the copy in the
holding buffer and overwites the line currently in the pattern space. Simply stated: Any line containing
the pattern WE will be moved to overwrite lines containing CT.

28) sed -e '/Patricia/h' -e '/Margot/x' datafile

The x command exchanges (swaps) the contents of the holding buffer with the current pattern space.
When the line containing the pattern Patricia is found, it will be stored in the holding buffer.
When the line containing Margot is found; the pattern space will be exchanged for the line in the
holding buffer. Simply stated: The line containing Margot will be replaced with the line containing
Patricia.

*********************************************
SED SCRIPTING - sed -f sedscript datafile
*********************************************

/western/,/southeast/{
   /^ *$/d
  /Suan/{h;d;}
}
/Ann/g
s/TB \(Savage\)/Thomas \1/
------------------------------------

*******
* AWK *
*******

Awk scans a file (or input) line by line, from the first to the last line, searching for lines that matches a
specified pattern and performing selected actions (enclosed in curly braces) on the lines. If there is a pattern
with no specific action, all lines that match the pattern are displayed; if there is an action with no pattern, 
all input lines specified by the action are executed upon.

********************
* INPUT FROM FILES *
********************

1) awk 'pattern' datafile
2) awk '{action}' datafile
3) awk 'pattern {action}' datafile

***********************
* INPUT FROM COMMANDS *
***********************

The output from a Unix command or commands can be piped to awk for processing. Shell programs commonly use
awk for manipulating commands.

	* command | awk 'pattern'
	* command | awk '{action}'
	* command | awk 'pattern {action}'

e.g. 

1) df | awk '$4 > 75000' - the df command reports the free disk space on file system. The output of the df
command is piped to awk. If the 4th field is greater than 75000 blocks, the line is printed.

2) date --->  Wed Jul 28 22:23:16 BST 2000

date | awk '{print "Month: "$2 "\nYear: ",$6}'

---> Month: Jul
     Year: 2000

3) cat employees

Tom Jones	4424	5/12/66		543354
Mary Adams	5346	11/4/63		287650
Sally Chang	1654	7/22/54		650000
Billy Black	1683	9/23/44		336500

$ awk '/Sally/{print "\t\tHave a nice day, "$1,$2"\!"}' employees
		Have a nice day, Sally Chang!

If the line contains the pattern Sally, the print function prints two tabs, the string "Have a nice day",
the first (where $1 is Sally) and second fields (where $2 is Chang) followed by a string containing an 
exclamation mark.

************
* THE OFMT *
************

When printing numbers the OFMT can be used to control the format of the number. By default it is set to
"%.6g" six significant digits to the right of the decimal are printed.

$ awk 'BEGIN {OFMT="%.2f"; print 1.2456789, 12E-2}'
1.25 0.12

The OFMT variable is set so that floating point numbers (f) will be printed with two numbers following the 
decimal point. The percent sign (%) indicates a format is being specified.

$ echo "UNIX" | awk '{printf "#%-15s#\n",$1}'
#UNIX         #

$ echo "UNIX" | awk '{printf "#%15s#\n",$1}'
#         UNIX#

The output of the echo command, UNIX, is piped to awk. The "printf" function contains a control string.
The % sign alerts printf that it will be printing a 15 space, left justified string enclosed in # and 
terminated by a newline. The dash after the % sign indicates left justification (no dash means right
justification.) The control string is followed by a comma and $1. The string UNIX will be formatted
according to the format specification in the control string.

$ awk '{printf"The name is: %-15s ID is %8d\n", $1,$3}' employees
The name is Tom		ID is  4424
The name is Mary	ID is  5346
The name is Sally       ID is  1654
The name is Billy	ID is  1683

The string to be printed is enclosed in double quotes. The first format specifier is %15s. It has a
corresponding argument, $1, positioned directly to the right of the comma after the closing quotes 
in the control string. The % sign indicates a format specification. The dash means left justify, the
15s means 15-space string. At this spot, print a left-justified, 15-spaced followed by the string ID is 
and a number.

The %d format specifies that the decimal(integer) value of $3 will be printed in its place within the string.
The number will be right justified and take up 8 spaces. Placing the quoted string and expressions within
parenthesis is optional.


***********************************
* AWK COMMANDS FROM WITHIN A FILE *
***********************************

If awk commands are placed in a file, the -f option is used with the name of the awk file, followed by the
name of the input file to be processed. A record is read into awk's buffer and each of the commands in the
awk file are tested and executed for that record. After awk has finished with the first record, it is
discarded and the next record is read into the buffer, and so on.

If an action is not controlled by a pattern, the default behaviour is to print the entire record. If a 
pattern does not have an action associated with it, the default is to print the record where the pattern
matches an input line.

$ cat awkfile
/^Mary/{print "Hello Mary!"}
{print $1,$2,$3}

$ awk -f awkfile employees

If the record begins with the regular expression Mary, the string "Hello Mary!" is printed. The action is
controlled by the pattern preceding it. Fields are separated by white space.

The 1st, 2nd and 3rd field of each record are printed. The action occurs for each line because there is
not a pattern controlling the action.


***********
* RECORDS *
***********

By default, each line of the input data is called a record and is terminated by a newline.

********************
* RECORD SEPARATOR *
********************

By default, the output and input record separator (line separator) is a carriage return, stored in the
built-in awk variables ORS and RS respectively. The ORS and RS values can be changed, but only in a 
limited fashion.

*******************
* THE $0 VARIABLE *
*******************

An entire record is referenced as $0 by awk (when $0 is changed by substitution or assignment, the value
of NF, the number of fields, may be changed). The newline value is stored in awk built-in variable RS,
a carriage return by default.

*******************
* THE NR VARIABLE *
*******************

The number of each record is stored in awk's built-in variable, NR. After a record has been processed,
the value of NR is incremented by one.

$ awk '{print NR, $0}' employees
1 Tom Jones	4424	5/12/66		543354
2 Mary Adams	5346	11/4/63		28765
3 Sally Chang   1654	7/22/54		650000
4 Billy Black	1683	9/23/44		336500

Each record, $0, is printed as it is stored in the file and is preceded with the number of the record, NR.

**********
* FIELDS *
**********

$ awk '{print NR,$1,$2,$5}' employees

awk will print the number of the record (NR), and the 1st, 2nd and 5th field (column) of each line in the
employees file (white space separated by default).

********************
* FIELD SEPARATORS *
********************

FS by default is space and/or tabs, stripping leading blanks and tabs.

$ awk -F: " " '/Tom Jones/ {print $1,$2}' employees

***************************************
* USING MORE THAN ONE FSs (nawk only) *
***************************************

$ nawk -F '[ :\t]' '{print $1, $2, $3}' employees

A space, colon or tab is used as field separator (must surround in single quotes to prevent shell
from interpretation).

**************************
* OUTPUT FIELD SEPARATOR *
**************************

By default a single space is for OFS. If default is used, the comma inserted $1,$2 will evaluates to a single
space and the print function will prints the fields with a space between them. OFS will not be evaluated unless
the comma separates the fields.

************************
* PATTERNS AND ACTIONS *
************************

************
* PATTERNS *
************

awk "patterns" control what action awk will take on a line of input, which consists of regular expression,
or a combination of these. The default is to print each line where the expression results in a true condition.
When reading a pattern expression, there is an implied "if" statement. When an "if" is implied there can be no
curly braces surrounding it. When the if is explicit it becomes an action statement and the syntax is different.

$ awk '$3 < 4000' employees
$ awk '$0 ~ /Tom/ {print $0}' employees

***********
* ACTIONS *
***********

Actions are statements enclosed within curly braces and separated by semicolons. If a pattern precedes an action,
the pattern dictates when the action will be performed. Action can be simple statements or complex groups of 
statements. Statements are separated by semicolons, or by a newline if place on their own line.

pattern { action statement;action statement;etc}
or
pattern {
 	action statement
	action satement
}

$ awk '/Tom/{print "Hello there, "$1}' employees
$ awk '$1 ~ /[Bb]ill/' employess
$ awk '$1 !~/ly$/' employees

*********************************
* AWK COMMANDS IN A SCRIPT FILE *
*********************************

When you have multiple awk pattern/action statements, it is often much easier to put the statements in a script.
The script is a file containing awk comments and statements. If statements and actions are on the same line, they
are separated by semicolons. If statements are on separate lines, semicolons are not neccessary. If an action
follows a pattern, the opening curly brace must be on the same line as the pattern.

# script name : info.awk
/Tom/{print "Tom's birthday is "$3}
/Mary/{print NR, $0}
/^Sally/{print "Hi Sally. " $1 "has a salarly of $" $4 "."}
# End of info.awk script

$ awk -F: -f info.awk employees
$ awk '$5 ~ /\.[7-9]+/' datafile
If the 5th field ($5) contains a literal period, followed by one or more numbers between 7 and 9, the record
is printed.

$ awk '$2 !~ /E/ { print $1, $2}' datafile
$ awk '$3 ~ /^Joel/{print $3 "is a nice guy"}' datafile
$ awk '$8 ~ /[0-9][0-9]$/{print $8}' datafile
$ awk '$4 ~ /Chin$/{print "The print is $" $8 "."}' datafile
$ nawk -F "[ :]" '{print $1,$2}' datafile



******************************
* AWK PROGRAMMING CONSTRUCTS *
******************************


***************************
* CONDITIONAL EXPRESSIONS *
***************************

	Conditional expression1 ? expression2 : expression3

$ nawk '{max=($1>$2) ? $1 : $2; print max}' filename

If the first field is greater than the second field, the value of the expression after the question mark is
assigned to max, otherwise the value after the colon is assigned to max. This is comparable to

		if ($1 > $2)
		  max = $1
		else
		  max = $2

$ cat /etc/passwd | nawk -F: '\
NF != 7 { printf("line %d, does not have 7 fields : %s\n",NR,$0)}\
$1 !~ /[A-Za-z-0-9]/ {printf("line %d, nonalphanumeric user id : %s\n", NR, $0}\
$2 == "*" {printf("line %d, no password : %s\n",NR,$0)}'

$ nawk '$7 == 5' datafile
$ nawk '$2 == "CT" {print $1,$2}' datafile
$ nawk '$7 != 5' datafile
$ nawk '$7 < 5 {print $4,$7}' datafile
$ nawk '$6 > .9 {print $1, $6}' datafile
$ nawk '$8 <= 17 {print $8}' datafile
$ nawk '$8 >= 17 {print $8}' datafile
$ nawk '$8 >10 && $8 <17' datafile
$ nawk '$2 == "NW" || $1 ~ /South/ {print $1, $2}' datafile
$ nawk '!($8==13) {print $8}' datafile
$ nawk '/Southern/ {print $5 + 10}' datafile
$ nawk '$3 ~ /^Susan/ {print "Percentage: "$6 + .2 "Volume: " $8}' datafile
$ nawk '{print ($7 > 4 ? "high " $7 : "low " $7) }' datafile
$ nawk '$3 == "Chris" {$3 = "Christian"; print}' datafile
$ nawk '/Derek/ {$8 += 12; print $8}' datafile
$ nawk '{$7 %= 3; print $7}' datafile
$ nawk '$1 ~ /Tom/ { wage = $2 * $3; print wage}' datafile
$ nawk '{$5 = 1000 * $3/$2; print}' datafile
If $5 does not exists, awk will create it and assign the result of the expression 1000 * $3/$2 to the
fifth field ($5). If the fifth field exists, the result will be assigned to it, overwriting what was there.

$ nawk '$4 == "CA" {$4 = "California"; print}' datafile

**********************
* BUILT-IN VARIABLES *
**********************

ARGC		number of command line arguments
ARGV		array of command line arguments
FILENAME	name of current input file
FNR		record number in current file
FS		the input field separator, by default a space
NF		number of fields in current record
NR		number of records so far
OFMT		output format for numbers
OFS		output field separator
ORS		output record separator
RLENGTH		length of string matched by "match" function
RS		input record separator
RSTART		offset of string matched by "match" function
SUBSEP		subscript separator

******************
* BEGIN PATTERNS *
******************

The BEGIN pattern is followed by an action block that is executed "before awk" processes any lines from the 
input file. In fact, a BEGIN block can be tested with any input file, since awk does not start reading until
the BEGIN action block has completed. The BEGIN action is often used to change the value of the built-in
variables, OFS, RS, FS and so forth, to assign initial values to user-defined variables, and to print headers
or titles as part of the output.

$ nawk 'BEGIN { FS=":"; OFS="\t"; ORS="\n\n"} {print $1, $2, $3}' datafile
$ nawk 'BEGIN { print "MAKE	YEAR"}'

END PATTERNS

END patterns do not match any input lines, but executed any actions that are associated with the END pattern.
END patterns are handled "after" all lines of input have been processed.

$ nawk 'END { print "The number of records is "NR}' datafile

$ nawk '/Mary/{count++} END{print "Mary was found "count "times."}' employees


					
***************
* REDIRECTION *
***************

**********
* OUTPUT *
**********

When redirecting output from within awk to a UNIX file, the shell redirection operator are used. The filename
must be enclosed in double quotes.

$ nawk '$4 >= 70 {print $1, $2 > "passing_file"}' datfile

*******************
* INPUT (GETLINE) *
*******************

The "getline" function is used to read input from the standard input, a pipe, or a file other than from the
current file being processed. It gets the next line of input and sets the NF, NR and the FNR built-in
variables. The "getline" function return 1 if a record is found and zero if EOF is reached. If there is
an error, such as failure to open a file, the "getline" function returns a value of -1.

$ nawk 'BEGIN { "date" | getline d; print d }' filename

$ nawk 'BEGIN { "date" | getline d; split(d,mon); print mon[2] }'

$ nawk 'BEGIN { while("ls" | getline) print}'

$ nawk 'BEGIN{print "what is your name?"; getline name < "/dev/tty"}\
$1~name{print "Found " name "on line ",NR "."}\
END{print "see ya, " name "."} filename

$ nawk 'BEGIN{while(getline < "/etc/passwd" > 0) lc++; print lc}'


Note that the value returned by "getline" is 
		-1 if the file does not exist.
		0 (EOF)
		1 (Line Read)
     while (getline < "/etc/junk") yields an infinite loop if junk does not exist, since the return of -1
yields a true condition.


*********
* PIPES *
*********

If you open a pipe in an awk program, you must close it before opening another one. The command on the RHS of
the pipe symbol is enclosed in dounble quotes. Only one pipe can be opened at a time.

$ nawk '{print $1,$2 | "sort -r +1 -2 +0 -1"}' names
Reverse sort using 2nd field as primary key, 1st field as secondary key.

[

sort +1 -2 filename - sorts starting on field 1 (fields are separated by whitespace and start at field 0),
stopping at field 2 rather than sorting to the end of line.

sort -t: +2n -3 filename - sorts numerically starting at field 3 and stopping at field 4, with the colon
designated as the field separator (-t:).

]

***************************
* CLOSING FILES AND PIPES *
***************************

If you plan to use a file or pipe in an awk program again for reading or writing, you may want to close it first,
since it remains open until the script ends. Once opened, the pipe remains opened until awk exits. Therefore, 
statement in the END block will also be affected by the pipe. The first line in the END block closes the pipe.

# some code in the script
{print $1,$2,$3 | "sort -r +1 -2 +0 -1"}
 END{
     close ("sort -r +1 -2 +0 -1")
     rest of statement
 }

*************************
* THE "SYSTEM" FUNCTION *
*************************

The built-in "system" function takes a UNIX command as its argument, execute the command, and returns the exit
status to the awk program. It is similar to the C standard library function, also called system(). The Unix 
command must be enclosed in double quotes.
	system("UNIX command")

# some line in awk script
{
   system("cat " $1)
   system("clear ")
}

$ nawk '/^north/{count += 1; print count}' datafile
$ nawk '/^north/{count++; print count}' datafile
$ nawk '{x=$7--; print "x = "x ", $7 = " $7}' datafile
$ nawk '{print NR, $0}' datafile
$ nawk 'NR==2, NR==5{print NR, $0}' datafile
$ nawk 'BEGIN{OFMT="%.2f"; print 1.2456789, 12E-2}' datafile
$ nawk '{printf "$%6.2f\n", $6*100}' datafile
$ nawk '/north/{print $1,$3,$4 > "districts"}' datafile

# awk script
BEGIN { FS =":"; OFS="\t"
    print "NAME\t\tDISTRICT\tQUANTITIY"
    print "--------------------------------\n"
}
  {print $1 "\t " $3 "\t\t"$7}
  {total += $7}
  /north/{count++}
END{
   print "---------------------"
   print "The total quantity is" total
   print "The number of northern salespersons is "count "."
}

# awk script using pipe
BEGIN{
     printf "%-22s%s\n", "NAME", "DISTRICT"
     printf "---------------------------------------"
}
/west/{count++}
{ printf "%s %s\t\t%-15s\n",$3,$4,$1 | "sort +1"}
END{
     close "sort +1"
     printf "The number of salespersons in the western "
     printf "region is " count "."
}


**************************
* CONDITIONAL STATEMENTS *
**************************

******
* IF *
******

	if (expression) {
		statement; statement;
	}

$ nawk '{if($6 > 50) print $1 "Too high"}' datafile
$ nawk '{if($6 > 20 && $6 <= 50) {safe++; print "OK"}}' datafile

***********
* IF/ELSE *
***********

	{ if (expression) {
		statement; statement; ...
	  }
	  else {
		statement; statement; ...
	  }
	}

$ nawk '{if($6 > 50) print $1 "Too high";\
	 else print "Range is OK"}' datafile

$ nawk '{if($6 > 50) {count++; print $3}\
	 else {x+5; print $2}' datafile

*******************
* IF/ELSE ELSE IF *
*******************

	{ if (expression) {
		statement; statement; ...
	  }
	  else if (expression) {
		statement; statement; ...
	  }
	  else if (expression) {
		statement; statement; ...
	  }
	  else {
		statement
	  }
	}

# in the script
{ if ($3 > 89 && $3 < 101) Agrade++
  else if ($3 > 79) Bgrade++
  else if ($3 > 69) Cgrade++
  else if ($3 > 59) Dgrade++
  else Fgrade++
}
END{print "The number of failures is "Fgrade}



*********
* LOOPS *
*********


***************
* WHILE LOOPS *
***************

$ nawk '{i=1; while(i <= NF) {print NF, $i; i++}}' filename

*************
* FOR LOOPS *
*************

$ nawk '{for(i=1; i<=NF;i++) print NF, $i}' filename

**********************
* BREAK AND CONTINUE *
**********************

# in the script
{	for(x=3; x<=NF;x++)
	  if($x < 0) {print "Bottom out!"; break}
		# break out of for loop
}

# in the script
{	for(x=3; x<=NF;x++)
	  if($x == 0) {print "Get next item"; continue}
		# start next iteration of the for loop
}

********
* NEXT *
********

# In a script
{ 	if($1 ~ /Peter/) {next}
	else {print}
}

**********
* ARRAYS *
**********

$ nawk '{name[x++]=$2}; END{for(i=0;i<NR;i++)\
print i, name[i]}' datafile

The subscript in array "name" is a user-defined variable, x. The ++ indicates a numeric context. Awk initializes
x to zero and increments x by one "after" it is used. The value of the second field is assigned to each element
of the "name" array. In the END block, the for loop is used to loop through the array, printing the value that
was stored there, starting at subscript zero. Since the subscript is just a key, it does not have to start at
zero. It can start at any value, either a number or a string.

$ nawk '{id[NR]=$3}; END{for(x=1;x<=NR;x++)\
print id[x]}' datafile

The awk variable NR contains the number of the current record. By using NR as a subscript, the value of the 
third field is assigned to each element of the array for each record. At the end, the for loop will loop
through the array, printing out the values that were stored there.


************************
* THE SPECIAL FOR LOOP *
************************

The special "for" loop is used to read through an associative array in cases where the "for" loop is not
practical; that is, when strings are used as subscripts or the subscripts are not consecutive numbers.
The special for loop uses the subscript as a key into the value associated with it.

	{	for(item in arrayname) {
			print arrayname[item]
		}
	}

$ nawk '/^Tom/{name[NR]=$1};\
END {for(i in name) {print name[i]}}' datafile

The special for loop iterates through the array, printing only values where there was a subscript associated
with that value. The order of the printout is random due to the way the associate arrays are stored (hashed).

# datafile
4234	Tom	43
4567	Arch	45
2008	Eliza	65
4571	Tom	22
3298	Eliza 	21
4623	Tom	53
2345	Mary	24

$ nawk '{dup[$2]++; if(dup[$2]>1) {name[$2]++}}\
END {print "The duplicates were"\
for (i in name) {print i, name[i]}}' datafile


*********************************
* ARRAYS AND THE SPLIT FUNCTION *
*********************************

split(string, array, field separator)
split(string array)

$ nawk BEGIN{split("15/3/1999", date, "/");\
print "The month is" date[2] "and the year is" date[3]"}

*******************
* DELETE FUNCTION *
*******************

$ nawk '{line[x++]=$2} END{for(x in line) delete(line[x])}' datafile


********************************************
* PROCESSING COMMAND LINE ARGUMENTS (NAWK) *
********************************************

********
* ARGV *
********

The index of ARGV arrays start at zero

********
* ARGC *
********

Contains the number of command line arguments

# argvs.scr
BEGIN{
	for(i=0;i<=ARGC;i++){
	  printf("argv[%d] is %s\n",i,ARGV[i])
	}
	printf("The number of arguments, ARGC=%d\n", ARGC)
}

$ nawk -f argvs.scr datafile
argv[0] is nawk
argv[1] is datafile
The number of arguments, ARGC=2

$ nawk -f argvs.scr datafile "Peter Pan" 12
argv[0] is nawk
argv[1] is datafile
argv[2] is Peter Pan
argv[3] is 12
The number of arguments, ARGC=4


**************************
* AWK BUILT-IN FUNCTIONS *
**************************

*************************
* SUB AND GSUB FUNCTION *
*************************

The "sub" function matches the regular expression for the largest and leftmost substring in the record, and
then replaces that substring with the substitution string. If a target string specified, the regular expression
is matched for the largest and leftmost substring in the target string, and the substring is replaced with the
substitution string. If the target string is not specified, the entire record is used

sub(regular expression, substitution string)
sub(regular expression, substitution string, target string)

$ nawk '{sub(/Mac/, "MacIntosh"); print}' filename
The first time the regular expression Mac is matched in the record ($0), it will be replaced with the string
"MacIntosh". The replacement is made only on the first occurrence of a matched on the line.

$ nawk '{sub(/Mac/, "MacIntosh", $1); print}' filename
The first time the regular expression Mac is matched in the first field of the record, it will be replaced
with the string MacIntosh. The replacement is made only on the first occurrence of a match on the line for
the target string.

gsub(regular expression, substitution string)
gsub(regular expression, substitution string, target string)

$ nawk '{gsub(/CA/, "California"); print}' datafile
$ nawk '{gsub(/[Tt]om/, "Thomas", $1); print}' datafile


******************
* INDEX FUNCTION *
******************

The index function returns the first position where the substring is found in a string. Offset starts at position
one.

index(string, substring)

$ nawk '{print index("hollow", "low")}' filename ---> 4
The number return is the "position" where the substring "low" is found in "hollow", with the offset starting at one.

**********
* LENGTH *
**********

The length function returns the number of characters in a string. Without an argument, the length function
returns the number of characters in a record

length(string)
length

$ nawk '{print length("hello")}'  ----> 5

*******************
* SUBSTR FUNCTION *
*******************

The substr function returns the substring of a string starting at a position where the first position is one.
If the length of the substring is given, that part of the string is returned. If the specified length exceeds
the actual string, the string is returned.

substr(string, starting position)
substr(string, starting position, length of string)

$ nawk '{print substr("Santa Clause",7,6)}'


******************************
* MATCH FUNCTION (NAWK ONLY) *
******************************

The match function returns the index where the regular expression is found in the string, or zero if not found.
The match function sets the built-in variable RSTART to the starting position of the substring within the
string, and RLENGTH to the number of characters to the end of the substring. These variables can be used with the
substr function to  extract the pattern.

match(string, regular expression)

$ nawk 'END {start=match("Good ole USA", /[A-Z]+$/); print start}' filename ----> 10
The regular expression, /[A-Z]+$/, says search for consecutive uppercase letters at the end of the string.
The substring "USA" is found starting at the 10th character of the string "Good ole USA". If the string
cannot be matched, 0 is returned.

$ nawk 'END{start=match("Good ole USA", /[A-Z]+$/);\
print RSTART, RLENGTH}' filename  ----> 10 3
The RSTART variable is set by the match function to the starting position of the regular expression matched.
The RLENGTH variable is set to the length of the substring.

$ nawk 'BEGIN{line="Good ole USA"};\
END{match(line, /[A-Z]+$/);\
print substr(line, RSTART, RLENGTH)}' filename     ------> USA

The substr function is used to find a substring in the variable "line", and uses the RSTART and RLENGTH values
(set by the match function) as the beginning and length of the substring.



******************
* SPLIT FUNCTION *
******************

The split function splits a string into an array using whatever field separator is designated as the third
parameter. If the third parameter is not provided, awk will use the current value of FS.

split(string, array, field separator)
split(string, array)

********************
* sprintf FUNCTION *
********************

The sprintf function returns an expression in a specified format. It allows you to apply the format specification
of the printf function.

variable=sprintf("string with format specifiers", expr1, expr2, ...)

$ awk '{line=sprintf("%-15s %6.2f", $1, $3); print line}' filename
------

# awk script illustrating arrays - nawk.scr
BEGIN{ OFS="\t" }
{ list[NR]=$1}
END{ for(n=1; n<=NR; n++){
	print list[n] }
}

$ nawk -f nawk.scr datafile  # at the command line

# nawk.scr1 - awk script with special for loop
/north/{name[count++]=$3}
END{print "The number living in a northern district: "count
    print "Their names are: "
    for (i in name)	# special nawk "for loop" used to iterate through the array
	print name[i]
}

$ nawk -f awk.scr1 datafile
The number living in a northern district: 3
Their names are:
Joel
TJ
Val


$ nawk '{printf substr($0,1,6)" "; printf substr($0,7,6)" ";\
	 printf substr($0,13,length)}' filename_fixed


# awkfix.scr - preserving the empty field. Field width is fixed
{
  f[1]=substr($0,1,3)
  f[2]=substr($0,5,3)
  f[3]=substr($0,9,3)
  line=sprintf("%-4s%-4s%-4s\n",f[1],f[2],f[3])
  print line
}

$ nawk -f awkfix.scr datafile

$ nawk -F: '{gsub(/\$/," "); gsub(/,/," "); cost +=$7};\
END{ print "The total is $" cost}' datafile

The first gsub function globally substitute the literal dollar sign (\$) with the null string, and the second
gsub substitute commas with a null string. The user-defined "cost" variable is then totalled by adding the 7th
field to cost and assigning the result back to cost. In the END block, the string "The total cost is $" is printed,
followed by the value of cost.



******************
* BUNDLE PROGRAM *
******************

$ nawk '{print FILENAME, $0}' file1 file2 file3 > bundled

The name of the current input file, FILENAME, is printed, followed by the record ($0) for each line of the input
in file1. After file1 has reached the end of file, awk will open the next file, file2, and do the same thing, and
so on. The output is redirected to a file called "bundled".

********************
* UNBUNDLE PROGRAM *
********************

$ nawk '$1 != previous {close(previous); previous=$1};\
{print substr($0, index($0, " ") +1 ) > $1}' bundled

The first field is the name of the file. If the name of the file is not equal to the value of the user defined
variable "previous" (initially null), the action block is executed. The file assigned to previous is closed,
and previous is assigned the value of the first field. Then the substr of the record, the starting position 
returned from the index function (the position of the first space + 1, is redirected to the filename contained
in the first field).

To bundle the files so that the filename appears on a line by itself, above the contents of the file, use
the following command:

$ nawk '{if(FNR==1){print FILENAME; print $0}\
else print $0}' file1 file2 file3 > bundled

The following command will unbundle the files:

$ nawk 'NF==1{filename=$NF};\
NF != 1 {print $0 > filename }' bundled



**********************
* MULTI-LINE RECORDS *
**********************

If the records are separated by blank lines and the fields are separated by newlines. To process this, the 
record separator (RS) is assigned a value of null, and the field separator (FS) is assigned the newline.

# multiline_awk.scr
BEGIN { RS=""; FS="\n"; ORS="\n\n"}
{print NR, $1, $2, $3, $4}

$ nawk -f multiline_awk.scr datafile

In the BEGIN block, the record separator (RS) is assigned null, the field separator (FS) is assigned a newline,
and the output record separator (ORS) is assigned two newlines. Now each line is a field and each output record
is separated by two newlines. The number of the record is printed, followed by each of the fields.


*************
* FUNCTIONS *
*************

Define a function				function func_name {commands}
Call a function					func_name or func_name param1 param2 ...



***************
* COPROCESSES *
***************

A coprocess is a special two-way pipeline that allows the shell script to write to the standard input of another
command and to read from it. This provides a way to create a new interface for an existing program. The append 
operator, |&, is placed at the end of the command to initiate the command as a coprocess. Normal redirection
and background processing should not be used on coprocess. The "print" and "read" commands require a "-p" switch
to read from and write to a coprocess. The output must be sent to the standard output and have a newline at
the end of each message of output. You can run multiple coprocesses by using the "exec" command with the >&p
or <&p operator. To open file descriptor 4 as a coprocess, you would enter exec 4>&p.

#!/bin/ksh
# mycalculator - A simple calculator which uses the bc command to perform the calculation. Since the shell
# performs operation on integers only, this program allows you to use floating point numbers by writing
# to and reading from the bc program.

cat <<!
	******* Welcome to the calculator program *******
!
bc |& 	# open coprocess
while true
do
  print "Select the letter for one of the operator below"
  cat <<-!
	a) +
	s) -
	m) *
	d) /
	e) ^
  !
  read op
  case op in 
	a) op="+";;
	s) op="-";;
	m) op="*";;
	d) op="/";;
	e) op="^";;
	*) print "Bad operator"
	   continue;;
  esac
  print -p scale=3				# write to the coprocess
  print "Please enter two numbers: "		# write to standard output
  read num1 num2				# read from standard input
  print -p "$num1" "$op" "$num2"		# write to the coprocess
  read -p result				# read from the coprocess
  print $result
  print -n  "continue (y/n)? "
  read answer
  case $answer in
     [Nn]*)
       break;;
  esac
done
print Good-bye



*************
* DEBUGGING *
*************

By turning on the "noexec" option or using the "-n" argument to the ksh command, you can check the syntax of your
script without really executing any of the commands. If there is a syntax error in the script, the shell will 
report the error. If there are no errors, nothing is displayed.

The most commonly used method for debugging scripts is to turn on the "xtrace" option or to use the ksh command
with the -x option. With the "verbose" option turned on, or by invoking the korn shell with the -v option
(ksh -v scriptname), each line of the script will be displayed, just as it was typed in the script, and then 
executed it.

COMMAND				FUNCTION				HOW IT WORKS
-------				--------				------------
ksh -x scriptname		invoke ksh with echo option		displays each line of the script after
									variable substitution and before execution.

ksh -v scriptname		invokes ksh with verbose option		displays each line of the script before
									execution, just as you typed it.

ksh -n scriptname		invokes ksh with noexec option		interprets but does not execute commands.

set -x or set -o xtrace		turns on echo option			traces execution in a script.

set +x				turns off echo				turns off tracing.

typeset -ft			turns on tracing			traces execution in a function.



**************************
* PROGRAMMING CONSTRUCTS *
**************************

******************
* if CONDITIONAL *
******************

if (( numeric expression ))
then
   commands
fi

						
if [[ string expression ]]
then
   commands
fi

***********************
* if/else CONDITIONAL *
***********************

if command
then
   commands
else
   commands
fi				

****************************
* if/elif/else CONDITIONAL *
****************************

if command
then
   commands
elif command
then
   commands
else
   commands
fi				

*******************
* switch and case *
*******************

case value in
   pattern 1) command;;						
   pattern 2) command;;						
   *) command;;						
esac

**************
* while loop *
**************

while command
do
   commands
done


*****************
* until COMMAND *
*****************

until command
do
   commands
done

******************
* select COMMAND *
******************


PS3="Please select a menu item"
Select var in worlist
do
   commands
done

*****************
* break COMMAND *
*****************

while true
do
  read answer?Are you ready to move on\?
  if [[ $answer = [Yy]* ]]
  then
     break
  else
     commands
  fi
done
print "Here we are"

********************
* continue COMMAND *
********************

for name in $(< mail_list)
do
   if [[ "$name" = "Dal" ]]
   then
      continue
   else
      mail $name < memo
   fi
done

****************
* NESTED LOOPS *
****************

#!/usr/bin/ksh

while true
do
  <commands here>
  for user in tom dick harry joe
  do
    if [[ $user = [Dd]* ]]
    then
        continue 2
               <commands here>
               while true
               do
                  <commands here>
                  break 3
               done
    fi
  done
done
print "out of loop"

-----------------------------------------------------------------------------------------

**********************************
* USEFUL SHELL SCRIPTS/FUNCTIONS *
**********************************

##
# what_day
#
# Function to determine the day of the week for a given day
# parameter format YYYY-MM-DD
##

what_day(){
DATE=$1
YEAR=$(print $DATE | awk -F\- '{ print $1 }')
MONTH=$(print $DATE | awk -F\- '{ print $2 }')
DAY=$(print $DATE | awk -F\- '{ print $3 }')
#
# Strip off leading 0's if any
#
DAY=$(print $DAY | sed s/"^0"//g)
MONTH=$(print $MONTH | sed s/"^0"//g)
line=$(cal $MONTH $YEAR | egrep "^$DAY | $DAY$| $DAY ")
SUN=$(print "$line" | awk '{ print substr($0,1,3) }' | awk '{ print $1 }')
MON=$(print "$line" | awk '{ print substr($0,4,3) }' | awk '{ print $1 }')
TUE=$(print "$line" | awk '{ print substr($0,7,3) }' | awk '{ print $1 }')
WED=$(print "$line" | awk '{ print substr($0,10,3) }' | awk '{ print $1 }')
THU=$(print "$line" | awk '{ print substr($0,13,3) }' | awk '{ print $1 }')
FRI=$(print "$line" | awk '{ print substr($0,16,3) }' | awk '{ print $1 }')
SAT=$(print "$line" | awk '{ print substr($0,19,3) }' | awk '{ print $1 }')
case $DAY in
	$SUN)   print "Sun";;
	$MON)   print "Mon";;
	$TUE)   print "Tue";;
	$WED)   print "Wed";;
	$THU)   print "Thu";;
	$FRI)   print "Fri";;
	$SAT)   print "Sat";;
esac
}
#what_day $1
------------------------------------------------------------

##
# set_date
##

##
# Function to set the new process date to the previous working day
##

set_process_dates(){
TODAY=$(date "+%C%y-%m-%d")
DAYOFWEEK=$(what_day $TODAY)
NEWPROCESSDAY=$(decrement_date 1 $TODAY)
#
# If Today is Monday then the NEWPROCESSDAY variable 
# needs to point at Saturday and not Sunday
#
if [ "$DAYOFWEEK" = "Mon" ]
then
	NEWPROCESSDAY=$(decrement_date 2 $TODAY)
fi	
print "$NEWPROCESSDAY" 
}

START_DATE=$(set_process_dates)
END_DATE=$DATE_TODAY
-------------------------------------------------------------
##
# dater
##

#
# Function to decrement the original date ($2) by a specific number of days
# defined by parameter $1
# Usage : decrement_date 5 2000-12-25 ( returns 2000-12-20 )
# Note  : If $2 is -ve then the function will increment the date
#
decrement_date(){
BACKDAYS=$1
ORIGDATE=$2
YR=$(echo $ORIGDATE | awk -F\- '{ print $1 }')
MN=$(echo $ORIGDATE | awk -F\- '{ print $2 }')
DY=$(echo $ORIGDATE | awk -F\- '{ print $3 }')
#
# Subtract Days
#
RES=$(expr $DY - $BACKDAYS)
#
# If RES > 0 then this bit was easy, else we need tocheck whether the
# Month or even Year boundaries have been crossed taking into account
# Leap years and Year 2000!
#
if [ $RES -gt 0 ]
then
	if [ $RES -lt 10 ]
	then
		RES="0"$RES
	fi
	echo "$YR-$MN-$RES"
else
	#
	# Determine if Month or Year Boundaries have been crossed
	#
	# Subtract Current Day from BACKDAYS
	# This will leave the number of days to be subtracted from the 
	# Previous month
	#
	BACKDAYS=$(expr $BACKDAYS - $DY)
	#
	# Loop continuosly until finished
	#
	DDLOOP=0
	while [ $DDLOOP -eq 0 ]
	do
		#
		# Decrement the Month. If it becomes 0 then also
		# Decrement the year, and change the month to 12
		#
		MN=$(expr $MN - 1)
		if [ $MN -eq 0 ]
		then
			YR=$(expr $YR - 1)
			MN="12"
		fi
		#
		# Determine the number of days in the current month
		# using the UNIX cal command
		#
		DAYSINMNTH=$(cal $MN $YR | grep "[0-9]" | tail -1 | awk '{ print $NF }')


		#
		# Determine whether date falls into this month
		#
		RES=$(expr $DAYSINMNTH - $BACKDAYS)
		#
		# If RES > 0 and < Days in current month then result is 
		# in this month, so print it
		#
		if [ $RES -gt 0 ] && [ $RES -le $DAYSINMNTH ]
		then
			if [ $RES -lt 10 ]
			then
				RES="0"$RES
			fi
			if [ $MN -lt 10 ]
			then
				MN="0"$MN
			fi
			echo "$YR-$MN-$RES"
			#
			# Exit Loop
			#
			DDLOOP=1
		else
			BACKDAYS=$(expr $BACKDAYS - $DAYSINMNTH)
		fi
	done
fi
}

-------------------------------------------------------------------------

##
# decrement_date
##

#
# Function to decrement the date by a specific number of days
# defined by parameter $1
#
decrement_date(){
BACKDAYS=$1
ORIGDATE=$2
YR=$(echo $ORIGDATE | awk -F\- '{ print $1 }')
MN=$(echo $ORIGDATE | awk -F\- '{ print $2 }')
DY=$(echo $ORIGDATE | awk -F\- '{ print $3 }')
#
# Subtract Days
#
RES=$(expr $DY - $BACKDAYS)
#
# If RES > 0 then this bit was easy, else we need tocheck whether the
# Month or even Year boundaries have been crossed taking into account
# Leap years and Year 2000!
#
if [ $RES -gt 0 ]
then
	if [ $RES -lt 10 ]
	then
		RES="0"$RES
	fi
	echo "$YR-$MN-$RES"
else
	#
	# Determine if Month or Year Boundaries have been crossed
	#
	# Subtract Current Day from BACKDAYS
	# This will leve the number of days to be subtracted from the 
	# Previous month
	#
	BACKDAYS=$(expr $BACKDAYS - $DY)
	#
	# Loop continuosly until finished
	#
	DDLOOP=0
	while [ $DDLOOP -eq 0 ]
	do
		#
		# Decrement the Month. If it becomes 0 then also
		# Decrement the year, and change the month to 12
		#
		MN=$(expr $MN - 1)
		if [ $MN -eq 0 ]
		then
			YR=$(expr $YR - 1)
			MN="12"
		fi
		#
		# Determine the number of days in the current month
		# using the UNIX cal command
		#
		DAYSINMNTH=$(cal $MN $YR | grep "[0-9]" | tail -1 | awk '{ print $NF }')


		#
		# Determine whether date falls into this month
		#
		RES=$(expr $DAYSINMNTH - $BACKDAYS)
		#
		# If RES > 0 and < Days in current month then result is 
		# in this month, so print it
		#
		if [ $RES -gt 0 ] && [ $RES -le $DAYSINMNTH ]
		then
			if [ $RES -lt 10 ]
			then
				RES="0"$RES
			fi
			if [ $MN -lt 10 ]
			then
				MN="0"$MN
			fi
			echo "$YR-$MN-$RES"
			#
			# Exit Loop
			#
			DDLOOP=1
		else
			BACKDAYS=$(expr $BACKDAYS - $DAYSINMNTH)
		fi
	done
fi
}
 
------------------------------------------------------------------------------
##
# IF
##

#!/bin/ksh

###----------------------------------------------------------------------------
# "IF" will "cat" a source file to a screen. If a directory is given it 
# looks for the file in that directory otherwise it will look in the 
# default functions directory.
###----------------------------------------------------------------------------

FDIR=$HOME/functions

###
# Usage to make sure correct parameters are passed
###

USAGE()
{
if [ $# -lt 1 ]
then
	echo "Invalid command arguments"
	echo "Usage : $0 <File_Name> [<Full_Path>]"
	exit
fi
}

###
#  Check to see if we have read permission or the file is a directory
###

CHK_FILE(){

if [ -d $1 ] || [ ! -r $1 ]
then
	echo "The given filename is a directory"
	echo "Or you don't have read permission"
	exit
fi
}

see(){
#if [ x"$2" = x"bin" ]
if [ $2 ]		# if a directory is given then use 
			# the file in that directory
then
	cat $2/$1
else			# Use the default directory
	case $1 in
		"YESNO") cat $FDIR/YESNO ;;
		"Stop") cat $FDIR/Stop ;;
		"decrement_date") cat $FDIR/decrement_date ;;
		"fromto") cat $FDIR/fromto ;;
		"jot") cat $FDIR/jot ;;
		"log") cat $FDIR/log ;;
		"log_end") cat $FDIR/log_end ;;
		"log_start") cat $FDIR/log_start ;;
		"mycal") cat $FDIR/mycal ;;
		"h")	cat << !
	Usage: IF <Function Name>

	Where Function in:

	YESNO
	Stop
	decrement_date
	fromto
	jot
	log
	log_end
	log_start
	mycal
!
		;;
	*) echo "Couldn't find $1 in functions directory to cat"
		;;
	esac
fi
}

###
# Main
###

USAGE $1 $2
#CHK_FILE $1
see $1 $2
###
# End of script
###

----------------------------------------------------------------------------
##
# YESNO
##

###----------------------------------------------------------------------------
#  Useful for Yes No interactive shell script
#  Force the user to enter Y or N only to get out of the loop
#
###----------------------------------------------------------------------------

#set -x
yesno(){
	MESG="Y/N ? "
	ynloop=0
	while [ $ynloop -eq 0 ]
	do
		echo $MESG
		read yesno
		if [ x"$yesno" = "x" ]
		then
			yesno=0
		fi
		yesno=$(echo $yesno | tr "[a-z]" "[A-Z]" | awk '{ print substr($1,1,1) }')
		case $yesno in
			"Y") ynloop=1;;	
			"N") ynloop=1;;	
			*) MESG="Invalid Entry. Enter Y or N ..";;
		esac
	done
}
#echo "Ok then ? \c"
yesno

--------------------------------------------------------------------------------

##
# log_start
##

## ----------------------------------------------------------------------------
# Create log file
## ----------------------------------------------------------------------------
log_start()

{
echo "Starting ${SCRIPT}, version ${VERS}: `date`" > $AUDIT_LOG_NAME
}

-------------------------------------------------------------------------------

##
# mycal
##

#!/usr/bin/ksh

TODAY=$(date "+%d")
BOLD=$(tput smso)
BLINK=$(tput blink)
RESET=$(tput rmso)
TODAY=$(expr $TODAY + 0 )

CAL=$(cal | awk '{ print" "$0" "}' | sed s/" $TODAY "/$BLINK$BOLD"<$TODAY>"$RESET/g)

print "$CAL"

if [ $1 ] && [ $2 ]
then
	IFS=" "
	cal $* | sed s/" "/"-"/g | while read line
	do
		print #3 $line | sed s/"-"/" "/g
		print #4 $line | sed s/"-"/" "/g
	done
else
	IFS=" "
	cal $* | awk '{ print" "$0" "}' | sed s/" "/"-"/g | while read line
	do
	   print #3 $line | sed s/"-"/" "/g | sed s/" $TODAY "/$BLINK"<$TODAY>"$RESET/g
	   print #4 $line | sed s/"-"/" "/g | sed s/" $TODAY "/$BLINK"<$TODAY>"$RESET/g
	done
fi

---------------------------------------------------------------------------------------------------

##
# fix_header
##

ls -al DB* | awk '{print $NF}' | while read FILE
do
  cat header $FILE > $FILE.bak
  mv $FILE.bak $FILE
done

-------------------------------------------------------------

##
# mymenu
##

#!/usr/bin/ksh

###----------------------------------------------------------------------------
#  A short menu driven program to help you work more effectively!
#
#  Version :   1.0
#  Author  :   Diep Le
#  Date    :   02/11/2000
#
#  Somehow the colour function doesn't seem to work on Sun OS !!!
#
###----------------------------------------------------------------------------


trap 'print "\n\nEscape or CTL-C not permitted whilst using this menu!";sleep 2' INT TERM


##
# Vars
##

RESET=$(tput rmso)
BOLD=$(tput smso)
BLINK=$(tput blink)
MYDATE=$(date "+%d-%m-%Y")
HOST=$(uname -n)

##
# Functions definition
##


##
# Function to print colour display to
# the terminal
##

colour(){

case $1 in
	black_white)
		print '[40;37m'
		;;
	black_yellow)
		print '[40;33m'
		;;
	black_cyan)
		print '[40;36m'
		;;
esac
}

##
# Nice try
##
nice_try(){
	print "Wrong password ... terminal is still lock"
}


##
# Function to lock the terminal
# by reading in the password from keyboard
##

lock_tty(){

trap "nice_try" 2 3 15

TTY=$(tty)

SAVEDSTTY=$(stty -g)
stty -echo
print "Enter your password to lock $TTY : \c"
read PASSWORD
print
while true
do
	##  read from keyboard
	read RESPONSE < $TTY
	if [ "$RESPONSE" = "$PASSWORD" ]
	then  
		print "Correct password ... unlocking"
		break
	fi
	print "Wrong password and terminal is still locked."
done
# restore tty setting to normal state
stty $SAVEDSTTY
}

setup_oraenv(){
###
# Set the environment variable ORACLE_HOME and ORACLE_SID 
# so that you can log onto the appropriate database
#
# NOTE:	Usage 		. setup_oraenv <ORACLE_SID>	
#
###

#
# Set minimum environment variables
#

ORACLE_HOME="/opt/thirdpp/oracle/u01/product/8.0.4"
ORACLE_SID=$1
export ORACLE_SID ORACLE_HOME
PATH=$PATH:$ORACLE_HOME/bin
export PATH 
}

###
#  Function to 'su' to another user id
###

su_session(){

	print "User : \c "
	read _USER
	su - $_USER
}


###
# Main
###


DC=$(colour black_white)	# default colour
BY=$(colour black_yellow)
BC=$(colour black_cyan)

while true
do 
clear 
colour black_white
cat <<!
================================================================================
USER : $BY $BOLD $LOGNAME $RESET $DC    ||    MACHINE :  $BOLD $HOST $RESET    ||     DATE : $BOLD $MYDATE $RESET    ||
================================================================================

   	      $BOLD#3$RESET
       	      $BOLD#4 $RESET


	1  .................... Telnet Hercules
	2  .................... Telnet Titan  
	3  .................... Telnet Luna
	4  .................... Telnet Chronos
	5  .................... Lock The Terminal
	6  .................... Korn Shell Session
	7  .................... Use the IF function
	8  .................... SQL*Plus (ORACLE_SID=MS_DEV)
	9  .................... SQL*Plus (ORACLE_SID=NI_DEV)
	10 .................... su another ID


!
print "	                X ............ eXit\n"           
colour black_cyan
print "	                PLEASE ENTER YOUR CHOICE :  \c" 

ANS=""
CONT=""

read ANS
ANS=$(print $ANS | tr "[a-z]" "[A-Z]")

  case $ANS in 

	      1) clear
                 telnet hercules
		 print
		 print "             Press [ Return ] to continue ......"
                 read CONT
		 ;;

              2) clear
		 telnet titan
                 print
		 print "             Press [ Return ] to continue......"
	         read CONT
	         ;;
              3) clear
		 telnet luna
                 print
		 print "             Press [ Return ] to continue......"
	         read CONT
	         ;;
              4) clear
		 telnet chronos
                 print
		 print "             Press [ Return ] to continue......"
	         read CONT
	         ;;
              5) lock_tty
                 print
		 print "             Press [ Return ] to continue......"
	         read CONT
	         ;;
              6) clear
		 /usr/bin/ksh
                 print
		 print "             Press [ Return ] to continue......"
	         read CONT
	         ;;
              7) clear
		 AGAIN="Y"
		 while [ "$AGAIN" = "Y" ]
		 do
			print "Please enter <file_name> <full_path> to 'cat'"
			read _FILE $MY_PATH
			$HOME/bin/IF $_FILE $MY_PATH
			print "\n\n"
			print "Cat Another file ? (Y/N)  : \c"
			read ANS
			AGAIN=$(print $ANS | awk '{print substr($1,1,1)}'| tr "[a-z]" "[A-Z]") 
			if [ x"$AGAIN" = x"N" ]
			then 
				break
			fi
		 done
                 print
		 print "             Press [ Return ] to continue......"
	         read CONT
	         ;;
              8) clear
		 . $HOME/bin/setup_oraenv MS_DEV
		 sqlplus 
                 print
		 print "             Press [ Return ] to continue......"
	         read CONT
	         ;;
              9) clear
		 . $HOME/bin/setup_oraenv NI_DEV
		 sqlplus 
                 print
		 print "             Press [ Return ] to continue......"
	         read CONT
	         ;;
              10) clear
		 su_session
                 print
		 print "             Press [ Return ] to continue......"
	         read CONT
	         ;;
	       x|X|q|Q) clear
			print "\n\nWarning - Exiting this menu will loose status of jobs currently executed"
			print "If a shell is required then select option 6"
			print "Continue With Exit ? (Y/N)  : \c"
			read xval
			if [ x"$xval" = x"Y" ] || [ x"$xval" = x"y" ]
			then
				print "Thank you."
				print
				exit 
			fi
			;;

   esac
done
##
# reset trap signals
##
trap INT TERM
###---------------
# End of script
###---------------

-------------------------------------------------------------

##
# fromto
##

#
# Function to read menu selections
#
fromto()
{
   MESG="($1 - $2) :"
   FROM=$1
   TO=$2
   ftloop=0
   echo "		Enter Selection ...\c"
   while [ $ftloop -eq 0 ]
   do
	echo $MESG" \c"
	read FT
	if [ x"$FT" = "x" ]
	then
	   FT="n"
	fi
	FT=$(echo $FT | tr "[A-Z]" "[a-z]")
	case $FT in
		"x")	ftloop=1
		;;
		"q")	ftloop=1
		;;
		*)      chkchar=$(echo $FT | grep -i "[A-Z]" | wc -l )	
			if [ $chkchar -ne 0 ]
			then
				FT=999999999
			fi
			if [ "$FT" = "q" ] || [ "$FT" = "Q" ]
			then
				exit
			fi
			if [ $FT -lt $FROM ] || [ $FT -gt $TO ]
			then
				echo "			INVALID INPUT ..."	
				echo "		Enter Selection ...\c"
			else
				ftloop=1
			fi
			;;
	esac
   done
}

-------------------------------------------------------------------------------------------------

##
# putfile
##

#!/bin/ksh

####
# FTP files to Helios                     
####

export FILE=$1
DIR=$2
HOST=$3

get_pass(){
cat <<!

    ##################
    ##  FTP LOG ON  ##
    ##################

Please enter your login details:

!
echo "Login (or press Enter to accept default of \"$LOGNAME\") :\c"
read USER

if [ x"$USER" = "x" ]
then 
	USER=$LOGNAME
fi
echo "Password : \c"
stty -echo
read PASSWD
stty echo
echo

export USER=$USER
export PASSWD=$PASSWD
}

PUT_FILE(){
/usr/bin/ftp -vn $HOST << !
user  $USER $PASSWD
bin
cd $DIR
put "$FILE"
bye
!
}

####
# Main
####

if [ $# -ne 3 ]; then
  echo "Usage: ${0} <<FILE>> <<DIR>> <<HOST>> "
  echo "I need a file, a directory and a host to transfer to"
  exit 1
fi

get_pass 
PUT_FILE

####
# End
####
----------------------------------------------------------------------------

##
# getfile
##

#!/bin/ksh


export FILE=$1
DIR=$2
HOST=$3

get_pass(){
cat <<!

    ##################
    ##  FTP LOG ON  ##
    ##################

Please enter your login details:

!
echo "Login (or press Enter to accept default of \"$LOGNAME\") :\c"
read USER

if [ x"$USER" = "x" ]
then 
	USER=$LOGNAME
fi
echo "Password : \c"
stty -echo
read PASSWD
stty echo
echo

export USER=$USER
export PASSWD=$PASSWD
}

Getfile(){
/usr/bin/ftp -vn $HOST << !
user  $USER $PASSWD
bin
cd $DIR
get "$FILE"
bye
!
}

####
# Main
####

if [ $# -ne 3 ]; then
  echo "Usage: ${0} <<FILE>> <<DIR>> <<HOST>>"
  echo "I need a file, directory path, and a host to transfer to"
  exit 1
fi

get_pass 
Getfile

####
# End
####
-------------------------------------------------------------------------------

##
# setup_oraenv
##

###-----------------------------------------------------------------------------
# Set the environment variable ORACLE_HOME and ORACLE_SID 
# so that you can log onto the appropriate database
# Usage :    . setup_oraenv <ORACLE_SID>
# 
###-----------------------------------------------------------------------------

#
# Set minimum environment variables
#

ORACLE_HOME="/opt/thirdpp/oracle/u01/product/8.0.4"
ORACLE_SID=$1
export ORACLE_SID ORACLE_HOME
export PATH=$PATH:$ORACLE_HOME/bin

--------------------------------------------------------------------------------

##
# jot
##

#!/usr/bin/ksh
#*******************************************************************************
#
# MODULE:	jot
#
# DESCRIPTION:  Generic module to generate a list of numericals which
#		will be useful in a "for loop" (useful for long list 
#		of variables). This works for decrement
#		as well.
#
#*******************************************************************************

#*******************************************************************************
#
# FUNCTION:	USAGE
#
# DESCRIPTION:  Make sure we have at least 2 arguments are passed
#
#*******************************************************************************

USAGE(){
if [[ $# -lt 2 ]]
then
	echo "Usage :  $0 <Num1> <Num2> [<Num3>]"
	exit
fi
}

#*******************************************************************************
#
# FUNCTION:	jot
#
# DESCRIPTION:  Function to generate numerical lists
#
#*******************************************************************************

JOT(){
start=$1
finish=$2
if [ $3 ]
then
	incr=$3
else
	incr=1
fi
if [ $start -lt $finish ]
then
	while [ $start -le $finish ]
	do
		echo  "$start" "\c"
		start=`expr $start + $incr`
	done
else
	while [ $start -ge $finish ]
	do
		echo "$start" "\c"
		start=`expr $start - $incr`
	done
fi
echo
}

###
# Main
###

USAGE $1 $2  $3
JOT $1 $2 $3

###
# end of script
###
-------------------------------------------------------------------------------

##
# l_jot
##

#!/usr/bin/ksh
#*******************************************************************************
#
# MODULE:	jot
#
# DESCRIPTION:  Generic module to generate a list of numericals which
#		will be useful in a for loop. This works for decrement
#		as well.
#
#*******************************************************************************

#*******************************************************************************
#
# FUNCTION:	USAGE
#
# DESCRIPTION:  Make sure we have at least 2 arguments are passed
#
#*******************************************************************************

USAGE(){
if [[ $# -lt 2 ]]
then
	echo "Usage :  $0 <Num1> <Num2> [<Num3>]"
	exit
fi
}

#*******************************************************************************
#
# FUNCTION:	jot
#
# DESCRIPTION:  Function to generate numerical lists
#
#*******************************************************************************

JOT(){
start=$1
finish=$2
if [ $3 ]
then
	incr=$3
else
	incr=1
fi
if [ $start -lt $finish ]
then
	while [ $start -le $finish ]
	do
		echo  $start
		start=`expr $start + $incr`
	done
else
	while [ $start -ge $finish ]
	do
		echo $start
		start=`expr $start - $incr`
	done
fi
#echo
}

###
# Main
###

USAGE $1 $2  $3
JOT $1 $2 $3

###
# end of script
###
-------------------------------------------------------------------------------

##
# log
##

###-----------------------------------------------------------------------------
#
# FUNCTION:	log
#
# DESCRIPTION:
#		Writes a line to the log file, adding the date to the start
#		of the line
#
###-----------------------------------------------------------------------------
log ()
{
echo "$(date +%Y-%m-%d-%H.%M.%S): "$* >> $AUDIT_LOG_NAME
}

----------------------------------------------------------------------------------

##
# log_check
##

#!/usr/bin/ksh

PASSWORDS=/etc/passwd

cat <<!
Login                Real Name                              Shell
====================================================================
!
for user in $(cat $PASSWORDS | awk -F: '{ print $1 }')
do
	USER=$(echo $user | awk '{ printf("%-12s\n",$0)}')
	NAME=$(grep "^$user:" $PASSWORDS | awk -F: '{ print $5 }' | awk '{ printf("%-25s\n",$0)}')
	SHELL=$(grep "^$user:" $PASSWORDS | awk -F: '{ print $NF }')
	echo "$USER$NAME                "$SHELL
done

---------------------------------------------------------------------------------------------------------

##
# log_end
##

## ----------------------------------------------------------------------------
# End log file
## ----------------------------------------------------------------------------
log_end()

{
echo "Exiting ${SCRIPT}, version ${VERS}: `date`" >> $AUDIT_LOG_NAME
}

------------------------------------------------------------------------------

##
# validate_logon
##

get_pass(){
CHKLOOP=0
while [ $CHKLOOP -eq 0 ]
do
tput clear
cat <<!
                          ########################

                            ##  ORACLE LOG ON  ##

Please enter your oracle login details:

!
echo "Login (or press Enter to accept default of \"$LOGNAME\") :\c"
stty -echo
read ORACLE_USER
stty echo
echo
done
if [ x"$ORACLE_USER" = "x" ]
then 
	ORACLE_USER=$LOGNAME
fi
if [ x"$ORACLE_USER" = "xUNIX" ] || [ x"$ORACLE_USER" = "xunix" ]
then
	echo "$(tput blink) Warning .... Your ORACLE environment has not been set up $(tput rmso)"
fi
echo "Password: \c"
stty -echo
read ORACLE_PASSWD
stty echo
echo
}

test_login(){
CHECK=$(sqlplus $ORACLE_USER/$ORACLE_PASSWD <<! | grep "ORACLE not available" | wc -l
exit
!
)
}

validate_oracle(){
CHECKLOGIN=1
while [ $CHECKLOGIN -eq 1 ]
do
	get_pass
	test_login
	CHECKLOGIN=$CHECK
	if [ $CHECKLOGIN -eq 1 ]
	then
		echo "\nInvalid Oracle Account / Password Combination .."
		echo "\n======= Press Enter to Continue ======= \c"
		read CONT
	fi
done

echo "Your Oracle login has been validated." 
}


ORACLE_USER=""
ORACLE_PASSWD=""

validate_oracle

---------------------------------------------------------------------------------------------

##
# wg
##

#
# whogroup
#
if [[ $# != 1 ]]
then
	echo 'Usage : $0 <group>'
	exit 1
fi
group=$1
gid=$(grep "^$group:" /etc/group | awk -F: '{ print $3 }')
for user in $(grep $gid /etc/passwd | awk -F: '{ print $1"-"$4 }')
do
	name=$(echo $user | awk -F\- '{ print $1 }')
	gcheck=$(echo $user | awk -F\- '{ print $2 }')
	if [ $gcheck = $gid ]
	then
		echo $name
		#tput smso
		tput blink
		who | grep $name
		tput rmso
	fi
done
-------------------------------------------------------------------------------------------------

##
# Chmod755
##

ls -al | grep "\-rw\-rw\-r\-\-" | awk '{ print "chmod 755 "$NF }' > permfix
sh permfix
rm -f permfix

-------------------------------------------------------------------------------------------------

##
# DB_run_query_pipe
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DBRQP
#
# Author           :    DL
#
# Usage            :	<command> | DBRQP 
#
# Description      :    DBRQP (DB_run_query_pipe). Run a SQL command from stdin 
#
# Calls            :    None
#
# Called By        :    None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){

	cat <<-!

	$(basename $0)  - Runs a SQL COMMAND from stdin

	Usage: <command> | DBRQP

	e.g    cat sql_file.sql | DBRQP
	
	or     DBRQP < sql_file.sql

	or     cat <<-END_SQL | DBRQP
	       Your SQL statements
               go here
	END_SQL

	!
}

CHK_PARAM(){

if [ $# -ne 0 ]
then
   print "Incorrect number of arguments" 2>&1
   USAGE
   exit 1
fi
}

####
# Main
####

CHK_PARAM
# DB_LOGIN is exported by .profile, i.e. DB_LOGIN=$ORACLE_LOGIN/$ORACLE_PASSWD
sqlplus -s ${DB_LOGIN}   

### End  ###
-------------------------------------------------------------------------------------------

##
# DB_check_segment
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :
#
# Author           :
#
# Usage            : 
#
# Description      :
#
# Calls            :
#
# Called By        :
#
#
# ---------------------------------------------------------------------
# Revision History
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
# 
# =====================================================================


####
# Global variables
####

TABLESPACE=$2
TABLE_NAME=$(print $1|tr [a-z] [A-Z])      # Convert table name to uppercase
TAB_EXT=$(grep $TABLE_NAME" " $EXPLOG/exptab.log|tail -1| awk '{print $15}')
NEXT_EXT=$(grep $TABLE_NAME" " $EXPLOG/exptab.log|tail -1| awk '{print $14}')
INIT_EXT=$(grep $TABLE_NAME" " $EXPLOG/exptab.log|tail -1| awk '{print $13}')


USAGE(){

    print "usage: $(basename $0)  <TABLE> " >&2
    print "Example: $(basename $0)  ACCOUNTS " >&2
    print "or " >&2 
    print "usage: $(basename $0)  <TABLE> <TABLESPACE> " >&2
    print "Example: $(basename $0)  ACCOUNTS  USERS " >&2
    exit 1
}

CHK_XPORT_TABLE(){

if [ -f $EXPLOG/exptab.log ]             # Check that the table was exported  
then
   EXIST=`grep $TABLE_NAME" " $EXPLOG/exptab.log`
   if [ "$EXIST" = "" ]
   then
      print "1" 
      exit 2                                                      
   fi
fi
}

GET_TSPACE(){

if [ "$TABLESPACE" = "" ]
then
   TSPACE=$(grep $TABLE_NAME" " $EXPLOG/exptab.log|tail -1| awk '{print $12}')
else
   TSPACE=$(print $TABLESPACE | tr [a-z] [A-Z])      # Convert tablespace to uppercase
fi
}

GET_SPOOL_FILE(){
# Blank file if free segments < initial ext
cat <<! | ${HOME}/bin/DBRQP 
--set heading off pagesize 0 verify off  feedback off  
spool /tmp/${TSPACE}.${TABLE_NAME}.lis
select bytes from dba_free_space
where bytes >= ${INIT_EXT}
and tablespace_name = '${TSPACE}'
order by 1 desc;
spool off
!
}

PROCESS_SEGMENT(){
# ----------------------------------------------------------------------------
#
#  If the spool file is blank, then the table cannot be created. The ! -s 
#  flag is used for blank files.
 
#set -x
INT_CNT=1     #  Set the initial extent counter

  if [ ! -s "/tmp/${TSPACE}.${TABLE_NAME}.lis" ]  
  then 
    print  "1 Failed"    
    exit 3
  else
  
       while read  xx                   # Read the spool file
       do
        SEG=`printf "$xx\n"`            # Get the first line

       # --------------------------------------------------------------- 
       if [ $INT_CNT -eq 1 ]              # If this is the Initial extent
       then   
        SEG=`expr $SEG - $INIT_EXT`     # Availabe free space in segment
        TAB_EXT=`expr $TAB_EXT - 1`          # Subtract 1 from the extents
       else
        SEG=`expr $SEG - $NEXT_EXT`
       fi

       # --------------------------------------------------------------- 
       if  [ $TAB_EXT -eq 0 ]     # break if there are no more table extents
       then
           print  "0"
           exit 
       else
           print  "1 Failed"
       fi

       # --------------------------------------------------------------- 
   
       if [ $SEG -ge $NEXT_EXT ]  # If the free space >= next table extent
        then
        while true     # loop while there are more table extents
        do
          if [ $TAB_EXT -gt 0 ]
          then
           if [ $SEG -le 0 ]      # if there is still space in this fragment
           then
             break                        # Exit loop if no space left in seg.
           else
             TAB_EXT=`expr $TAB_EXT - 1`  # Subract 1 from the table extents
             SEG=`expr $SEG - $NEXT_EXT`  # Subtract the next extent
           fi
          else
             break                # Exit when there are no more table extents
          fi
        done
       fi

       INT_CNT=`expr $INT_CNT + 1`
       done < /tmp/${TSPACE}.${TABLE_NAME}.lis 
   
   fi
}


####
# Main
####


if [ $# -lt 1 -o $# -gt 2 ]     # Check for the input parameters
then   
    USAGE
fi

CHK_XPORT_TABLE
GET_TSPACE
GET_SPOOL_FILE
PROCESS_SEGMENT

#### END ####
-----------------------------------------------------------------------------------------------

##
# DB_object_exists
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_OBJECT_EXISTS
#
# Author           :	DL
#
# Usage            : 	$(basename $0)  <Object (Table/View) name>
#
# Description      :	check if an object exists in the database
#
# Calls            :	DBRQP
#
# Called By        :	None
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - check if an object exists in the database 

Usage: $(basename $0)  <Object (Table/View) name>
!
}

CHK_PARAM(){

if [ $# -ne 1 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

####
# Main
####

CHK_PARAM $1

if ${HOME}/bin/DB_OBJECT_TYPE ${1} >/dev/null
then
	#print object ${1} exists
	exit 0
fi

#print object ${1} does not exist
exit 1

#### END ####
-------------------------------------------------------------------------------

##
# DB_column_exists
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_COLUMN_EXISTS	
#
# Author           :	DL
#
# Usage            : 	$0 <Table/View name> <Column name>
#
# Description      :	check to see if a column exists in an object
#
# Calls            :	DB_OBJECT_NOT_EXISTS
#			DB_DESC
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - check to see if a column exists in an object 

Usage: $(basename $0) <Table/View name> <Column name>
!
}

CHK_PARAM(){

if [ $# -ne 2 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

CHK_TABLE(){
if ${HOME}/bin/DB_OBJECT_NOT_EXISTS ${1}
then
    print "Error: Specified Table/View ${1} does not exist or insufficient priviledges" >&2
    exit 1
fi

${HOME}/bin/DB_DESC ${1} | grep -i "^${2}[ 	]" >/dev/null
if [[ $? -eq "0" ]]
then
    #print column ${2} exists in table ${1}
    exit 0
else
    #print column ${2} does not exist in table ${1}
    exit 1
fi
}

#### 
# Main
####

CHK_PARAM $1 $2
CHK_TABLE $1 $2

#### END ####
------------------------------------------------------------------------------

##
# DB_object_list
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
# Script Name      :	DB_OBJECT_LIST
#
# Author           :	DL
#
# Usage            : 	DB_OBJECT_LIST
#
# Description      :	$(basename $0) - list all tables, views and indexes
#
# Calls            :	DB_LIST_SYNONYMS
#			DB_LIST_TABLES
#			DB_LIST_VIEWS 
#			DB_LIST_INDEXES2
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){

cat <<!
$(basename $0) - list all tables, views and indexes 

Usage: $(basename $0)
!
}

CHK_PARAM(){

if [ $# -ne 0 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

GET_LIST(){

${HOME}/bin/DB_LIST_SYNONYMS | sed 's/$/		SYNONYM/'
${HOME}/bin/DB_LIST_TABLES | sed 's/$/		TABLE/'
${HOME}/bin/DB_LIST_VIEWS | sed 's/$/		VIEW/'
${HOME}/bin/DB_LIST_INDEXES2
}

####
# Main
####

CHK_PARAM
GET_LIST | sort

#### END ####
-----------------------------------------------------------------------------

##
# DB_column_is_primary_index
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
# Script Name      :	DB_COLUMN_IS_PRIMARY_INDEX
#
# Author           :	DL
#
# Usage            : 	$(basename $0) <Table/View name> <Column name>
#
# Description      :	check if an index uses this column first
#
# Calls            :	DBRQP
#			DB_COLUMN_NOT_EXISTS
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - check if an index uses this column first 

Usage: $(basename $0) <Table/View name> <Column name>
!
}

CHK_PARAM(){

if [ $# -ne 2 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

VARS(){

OBJECT_FULL_NAME=$(print ${1} | tr '[a-z]' '[A-Z]')
COLUMN_NAME=$(print ${2} | tr '[a-z]' '[A-Z]')
OBJECT_NAME=$(print ${OBJECT_FULL_NAME} | sed 's/.*\.//')
# this is owner based information
OBJECT_OWNER=$(print ${OBJECT_FULL_NAME} | sed 's/\..*//')

}


SELECT_INDEX(){

INDEX_RETURN=`print "\
set pages 0;
set feedback off;
select '1'
from ALL_IND_COLUMNS
where TABLE_NAME = '${OBJECT_NAME}'
and COLUMN_NAME = '${COLUMN_NAME}'
and COLUMN_POSITION = 1
; " | ${HOME}/bin/DBRQP`
#echo ${INDEX_RETURN}
}

SELECT_OWNER(){

INDEX_RETURN=`print "\
set pages 0;
set feedback off;
select '1'
from ALL_IND_COLUMNS
where OWNER = '${OBJECT_OWNER}'
and TABLE_NAME = '${OBJECT_NAME}'
and COLUMN_NAME = '${COLUMN_NAME}'
and COLUMN_POSITION = 1
; " | ${HOME}/bin/DBRQP`
#echo ${INDEX_RETURN}
}


####
# main 
####

CHK_PARAM $1 $2
VARS $1 $2

if ${HOME}/bin/DB_COLUMN_NOT_EXISTS ${OBJECT_FULL_NAME} ${COLUMN_NAME}
then
    print "Database Column does not exist"
    exit 1
fi

if [ "${OBJECT_NAME}" = "${OBJECT_FULL_NAME}" ]
then
    SELECT_INDEX
else
    SELECT_OWNER
fi

if [ x"${INDEX_RETURN}" = x"1" ]
then
    #print "a primary index on ${1}(${2}) exists"
    exit 0
else #print "a primary index on ${1}(${2}) does not exist"
    exit 1
fi

#### END ####
------------------------------------------------------------------------

##
# DB_object_list_like
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_OBJECT_LIST_LIKE
#
# Author           :	DL
#
# Usage            :	$(basename $0) <pattern_to_match> 
#
# Description      :	list all tables, views and indexes named like %\$1%
#
# Calls            :	DB_LIST_TABLES 
#			DB_LIST_VIEWS
#			DB_LIST_INDEXES2
#	
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - list all tables, views and indexes named like %\$1% 

Usage: $(basename $0) <pattern_to_match> 
!
}

CHK_PARAM(){

if [ $# -ne 1 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

GET_LIST(){

PATTERN=$(print $1 | tr '[a-z]' '[A-Z]')
${HOME}/bin/DB_LIST_TABLES |grep ${PATTERN} | sed 's/$/		TABLE/'
${HOME}/bin/DB_LIST_VIEWS | grep ${PATTERN} | sed 's/$/		VIEW/'
${HOME}/bin/DB_LIST_INDEXES2 | grep ${PATTERN}
}

####
# Main
####

CHK_PARAM $1
GET_LIST $1  | sort

#### END ####
-----------------------------------------------------------------------------------

##
# DB_column_not_exists
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_COLUMN_NOT_EXISTS 
#
# Author           :	DL
#
# Usage            : 	$(basename $0) <Table/View name> <Column name>
#
# Description      :	check to see if a column exists in an object
#
# Calls            :	DB_OBJECT_NOT_EXISTS
#			DB_DESC
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0 - check to see if a column exists in an object 

Usage: $(basename $0) <Table/View name> <Column name>
!
}

CHK_PARAM(){

if [ $# -ne 2 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 0
fi
}

CHK_OBJECT(){

if ${HOME}/bin/DB_OBJECT_NOT_EXISTS ${1}
then
    print "Error: Specified Table/View ${1} does not exist or insufficient priviledges" >&2
    exit 0
fi
}

DESCRIBE(){

${HOME}/bin/DB_DESC ${1} | grep -i "^${2}[ 	]" >/dev/null 

if [[ $? -eq "0" ]]
then
    #print column ${2} exists in table ${1}
    exit 1
else
    #print column ${2} does not exist in table ${1}
    exit 0
fi
}


####
# main
####

CHK_PARAM $1 $2
CHK_OBJECT $1
DESCRIBE $1 $2

#### END ####
----------------------------------------------------------------------------

## 
# DB_object_not_exists
##
#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_OBJECT_NOT_EXISTS
#
# Author           :	DL
#
# Usage            :	$(basename $0) <Table/View name> 
#
# Description      :	check if an object does not exist in the database
#
# Calls            :	DB_OBJECT_TYPE
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


#set -x

USAGE(){
cat <<!
$(basename $0) - check if an object 
does not exist in the database 

Usage: $(basename $0) <Table/View name>
!
}

CHK_PARAM(){

if [ $# -ne 1 ]
then
   print "Error: Incorrect number of arguments" >&2
   USAGE
   exit 1
fi
}

####
# Main
####

CHK_PARAM $1

if ${HOME}/bin/DB_OBJECT_TYPE ${1} >/dev/null
then
#   print object ${1} exists
   exit 1
fi

#print object ${1} does not exist
exit 0
#### End ####
------------------------------------------------------------------------------

##
# DB_column_type
##
#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_COLUMN_TYPE
#
# Author           : 	DL
#
# Usage            : 	$(basename $0) <Table/View name> <Column name>
#
# Description      :	check if a column exists in an object, return its type
#
# Calls            :	DB_OBJECT_NOT_EXISTS
#			DB_DESC
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


T1=/tmp/$$.${LOGNAME}.out

USAGE(){
cat <<! 
$(basename $0) - check if a column exists in an object, return its type 

Usage: $(basename $0) <Table/View name> <Column name>
!
}


CHK_PARAM(){

if [ $# -ne 2 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

CHK_OBJECT(){

if ${HOME}/bin/DB_OBJECT_NOT_EXISTS ${1}
then
    print "Error: Specified Table/View ${1} does not exist or insufficient priviledges" >&2
    USAGE >&2
    exit 1
fi
}

DESCRIBE(){

${HOME}/bin/DB_DESC ${1} > $T1

QQ_TYPE=$(grep -i "^${2}[ 	]" $T1 2>&1)

if [ -n "${QQ_TYPE}" ]
then
    #print column ${2} exists in table ${1}
    rm  $T1
    print ${QQ_TYPE} | sed -e "s/.*[ 	][ 	]*//" -e 's/(.*//'
    exit 0
fi

#print column ${2} does not exist in table ${1}
rm $T1
exit 1
}

####
# Main
####

CHK_PARAM $1 $2
CHK_OBJECT $1
DESCRIBE $1 $2

#### END ####
-----------------------------------------------------------------------------------------

##
# DB_object_type
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_OBJECT_TYPE
#
# Author           :	DL
#
# Usage            : 	$(basename $0) <Object (Table/View) name>
#
# Description      :	display the value of OBJECT_TYPE column
#			from USER_OBJECTS table. 
#			Exit 1 if not found, exit 0 if found.
#
# Calls            :	DBRQP
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


#set -x
VARS(){
OBJECT_FULL_NAME=$(print ${1} | tr '[a-z]' '[A-Z]')
OBJECT_NAME=$(print ${OBJECT_FULL_NAME} | sed 's/.*\.//')
# this is owner based information
OBJECT_OWNER=$(print ${OBJECT_FULL_NAME} | /usr/bin/sed 's/\..*//')
T1=/tmp/$$.${LOGNAME}.out1
T2=/tmp/$$.${LOGNAME}.out2
}

USAGE(){
cat <<!
$(basename $0) - display the value of OBJECT_TYPE column 
from USER_OBJECTS table. Exit 1 if not found, exit 0 if found. 

Usage: $(basename $0) <Object (Table/View) name>
!
}

CHK_PARAM(){

if [ $# -ne 1 ]
then
   print "Error: Incorrect number of arguments" >&2
   USAGE
   exit 1
fi
}

SELECT_OBJ_NAME(){
cat <<! | ${HOME}/bin/DBRQP
set pages 0;
set feedback off;
select OBJECT_TYPE
from ALL_OBJECTS
where OBJECT_NAME = '${OBJECT_NAME}';
!
}

SELECT_OWNER_OBJ(){
cat <<! | ${HOME}/bin/DBRQP
set pages 0;
set feedback off;
select OBJECT_TYPE
from ALL_OBJECTS
where OWNER = '${OBJECT_OWNER}'
and OBJECT_NAME = '${OBJECT_NAME}';
select 'INDEX'
from ALL_INDEXES
where OWNER = '${OBJECT_OWNER}'
and INDEX_NAME = '${OBJECT_NAME}';
!
}

ERROR_CHK(){

if grep "ERROR" $T1 >/dev/null 2>&1
then
    cat $T1 >&2
    rm -f $T1 $T2
    exit 1
fi
}

####
# Main
####

VARS $1
CHK_PARAM $1

if [ "${OBJECT_NAME}" = "${OBJECT_FULL_NAME}" ]
then
    SELECT_OBJ_NAME | tee $T1 | grep -v "SYNONYM" > $T2 2>&1
else
    SELECT_OWNER_OBJ | tee $T1 | grep -v "SYNONYM" > $T2 2>&1
fi

ERROR_CHK

if [ -s "$T2" ] 	# object ${1} exists
then
    cat $T2
    rm -f  $T1 $T2
    exit 0
elif [ -s "$T1" ]  	# SYNONYM ${1} exists
then
    cat $T1
    rm -f $T1 $T2
    exit 0
else
    rm -f $T1 $T2       # object ${1} does not exist
    exit 1
fi

#### End ####
-----------------------------------------------------------------------------

##
# DB_compare_column_names
##

#!/bin/ksh
# ---------------------------------------------------------------------
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_COMPARE_COLUMN_NAMES
#
# Author           :	DL
#
# Usage            : 	$(basename $0)  <$1 - Source table/view> 
#					<$2 - Destination table/view>
#
# Description      :	Compare 2 tables or views, and report on
#			differences in layouts
#
# Calls            :	DB_DESC
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
# 
# =====================================================================


VARS(){

SOURCE_TABLE=$(print $1 | tr '[a-z]' '[A-Z]')
DESTINATION_TABLE=$(print $2 | tr '[a-z]' '[A-Z]')
T_SOURCE=/tmp/$$.${LOGNAME}.source
T_DEST=/tmp/$$.${LOGNAME}.dest
T1=/tmp/$$.${LOGNAME}.tmp
T2=/tmp/$$.${LOGNAME}.comp_1
T3=/tmp/$$.${LOGNAME}.comp_2
T4=/tmp/$$.${LOGNAME}.comp_3
}

USAGE(){
cat <<!
$(basename $0) - Compare 2 tables or views, and report on 
differences in layouts 

Usage: $(basename $0) <$1 - Source table/view> <$2 - Destination table/view>
!
}

CHK_PARAM(){

if [ $# -ne 2 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

CHK_SOURCE(){

# Verify OWNER.OBJECT_NAMEs is $1 and $2
if ${HOME}/bin/DB_DESC ${SOURCE_TABLE} > ${T_SOURCE}
then
    print "\c"
else
    rm -f ${T_SOURCE} ${T_DEST}
    print "Error: Table/view ${SOURCE_TABLE} does not exist or insufficient privileges" >&2
    exit 1
fi
}

CHK_DEST(){

if ${HOME}/bin/DB_DESC ${DESTINATION_TABLE} > ${T_DEST}
then
    print "\c"
else
    DESCRIBE=${MKI_HOME}/${ORACLE_SID}/templates/${DESTINATION_TABLE}.desc
    if [ -r "${DESCRIBE}" ]
    then
        cp ${DESCRIBE} ${T_DEST}
    else
        rm -f ${T_SOURCE} ${T_DEST}
	print "Error: Table/view ${DESTINATION_TABLE} does not exist or insufficient privileges" >&2
	exit 1
    fi
fi
}

READ_SOURCE(){

while read S_COL_NAME S_COL_SIZE
do
   grep "^${S_COL_NAME}[ 	]" ${T_DEST} > ${T1}
   read D_COL_NAME D_COL_SIZE < ${T1}
   if [ -z "${D_COL_NAME}" ]
   then
      print "\t${S_COL_NAME}\t\t\t${S_COL_SIZE}"
      continue
   fi
   if [ "${S_COL_SIZE}" != "${D_COL_SIZE}" ]
   then
       print "\tSOURCE:  ${S_COL_NAME}\t\t\t${S_COL_SIZE}\n\tDEST:    ${D_COL_NAME}\t\t\t${D_COL_SIZE}" >&2
   fi
done < ${T_SOURCE} > ${T2} 2> ${T3}
}

READ_DEST(){

while read D_COL_NAME D_COL_SIZE
do
   grep "^${D_COL_NAME}[ 	]" ${T_SOURCE} >${T1}
   read S_COL_NAME S_COL_SIZE <${T1}
   if [ -z "${S_COL_NAME}" ]
   then
       print "\t${D_COL_NAME}\t\t\t${D_COL_SIZE}" >&2
   fi
done <${T_DEST} 2> ${T4}
}

COMPARE(){

print "Comparison of ${SOURCE_TABLE} vs ${DESTINATION_TABLE}\n"

if [ -s "${T2}" -a -s "${T3}" -a -s "${T4}" ]
then
    print "\t Exactly Equal"
fi

print "Columns diff in ${SOURCE_TABLE} vs ${DESTINATION_TABLE}:"
if [ -s "${T3}" ]
then
    cat ${T3}
else
    print "\t None"
fi

print "Columns in ${SOURCE_TABLE} not in ${DESTINATION_TABLE}:"
if [ -s "${T2}" ]
then
    cat ${T2}
else
    print "\t None"
fi

print "Columns in ${DESTINATION_TABLE} not in ${SOURCE_TABLE}:"
if [ -s "${T4}" ]
then
    cat ${T4}
else
    print "\t None"
fi
}


####
# main
####

VARS $1 $2
CHK_PARAM $1 $2
CHK_SOURCE
CHK_DEST
READ_SOURCE
READ_DEST
COMPARE

rm -f $T{1} ${T2} ${T3} ${T4} ${T_DEST} ${T_SOURCE}

#### END ####
----------------------------------------------------------------------

##
# DB_report
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_REPORT
#
# Author           :	DL
#
# Usage            : 	$(basename $0) <$1 - Path to SQL script file>
#
# Description      :	Run SQL script nohup'ed in background 
#			with no extraneous info
#
# Calls            :	DB_RUN_QUERY_SCRIPT
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - Run SQL script nohup'ed in background with no extraneous info 

Usage: $(basename $0) <$1 - Path to SQL script file>
!
}

CHK_PARAM(){

if [ $# -ne 1 ]
then
    print "Error: Incorrect number of arguments" >&2
    print "${USAGE}" >&2
    exit 1
fi
}

CHK_FILE(){

if [ ! -r "$1" ]
then
    print "Error: ${1} not a read-able file:" >&2
    USAGE >&2
    exit 1
fi
}

REPORT(){

print "START_TIME = $(date)" >$1.out 

if [ ! -w "$1.out" ]
then
    print "Error: $1.out not a write-able file:" >&2
    USAGE >&2
    exit 1
fi

nohup ${HOME}/bin/DB_RUN_QUERY_SCRIPT ${1} >$1.out 2>&1 &
}

####
# Main
####

CHK_PARAM $1
CHK_FILE $1 
REPORT $1

#### END ####
---------------------------------------------------------------------------

##
# DB_count_rows
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_COUNT_ROWS
#
# Author           :	DL
#
# Usage            : 	$(basename $0)  <Table/View name>
#
# Description      :	count rows for an object
#
# Calls            :	DB_OBJECT_NOT_EXISTS
#			DBRQP
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - count rows for an object 

Usage: $(basename $0)  <Table/View name>
!
}

CHK_PARAM(){

if [ $# -ne 1 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

CHK_EXISTS(){

# Validate existence of the requested table or view
if ${HOME}/bin/DB_OBJECT_NOT_EXISTS ${1}
then
    print "Object does not exist."
    exit 1
fi
}

COUNT_ROWS(){

cat <<! | ${HOME}/bin/DBRQP
set pages 0;
set feedback off;
select count('1') from $1;
!
}


####
# Main
####

CHK_PARAM $1
CHK_EXISTS $1
COUNT_ROWS $1

#### END ####
---------------------------------------------------------

##
# DB_run_query_script
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_RUN_QUERY_SCRIPT
#
# Author           :	DL
#
# Usage            : 	$0 <SQL commands file name> 
#			<[ noisy (remove -s option on sqlplus) ]>
#
# Description      :	Run a SQL command file
#
# Calls            :	None
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - Run a SQL command file 

Usage: $0 <SQL commands file name> <[ noisy (remove -s option on sqlplus) ]> 
!
}

RUN_SCRIPT(){

SQLPLUS="sqlplus ${SILENT}"
sqlfile=$1

if [ ! -r "${sqlfile}" ]
then
    sqlfile=$1.sql
    if [ ! -r "${sqlfile}" ]
    then
       print "Error: Cannot read SQL command file: ${1}" >&2
       USAGE >&2
       exit 1
    fi
fi


${SQLPLUS} ${DB_LOGIN} <${sqlfile}
}

####
# Main
####


if [ $# -lt 1 -o $# -gt 2 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi

if [ $# -eq 2 ]
then
    SILENT=
else
    SILENT="-s"
fi

RUN_SCRIPT $1

#### END ####
------------------------------------------------------------------

##
# DB_desc
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_DESC
#
# Author           :	DL
#
# Usage            : 	$(basename $0) <Table/View name OR owner.table_name>
#
# Description      :	describe an object in the database and 
#			remove report formatting. Useful for shell scripting
#			as well as getting a quick description of a table/view
#			from the database without having to manually logging
#			into a sqlplus session!
#
# Calls            :	DBRQP
#			DB_OBJECT_NOT_EXISTS
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - describe an object in the database and remove report formatting 

Usage: $(basename $0) <Table/View name OR owner.table_name>
!
}

CHK_PARAM(){

if [ $# -ne 1 ]
then
   print "Error: Incorrect number of arguments" >&2
   USAGE
   exit 1
fi
}

DESCRIBE(){
cat <<! | ${HOME}/bin/DBRQP 	# DB_run_query_pipe
set pages 0;
set feedback off;
desc $1;
!
}

####
# Main
####

CHK_PARAM $1

# Validate existence of the requested table or view
if ${HOME}/bin/DB_OBJECT_NOT_EXISTS ${1}
then
   print "Object does not exist."
   exit 1
fi

DESCRIBE $1 | grep -v 'Null\?' |grep -v '\-\-\-\-' |\
grep -v '^$' | sed -e 's/^ //' -e 's/NOT NULL/        /'

### End ###
-----------------------------------------------------------------------

##
# DB_get_column_values
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_GET_COLUMN_VALUES
#
# Author           :	DL
#
# Usage            : 	$(basename $0) <$1- Table/View name> 
#			<$2- Column name> <$3- Where clause>
#
# Description      :	retrieve all values from table ${1},
#			column ${2} under ${3} conditions
#
# Calls            :	DB_OBJECT_NOT_EXISTS
#			DBRQP
#
# Called By        :	None
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================

USAGE(){
cat <<!
$(basename $0) - retrieve all values from table ${1},
column ${2} under ${3} conditions 

Usage: $(basename $0) <Table/View name> <Column name> <Where clause>
!
}

CHK_PARAM(){

if [ $# -ne 3 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

CHK_EXISTS(){

if ${HOME}/bin/DB_OBJECT_NOT_EXISTS ${1}
then
    print "Error: Specified Table/View  ${1} does not exist or insufficient priviledges" >&2
    USAGE >&2
    exit 1
fi
}

GET_COLUMN(){

cat <<! | ${HOME}/bin/DBRQP
set pages 0;
set feedback off;
select distinct ${2} from ${1} where ${3};
!
}


####
# Main
####

CHK_PARAM $1 $2 $3
CHK_EXISTS $1
GET_COLUMN $1 $2 $3

#### END ####
------------------------------------------------------------

##
# DB_is_up
##
#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_IS_UP
#
# Author           :	DL
#
# Usage            : 	DB_IS_UP
#
# Description      :	check if the database is up
#
# Calls            :	DBRQP
#
# Called By        :	None
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){

cat <<!
$(basename $0) check if the database is up 

Usage: $(basename $0)
!
}

CHK_PARAM(){

if [ $# -ne 0 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

CHK_DB(){

DB_RETURN=`print "\
set pages 0;
set feedback off;
select '1'
from dual;
" | ${HOME}/bin/DBRQP`
print $DB_RETURN
}

####
# Main
####

CHK_PARAM

if [ "$(CHK_DB)" = "1" ]; then
#    print Database ${ORACLE_SID} is up
    exit 0
else
    #print Database ${ORACLE_SID} is not up
    exit 1
fi

#### END ####
----------------------------------------------------------

##
# DB_segment_size
##
#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_SEGMENT_SIZE
#
# Author           :	DL
#
# Usage            : 	$(basename $0) <Segment name>
#
# Description      :	display the size of a segment in bytes
#			from USER_TABLES table. 
#			Exit 1 if not found, exit 0 if found.
#
# Calls            :	DBRQP
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - display the size of a segment in bytes 
from USER_TABLES table. Exit 1 if not found, exit 0 if found. 

Usage: $(basename $0) <Segment name>
!
}

CHK_PARAM(){

if [ $# -ne 1 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

GET_BYTES(){

SEGMENT_NAME=$(print ${1} | tr '[a-z]' '[A-Z]')
BYTES=`print "\
set pages 0;
set feedback off;
select BYTES 
from DBA_SEGMENTS
where SEGMENT_NAME = '${SEGMENT_NAME}';
" | ${HOME}/bin/DBRQP`

if [ -n "${BYTES}" ]
then
    #print table ${1} exists
    print "${BYTES}"
    exit 0
else
    #print table ${1} does not exist
    exit 1
fi
}

####
# Main
####

CHK_PARAM $1
GET_BYTES $1

#### END ####
-------------------------------------------------------------------------

##
# DB_list_indexes
##
#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_LIST_INDEXES
#
# Author           :	DL
#
# Usage            : 	DB_LIST_INDEXES
#
# Description      :	list all indexes this DB_LOGIN has access to
#
# Calls            :	DBRQP
#
# Called By        :	None
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - list all indexes this DB_LOGIN has access to 

Usage: $(basename $0)
!
}

CHK_PARAM(){

if [ $# -ne 0 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

SELECT_INDEXES(){

cat <<! | ${HOME}/bin/DBRQP
set pages 0;
set feedback off;
select index_name from user_indexes order by 1;
set pages 0;
set feedback off;
select owner||'.'||index_name from all_indexes
where owner <> 'SYS' and owner <> 'SYSTEM'
order by index_name;
!
}


####
# Main
####

CHK_PARAM
SELECT_INDEXES

#### END ####
-------------------------------------------------------------------

##
# DB_which_tablespace
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_WHICH_TABLE_SPACE
#
# Author           :	DL
#
# Usage            : 	$(basename $0} <Table name>
#
# Description      :	display the value of TABLESPACE_NAME column
#                       from USER_TABLES table. 
#                       Exit 1 if not found, exit 0 if found.
#
# Calls            :	DBRQP
#
# Called By        :	None
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     30-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - display the value of TABLESPACE_NAME column 
from USER_TABLES table. Exit 1 if not found, exit 0 if found. 

Usage: $(basename $0} <Table name>
!
}

CHK_PARAM(){

if [ $# -ne 1 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

GET_TABLESPACE(){

TABLE_NAME=$(print ${1} | tr '[a-z]' '[A-Z]')

TABLESPACE_NAME=`print "\
set pages 0;
set feedback off;
select TABLESPACE_NAME
from ALL_TABLES
where TABLE_NAME = '${TABLE_NAME}';
" | ${HOME}/bin/DBRQP`

if [ -n "${TABLESPACE_NAME}" ]
then
    #print table ${1} exists
     print "${TABLESPACE_NAME}"
     exit 0
fi

#print table ${1} does not exist
exit 1
}

#### 
# Main 
####

CHK_PARAM $1
GET_TABLESPACE $1

#### END ####
----------------------------------------------------------------------------------

##
# DB_list_indexes2
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_LIST_INDEXES2
#
# Author           :	DL
#
# Usage            :	DB_LIST_INDEXES2 
#
# Description      :	list all indexes (long version) this DB_LOGIN
#			has access to
#
# Calls            :	DBRQP
#
# Called By        :	None
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - list all indexes (long version) this DB_LOGIN 
has access to 

Usage: $(basename $0)
!
}

CHK_PARAM(){

if [ $# -ne 0 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

SELECT_INDEXES(){

cat <<! | ${HOME}/bin/DBRQP
set pages 0;
set lines 1000;
set feedback off;
select TABLE_OWNER||'.'||TABLE_NAME||','||OWNER||'.'||INDEX_NAME||','||UNIQUENESS||','||TABLESPACE_NAME
from all_indexes
where owner <> 'SYS' and owner <> 'SYSTEM'
order by TABLE_NAME;
!
}

####
# Main
####

CHK_PARAM
SELECT_INDEXES

#### END ####
----------------------------------------------------------------------------------------------

##
# DB_list_synonyms
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_LIST_SYNONYMS
#
# Author           :	DL
#
# Usage            :    DB_LIST_SYNONYMS
#
# Description      :	list all synonyms this DB_LOGIN has access to
#
# Calls            :	DBRQP
#
# Called By        :
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){

cat <<!
$(basename $0) - list all synonyms this DB_LOGIN has access to 

Usage: $(basename $0)
!
}

CHK_PARAM(){

if [ $# -ne 0 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

LIST_SYNONYMS(){

cat <<! | ${HOME}/bin/DBRQP
set pages 0;
set feedback off;
select owner||'.'||object_name from all_objects
where object_type = 'SYNONYM'
and owner <> 'SYS' and owner <> 'SYSTEM'
order by 1;
!
}


####
# Main
####

CHK_PARAM
LIST_SYNONYMS

#### END #### 
------------------------------------------------------------------------------

##
# DB_list_tables
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_LIST_TABLES
#
# Author           :	DL
#
# Usage            : 	DB_LIST_TABLES
#
# Description      :	list all tables this DB_LOGIN has access to
#
# Calls            :	DBRQP
#
# Called By        :	None
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - list all tables this DB_LOGIN has access to 
Usage: $0 
!
}

CHK_PARAM(){

if [ $# -ne 0 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

SELECT_TABLES(){

cat <<! | ${HOME}/bin/DBRQP
set pages 0;
set feedback off;
select owner||'.'||table_name from all_tables
where owner <> 'SYS' and owner <> 'SYSTEM'
order by table_name;
!
}

####
# Main
####

CHK_PARAM
SELECT_TABLES

#### END ####
---------------------------------------------------------------------------

##
# DB_list_views
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_LIST_VIEWS
#
# Author           :	DL
#
# Usage            : 	DB_LIST_VIEWS
#
# Description      :	list all views this DB_LOGIN has access to
#
# Calls            :	DBRQP
#
# Called By        :	NONE
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){
cat <<!
$(basename $0) - list all views this DB_LOGIN has access to 

Usage: $(basename $0)
!
}

CHK_PARAM(){

if [ $# -ne 0 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

SELECT_VIEWS(){

cat <<! | ${HOME}/bin/DBRQP
set pages 0;
set feedback off;
select owner||'.'||view_name from all_views
where owner <> 'SYS' and owner <> 'SYSTEM'
order by view_name;
!
}

####
# Main
####

CHK_PARAM
SELECT_VIEWS

#### END ####
-------------------------------------------------------------------------------------------

##
# DB_load_data
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_LOAD_DATA
#
# Author           :	DL
#
# Usage            :	$(basename $0) <Control file name> <Data file name> 
#
# Description      :	use SQL loader to load data
#
# Calls            :	None
#
# Called By        :	None
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


USAGE(){

cat <<!
$(basename $0) - use SQL loader to load data 

Usage: $(basename $0) <Control file name> <Data file name> 
!
}

CHK_PARAM(){

if [ $# -ne 2 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

CHK_CONTROL_FILE(){
	
ctlfile=$1
if [ ! -r "${ctlfile}" ]
then
    ctlfile=$1.ctl
    if [ ! -r "${ctlfile}" ]
    then
        print "Error: Cannot read sqlload control file: ${1}" >&2
	USAGE >&2
	exit 1
    fi
fi
}

CHK_DATA_FILE(){

datafile=$2
if [ ! -r "${datafile}" ]
then
    datafile=$2.dat
    if [ ! -r "${datafile}" ]
    then
        print "Error: Cannot read sqlload data file: ${2}" >&2
	USAGE >&2
	exit 1
    fi
fi
}

####
# Main
####

CHK_PARAM $1 $2
CHK_CONTROL_FILE $1
CHK_DATA_FILE $2

if [ -z "${SQLLOADER}" ]
then
    SQLLOADER="sqlload"
fi

#DB_LOGIN is exported from .profile DB_LOGIN=$ORACLE_LOGIN/$ORACLE_PASSWD
print "${DB_LOGIN}" | ${SQLLOADER} CONTROL=${ctlfile} DATA=${datafile}

#### END ####
-----------------------------------------------------------------------------------

##
# DB_object_drop_like
##

#!/bin/ksh
# ---------------------------------------------------------------------
#
#
# Script Name      :	DB_OBJECT_DROP_LIKE
#
# Author           :	DL
#
# Usage            : 	$(basename $0) <pattern_to_match>
#
# Description      :	drop all tables and views named like %\$1%
#
# Calls            :	DBRQP
#
# Called By        :
#
#
# ---------------------------------------------------------------------
# Revision History
#
#
# Version    Date     Description
# ---------------------------------------------------------------------
# 1.0     29-11-2000  Created
#
# =====================================================================


VARS(){

TMPFILE=/tmp/DB_object_drop_like.$$.tmp
TMPFILE2=/tmp/DB_object_drop_like1.$$.tmp
TABFILE=/tmp/DB_object_drop_like_2.$$.tmp
VIEWFILE=/tmp/DB_object_drop_like_3.$$.tmp
USERNAME=$(${LOGNAME} | tr '[a-z]' '[A-Z]')
PATTERN=$(print $1 | tr '[a-z]' '[A-Z]')

}

USAGE(){
cat <<!
$(basename $0) - drop all tables and views named like %\$1% 

Usage: $(basename $0) <pattern_to_match>
!
}

CHK_PARAM(){

if [ $# -ne 1 ]
then
    print "Error: Incorrect number of arguments" >&2
    USAGE >&2
    exit 1
fi
}

LIST_INFO(){
print "Only looking for tables owned by: $USERNAME."
print "Dropping all tables and views which are like $1..."

${HOME}/bin/DB_LIST_TABLES | grep "^$USERNAME." |\
cut -d'.' -f2 | grep ${PATTERN} > ${TABFILE}

${HOME}/bin/DB_LIST_VIEWS | grep "^$USERNAME." |\
cut -d'.' -f2 | grep ${PATTERN} > ${VIEWFILE}

if [ -s ${TABFILE} ]
then
    print "Attempting to drop the following tables:"
    cat ${TABFILE}
fi
if [ -s ${VIEWFILE} ]
then
    print "Attempting to drop the following views:"
    cat ${VIEWFILE}
    print ""
fi
}

DROP_OBJECTS(){
cat ${TABFILE} | sed -e 's/^/drop table /' -e 's/$/;/' > ${TMPFILE}
cat ${VIEWFILE} | sed -e 's/^/drop view /' -e 's/$/;/' >> ${TMPFILE}
cat ${TMPFILE} | ${HOME}/bin/DBRQP > ${TMPFILE2}
}

####
# Main
####

VARS $1
CHK_PARAM $1
LIST_INFO
DROP_OBJECTS

print "Complete. $(grep -c 'dropped.' ${TMPFILE2}) Tables/Views were dropped."
print "\nDatabase output:"
cat ${TMPFILE2}
print "\nEnd of database output."

rm -f ${TMPFILE} ${TMPFILE2} ${VIEWFILE} ${TABFILE}
-------------------------------------------------------------------------------------
****************
* gen_hkeys.sh *
****************
#!/bin/ksh
#set -x
# =====================================================================
#
# Script Name : %M%  
#
# Version     : %I% - %G%
#
# Usage       : %M% IA_home_dir table_name column_name 
#
# Description : This script generates new IA house keys for unregistered
#               NAMS ptcabs from the supplied <table_name> 
#
# Exit Status : 
#
#       0       Successful run
#       1       Error in run parameters - see usage
#
# Called by   : Script Controller Application /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

# -------------
# GLOBAL PARAMS
# -------------

APPNAME="GENHKEYS"   # used for general IA error pool identification
IA_HOUSE_KEY_TB=HOUSE_KEYS

# --------------------
# FUNCTIONS/PROCEDURES
# --------------------

Usage ()
{
echo "Usage:$0\tIA_home_dir table_name [column_name]
\ttable_name\tname of table to generate IA house keys for
\tcolumn_name\tdefaults to PTCABS if not specified"
exit 1
}

#----------------------------------------------------------------------
# GET_REC_COUNT - returns number of records present 
#----------------------------------------------------------------------
Get_Rec_Count ()
{
DB_run_query_pipe<<!
set heading off
set pages 0
set feedback off

select count(*) from $TABLE; 
!
}


#----------------------------------------------------------------------
# CHECK_COLUMN_EXISTS - returns 0=not exists 1=exists
#----------------------------------------------------------------------
Check_Column_Exists ()
{
DB_run_query_pipe<<!
set heading off
set pages 0
set feedback off 
select count(*) from all_tables 
where table_name = '$TABLE'; 
!
}


#----------------------------------------------------------------------
# CHECK_FOR_SEQ_INDEX - returns index_name if exists  
#----------------------------------------------------------------------
Check_SEQ_Index ()
{
# check index exists
DB_run_query_pipe<<!
set heading off
set feedback off
set pages 0
select index_name 
from all_ind_columns 
where table_name = '$TABLE'
and column_name = 'SEQ';
!
}


#----------------------------------------------------------------------
# BUILD_SEQ_INDEX - creates index on SEQ column for the input table 
#----------------------------------------------------------------------
Build_SEQ_Index ()
{
#COLLEN=11   # length of PTCABS
#IDX_INIT=`echo "$COLLEN * $RECCOUNT / 1024 " | bc`
#IDX_NEXT=$IDX_INIT
INI=$1
NXT=$2
IDX_NAME=${TABLE}_SEQ


#note: LOAD_IDX_TBLSP is derived from ia_vars.sh

RETVAL=`DB_run_query_pipe<<!
CREATE UNIQUE INDEX $IDX_NAME 
 ON ${TABLE}(SEQ)  STORAGE(
     INITIAL $INI  NEXT $NXT  PCTINCREASE 0)
#NOLOGGING TABLESPACE ${LOAD_IDX_TBLSP};
NOLOGGING TABLESPACE ${DIM2K_IDX};
!`

RET=`echo $RETVAL | grep -i 'Index created.'`
if [ $? -ne 0 ]; then
   echo "Index $IDX_NAME build failed, aborting"
   exit 4
else
   echo "Index $IDX_NAME built"
fi
}




#----------------------------------------------------------------------
# GENERATE_HOUSE_ID - assigns an IA House Id to non registered PTCABS 
#----------------------------------------------------------------------
Generate_House_ID ()
{
echo "Generating IA house identifiers for non registered PTCABS id's" 

# if server has multiprocessor OPQ capability
# switch APPEND hint to PARALLEL 
DB_run_query_pipe<<!
set serveroutput on size 1000000;
declare
    w_commit number(10) := 50000;
    w_chunks number(10) := 0;
    w_tot_recs number(10) := 0;

    w_start_seq  number(10) := 0; 
    w_end_seq number(10) := w_commit;
begin
 
	select count(*) into w_tot_recs from $TABLE;
	w_chunks := ceil(w_tot_recs / w_commit);
	
	For chunk in 1..w_chunks Loop
	
	    insert /*+ APPEND */ into $IA_HOUSE_KEY_TB  
       select  b.$COLUMN_NAME,house_keys_SEQ.nextval  
       from    (select distinct $COLUMN_NAME from $TABLE
	      	    where (seq > w_start_seq and seq < w_end_seq + 1)) b
       where not exists (select '1'from $IA_HOUSE_KEY_TB  a
                         where a.ptcabs = b.$COLUMN_NAME);
		 
        commit;
	     dbms_output.put_line('last seq boundry :'||w_end_seq);
	
		w_start_seq := w_end_seq;
		w_end_seq := w_end_seq + w_commit;
	End Loop;
   commit;
exception
	When Others Then
		Dbms_Output.Put_Line('last successfull commit seqno:'||w_start_seq);
		Dbms_Output.Put_Line(SqlErrm); 
end;
/
!

}


#----------------------------------------------------------------------
# SWITCH_IDENTIFIERS - replaces the NAMS PTCABS from the specified
#                      table with the new IA house id 
#----------------------------------------------------------------------
Switch_Identifiers ()
{
echo "Switching old PTCABS identifiers to new IA house id's for $TABLE"
DB_run_query_pipe<<!
set timing on
update ${TABLE} a 
set $COLUMN_NAME = (select house_id 
              from $IA_HOUSE_KEY_TB b 
              where a.$COLUMN_NAME = b.ptcabs);
commit;
!
}


#----------------------------------------------------------------------
# RENAME_TABLE - renames the specified table after processing to
#                indicate new IA house identifies have been assigned
#                Also renames the index
#----------------------------------------------------------------------
Rename_Table ()
{
# rename the table to TABLE_IA to indicate change of
# house identifier system NAMS PTCABS -> new IA PTCABS 

# check if destination table already exists

RETVAL=`DB_run_query_pipe<<!
set feedback off
set pages 0
set heading off
select count(*) from all_tables
where table_name = 'IA_${TABLE}';
!`

TABEXISTS=`echo $RETVAL|awk '{print $1}'`

if [ $TABEXISTS -eq 1 ]; then 
echo "Destination table already exists - now removing"
DB_run_query_pipe<<!
Drop table IA_${TABLE};
!
fi

DB_run_query_pipe<<!
alter table $TABLE rename to IA_${TABLE};
alter index $IDX_NAME rename to IA_${IDX_NAME};
!
}


#--------------------------------------------------------------------
# M A I N
#--------------------------------------------------------------------

# need to add in pp2_vars and PP2 error pooling

if [ $# -lt 2 ] 
then
  Usage 
fi

IA_BIN=$1

if [ ! -f ${IA_BIN}/ia_vars.sh ] ; then
 echo "Can't find parameter file tried: ${IA_BIN}/ia_vars.sh"
 exit 1
fi

# load PP2 environment vars
. ${IA_BIN}/ia_vars.sh


typeset -u TABLE 
typeset -u COLUMN_NAME

TABLE=$2
COLUMN_NAME=$3

# if no $3 supplied - default to HOUSE_ID
if [ -z $COLUMN_NAME ]; then
  COLUMN_NAME=HOUSE_ID
fi

# check column exists
COLEXISTS=`Check_Column_Exists| awk '{print $1}'`
if [ $COLEXISTS -eq 0 ]; then
  echo "Table/Column $TABLE.$COLUMN_NAME not found"
  exit 2
fi

# Confirm Records Present in Table
RECCOUNT=`Get_Rec_Count| awk '{print $1}'`
if [ $RECCOUNT -lt 1 ]; then
   echo "No Records in table, aborting."
   exit 3
else
   echo "Found $RECCOUNT records"
fi

IDX_NAME=`Check_SEQ_Index| awk '{print $1}'`
if [ -z $IDX_NAME ]; then
   echo "Index not detected, building.."
   Build_SEQ_Index 100M 100M
else
  echo "Index $IDX_NAME detected"
fi

Generate_House_ID      # update any new incoming house keys
Switch_Identifiers     # update the source table with new IA house keys
Rename_Table           # rename source table to table_IA to indicate 
                       # change of PTCABS system

# --------------------------------------------------------------[END]-

************
* type_a.s *
************
#!/bin/ksh

log()
{
  echo "$(date +%Y-%m-%d-%H:%M:%S): "$* | tee -a ${IA_HOME}/log/$(basename $0)".$$"
}

error_chk(){

ES=$1
MOD=$2

if [[ $ES != "0" ]]
then
    echo "$MOD : Failed"
    exit 1
else
    echo "$MOD : Finished Successfully"
fi
}

usage ()
{
   /usr/bin/echo "Usage : $0 table2"
   exit 1
}

check_columns ()
{
DB_desc ${TAB} > /tmp/$$.${TAB}.desc

for COL in SEQ HOUSE_ID SURNAME FORENAME SECOND_INITIAL GENDER
do
	if  [ `grep -w ${COL} /tmp/$$.${TAB}.desc | wc -l ` = 0 ] ; then
		echo "no ${COL}"
	else
		echo "yes ${COL}"
	fi
done

rm /tmp/$$.${TAB}.desc
}

insert_A ()
{
DB_run_query_pipe<<!
whenever sqlerror exit failure
Prompt Cleaning out ${CAN_A}...
truncate table ${CAN_A};

Prompt Inserting data from ${TAB} ...
insert into ${CAN_A} (ID,HOUSE_ID,SURNAME,FORENAME,SECOND_INITIAL,GENDER,SEQ)
select 0,HOUSE_ID,SURNAME,FORENAME,SECOND_INITIAL,GENDER,SEQ from ${TAB};
!
error_chk $? insert_data_from_${TAB}

DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
Prompt insert data from match to candidate_a... ;
insert into ${CAN_A} (ID,HOUSE_ID,SURNAME,FORENAME,SECOND_INITIAL,GENDER,SEQ)
select ID,HOUSE_ID,SURNAME,FORENAME,SECOND_INITIAL,GENDER,0 from match;
exit sql.sqlcode
!
error_chk $? insert_match_to_candidate_a
}

truncate_matchtemp()
{

DB_run_query_pipe <<!
truncate table match_temp;
!
}

run_hfs()
{

if [[ $# != 1 ]]
then
  echo "Error incorrect parameter passed!"
  echo "Usage run_hfs <<A/B>>"
fi

CONTROL=$(echo $1 | tr "[a-z]" "[A-Z]")
case $CONTROL in
  A)
        SQL_TEXT=$(cat <<-! | DB_run_query_pipe
        select max(id) from candidate_a;
        !
        )

        MAX_ID=$(echo $SQL_TEXT | awk '{print $NF}')
        echo "The max_id from candidate_a before running"
        echo "the Resolve routine is : $MAX_ID"
        $HOME/prod/bin/hfs.exe $CONTROL $MAX_ID
        insert_into_match $MAX_ID
        ;;
  *)
        echo "Error unknown parameter passed!"
        exit 1
        ;;
esac
}

insert_into_match()
{
MAX_ID=$1

DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
Prompt insert into match with data from candidate_a;
insert into match  (id,house_id,surname,forename,gender,seq)
select  id, 
	house_id, 
	surname, 
	forename,
	gender,
   seq
from	match_temp
where   id > ${MAX_ID};
exit sql.sqlcode;
!
error_chk $? insert_into_match
}



## 
# Main
##

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $(basename $0)"

if [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of parameters passed."
   usage
fi

IA_BIN=$HOME/prod/bin
. ${IA_BIN}/ia_vars.sh

CAN_A=CANDIDATE_A
TAB=$1

check_columns
insert_A
log "truncating table match_temp"
truncate_matchtemp
run_hfs A
-----------------------------------------------------------------------

*****************
* dcu_MY option *
*****************
head -2 $HOME/prod/workspace/create_dim2k.sql > ttt
echo " ID                        NUMBER(11)," >> ttt
tail +3 $HOME/prod/workspace/create_dim2k.sql >> ttt


mv $HOME/prod/workspace/create_dim2k.sql $HOME/prod/workspace/create_dim2k.sql2

mv ttt $HOME/prod/workspace/create_dim2k.sql



head -6 $HOME/prod/workspace/ldr_dim2k.ctl  > ttt
echo " ID               CONSTANT 99999999999,  " >> ttt
tail +7 $HOME/prod/workspace/ldr_dim2k.ctl  >> ttt

mv $HOME/prod/workspace/ldr_dim2k.ctl $HOME/prod/workspace/ldr_dim2k.ctl2

mv ttt $HOME/prod/workspace/ldr_dim2k.ctl
-------------------------------------------------------------------------------------------
*************
* dedupe.sh *
*************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : Removes duplicate entries on the IA_LOAD_DIM2K.
#               
#
# Called by   : combine_harvester.sh
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

usage()
{
echo "Usage: <<ia_bin>> <table>>"
exit 1
}


remove_dupes ()
{
DB_run_query_pipe<<!
whenever sqlerror exit failure
alter table ${TABLE} nologging;

create table ${DUPES}
tablespace USERS
storage (initial 1m next 1m pctincrease 0) 
pctused 99 pctfree 0 nologging
as
select rowid DIM_ID,id from ${TABLE}
where (id) in 
(select id from ${TABLE}
group by id having count(*) >1)
;

create table ${KEEPS}
tablespace USERS
storage (initial 1m next 1m pctincrease 0) 
pctused 99 pctfree 0 nologging
as
select min(rowid) K_ID,id
from ${DUPES}
group by id;

delete from ${DUPES} where rowid in (select K_ID from ${KEEPS});
!
if [ $? != 0 ] ; then
	exit 201
fi

TMP=`DB_run_query_pipe<<! 
delete from ${TABLE} where rowid in (select DIM_ID   from ${DUPES});
!
` 

TMP=`echo $TMP | awk '{print $1}'`

#${IA_BIN}/ia_reports.sh DUPE $TMP

DB_run_query_pipe<<!
drop table ${DUPES};
drop table ${KEEPS};
!

if [ $? != 0 ] ; then
	exit 201
fi
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 2 ] ; then
   /usr/bin/echo "Wrong number of paramters passed."
   usage
fi

# Set up standard variables

IA_HOME=$1
. ${IA_HOME}/bin/ia_vars.sh

TABLE=$2
DUPES=$2_DUPES
KEEPS=$2_KEEPS

remove_dupes
# ============================[END]==================================

*************
* run_dim2k *
*************
#!/usr/bin/ksh

####
# This routine first swap the ptcabs for house keys
# using Jari's script gen_hkeys.sh.
# Then run through the type A matching Pro*C routine
# to update load_dim2k table
####

log()
{
  echo "$(date +%Y-%m-%d-%H:%M:%S): "$* | tee -a ${IA_HOME}/log/$(basename $0)".$$" 2>/dev/null
}

error_chk(){

ES=$1
MOD=$2

if [[ $ES != "0" ]]
then
    log "$MOD : Failed"
    exit 1
else
    log "$MOD : Finished Successfully"
fi
}

chk_index_exists()
{

if [[ $# != 2 ]]
then
    log "Error wrong parameters passed"
    log "Usage: chk_index_exists <<TABLE>> <<COL>>"
    exit 2
fi

TABLENAME=$1
COL=$2

# check index exists
DB_run_query_pipe<<!
set heading off
set feedback off
set pages 0
select index_name
from all_ind_columns
where table_name = '$TABLENAME'
and column_name = '$COL';
!
}

create_index()
{
TABLENAME=$1
COL=$2
TABLESPACE=$3
INI=$4
NXT=$5
IDX_NAME=${TABLENAME}_${COL}_IDX

if [[ $# != 5 ]]
then
   log "\n
   I need 3 parameters for this function in the following order:
   TABLENAME      # eg house
   COL			   # eg ptcabs
   TABLESPACE     # eg users
   INI
	NXT"
	exit 1
fi

#ROWCOUNT=$(DB_row_count $TABLENAME | awk '{print $1}')
#LEN=$(DB_desc $TABLENAME | grep $COL | awk -F\( '{print $2}' | sed 's/)//')   # length of index column
#INI=`echo "${LEN:-11} * $ROWCOUNT / 1024 / 10 " | bc`
#NXT=$(expr $INI / 2 )

log "Creating index $IDX_NAME..."
DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
create  index $IDX_NAME on
  		  ${TABLENAME}($COL)
  		  nologging tablespace $TABLESPACE pctfree 0
        storage(initial ${INI} next ${NXT} pctincrease 0);
exit sql.sqlcode
!
CE=$?
error_chk $CE create_index
}


index_wrap()
{

TAB=$1
COL=$2
TSPACE=$3
INI=$4
NXT=$5
IDX_NAME=${TAB}_${COL}_IDX

CHK=$(chk_index_exists $TAB $COL | awk '{print $1}')
if [ -z $CHK ]; then
   log "Index not detected, building..."
   create_index $TAB $COL $TSPACE $INI $NXT
else
   log "Index ${INX_NAME} detected"
fi
}


create_dim2k()
{

if DB_object_not_exists load_dim2k ; then
DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
prompt creating table load_dim2k from dim2k ...
create table load_dim2k
tablespace load_data
pctfree 0 pctused 99
storage (initial 50M next 50M pctincrease 0)
nologging as select
HOUSE_ID,
STREET_CODE,
SURNAME,
FIRST_INITIAL,
TITLE_CODE,
FORENAME,
SECOND_INITIAL,
PERSON_RESIDENCY,
GENDER,
PERSON_MARRIED_FLAG,
PERSON_HOH_FLAG,
PERSON_ATTAINER_FLAG,
PERSON_DECEASED_FLAG,
PERSON_MOVER,
PERSON_DATE_OF_BIRTH_DATE,
PERSON_INVESTOR,
PERSON_WESCORE,
PERSON_WESCORE_INSIGHT,
PERSON_WESCORE_BAD,
PERSON_WESC_PC,
PERSON_WESC_PC_INSIGHT,
PERSON_WESC_PC_BAD,
PERSON_CCJ_DATE,
PERSON_CCJ_VALUE,
PERSON_INSIGHT_WS,
PERSON_INSIGHT_DATE_WS,
PERSON_INSIGHT_VALUE_WS,
PERSON_INSIGHT_WE,
PERSON_INSIGHT_DATE_WE,
PERSON_INSIGHT_VALUE_WE,
PERSON_SURKEY,
HOUSE_POSTSORT,
HOUSE_SOURCE,
HOUSE_GB,
HOUSE_MPS,
HOUSE_HH_COMPOSITION,
HOUSE_NO_SURNAMES,
HOUSE_NO_PEOPLE,
HOUSE_NO_ADULTS,
HOUSE_NO_ATTAINERS,
HOUSE_NO_RESIDENCY,
HOUSE_NO_MR,
HOUSE_NO_MRS,
HOUSE_NO_MISS,
HOUSE_NO_MS,
HOUSE_NO_OTHER,
HOUSE_SRH6,
HOUSE_SRH12,
HOUSE_SRH24,
HOUSE_CCJ6,
HOUSE_CCJ12,
HOUSE_CCJ24,
POSTCODE_POSTCODE,
POSTCODE_CAMEO_MATCH_FLAG,
POSTCODE_CAMEO_UK,
POSTCODE_CAMEO_UK_GROUP,
POSTCODE_CAMEO_PROP,
POSTCODE_CAMEO_INCC,
POSTCODE_CAMEO_INVV,
POSTCODE_CAMEO_FINC,
POSTCODE_TV_REGION,
POSTCODE_DIRECTOR_FLAG,
POSTCODE_DEFINE,
POSTCODE_INCOME_NATIONAL,
POSTCODE_INCOME_REGIONAL,
POSTCODE_MICROVISION,
HOUSE_TELEPHONE_FLAG,
PERSON_YEAR_OF_BIRTH,
PERSON_AGE_18_24,
PERSON_AGE_25_34,
PERSON_AGE_35_44,
PERSON_AGE_45_54,
PERSON_AGE_55_64,
PERSON_AGE_65_PLUS,
PERSON_FRUIT,
PERSON_FRUIT_SCORE_VALUE,
POSTCODE_CAMEO_UNEMPLOYMENT,
POSTCODE_CAMEO_INTL,
HOUSE_DPS,
POSTCODE_WEALTH_INDICATOR,
PERSON_MM_DOM_TYPE,
PERSON_MM_DOM_SCORE,
PERSON_MM_SCORE_A,
PERSON_MM_SCORE_F,
PERSON_MM_SCORE_T,
PERSON_MM_SCORE,
PERSON_NEW_YEAR_OF_BIRTH,
PERSON_DE_MATCH_FLAG,
PERSON_DE_DATE_OF_BIRTH,
PERSON_DE_OCCUPATION,
PERSON_DE_INCOME,
PERSON_DE_GENDER,
PERSON_DE_CHILDREN,
PERSON_DE_CHILD_AGE,
PERSON_DE_CH1_DATE_OF_BIRTH,
PERSON_DE_CH2_DATE_OF_BIRTH,
PERSON_DE_CH3_DATE_OF_BIRTH,
PERSON_DE_BANK_ACCOUNT,
PERSON_DE_LIFE_INSURANCE,
PERSON_DE_CREDIT_CARD,
PERSON_DE_CAR_OWNER,
PERSON_DE_MAIL_ORDER_BUYER,
PERSON_DE_RESPONDER,
PERSON_DE_BLUE_CHIP,
PERSON_DE_PRIVATE,
PERSON_DE_MULTI,
PERSON_DE_HOLIDAY,
PERSON_DE_DAILY,
PERSON_DE_SUNDAY,
PERSON_DE_PROPERTY_INSURANCE,
PERSON_DE_MOTOR_INSURANCE,
PERSON_DE_DIRECTORS_FLAG,
ID,
SEQ
from dim2k where rownum <100001;
exit sql.sqlcode
!
fi
ES=$?
error_chk $ES create_load_dim2k
}


update_id_and_dedupe()
{
log "updating id column on table ia_load_dim2k ..."
DB_run_query_pipe<<!
whenever sqlerror exit sql.sqlcode
update ia_dim2k
set id = (select id from match_temp where match_temp.seq = ia_dim2k.seq);
exit sql.sqlcode
!
ES=$?
error_chk $ES update_dim2k

log deduping table ia_dim2k 
dedupe.sh $HOME/prod ia_load_dim2k
ES=$?
error_chk $ES dedupe_dim2k
}


####
# Main
####

. $HOME/prod/bin/ia_vars.sh
log Started

# testing removed in final version
#log creating a small test table dim2k ...
#create_dim2k
# swap ptcabs for house_id against table dim2k
log "running Jari's swapping routine ..."
$IA_HKEYS/gen_hkeys.sh $IA_BIN DIM2K HOUSE_ID

ES=$?
error_chk $ES gen_hkeys.sh

# Tablespace might need to be changed in final version
log "runnning index_wrap on match_temp to create seq index ..."
index_wrap MATCH_TEMP SEQ IA_INDEX 100M 100M
ES=$?
error_chk $ES index_wrap_matchtemp

# now run against type_a matching to insert data
# to candidate_a from table ia_dim2k
log "running type_a.sh script ..."
$IA_RESOLVE/type_a.sh IA_DIM2K
ES=$?
error_chk $ES type_a.sh
log "running update and deduping ..."
update_id_and_dedupe
log "End of program"
####
# END
####
---------------------------------------------------------------------------------------------------
*******************************************
* USEFUL SHELL SCRIPTS/FUNCTIONS/PROGRAMS *
*******************************************

******************************
* goto xy screen co-ordinate *
******************************
gotoxy()
{
# invoke: gotoxy row column "text"
ROW=$1
COL=$2
TEXT=$3

tput cup $ROW $COL
print "$TEXT \c"
}

******************************************
* centre: a string of text across screen *
* invoke: centre "string" row_number     *
******************************************
centre()
{

STR=$1
ROW=$2
LEN=$(print $STR | awk '{length($0)}')
COLS=$(tput cols)
HOLD_COL=$(expr $COL - $LEN)
NEW_COL=$(expr $HOLD_COL / 2)

tput cup $ROW $NEW_COL
print " $STR \c"

e.g. tput clear
gotoxy 2 3 "USER: $LOGNAME"
centre "Add a new warp drive to a star ship" 3
}

-----------------------------------------------------
*****************
* USING COLOURS *
*****************

COLOUR			FOREGROUND	BACKGROUND
------			----------	----------
black			30		40
red			31		41
green			32		42
yellow(or brown)	33		43
blue			34		45
purple			35		44
cyan			36		46
white(or grey)		37		47


format : <escape> [ bg; fg m
e.g.
Linux/BSD	echo -e "\033[40; 32m"
System V	echo    "\033[40; 32m"
Generic method	echo "<CTRL-V><ESCAPE>[40; 32m"

Usage in script:
---------------
colour whatever
echo something
# now change to a different colour
colour whatever
echo something

***********************************
* colour function		  *
* format is background_foreground *
***********************************
colour()
{

case $1 in
     black_green) 	print '^[[40; 32m';;
     black_yellow)	print '^[[40; 33m';;
     black_white)	print '^[[40; 37m';;
     black_cyan)	print '^[[40; 36m';;
     red_yellow) 	print '^[[41; 33m';;
esac
}
-----------------------------------------------------------------------------------------------------------------------
*************
* GRABCHARS *
*************

ANS=`grabchars -q'Answer y or n: '`

By default, the answer that grabchar reads and echoes will be "eaten" by the backquotes; the user won't see what
she typed. That nice when the answer needs to be secret. To show the answer you have two choices:
1) You can use -b option grabchars will echo the answer to both stdout (which the backquotes read) and stderr (which
   is usually the terminal)
2) You can also use the following

while true
do
  ANS=`grabchars -q'Answer y or n:'`
  case "$ANS" in
	y) echo "yes" 1>&2; break;;
	n) echo "no"  1>&2; break;;
	*) echo "${ANS}?Please answer y or n" 1>&2;;
  esac
done

The option -c valid-characters tells grabchars to accept only characters listed in valid-characters (this can be a
regular expression like [a-z]). If the user types something that isn't listed, grabchars will ignore the answer
and wait. So to accept only y or n: ANS=`grabchar -c'yn' -q 'Answer y or n:'`

ANS=`grabchars -t5 -d'y' -q 'To stop, type n within 5 seconds: '`

If the user doesn't type anything in 5 seconds, grabchars will answer y by default (automatically).
---------------------------------------------------------------------------------------------------------------------
*******************
* ADD RECORD MENU *
*******************

##
# function to check the length of string
##
chk_str_length()
{

STR=$1
MAX=$2
LENGTH=$(print $STR | awk '{print length($1)}')

if [[ "$LENGTH" -gt "$MAX" ]]
then
   return 1
else
   return 0
fi
}

##
# function to check whether a string contains all numeric data
##
all_number()
{

STR=$1
CHK=$(print $1 | awk '{if($0~/[^0-9]/) print "1"}')

if [[ "$CHK" != "" ]]
then
   return 1
else
   return 0
fi
}

##
# function to check string contains only characters
##
characters()
{

STR=$1
CHK=$(print $1 | awk '{if($0~/[^a-zA-Z]/) print "1"}')

if [[ "$CHK" != "" ]]
then
   return 1
else
   return 0
fi
}

##
# continue_prompt
##
continue_prompt()
{

print "Hit any key to continue ..."
DUMMY=$(read_a_char)
}

##
# read_a_char
##
read_a_char()
{

SAVEDSTTY=$(stty -g)

stty cbreak
dd if=/dev/tty bs=1 count=1 2>/dev/null
stty -cbreak

stty $SAVEDSTTY
}

##
# function to check for the existence of a str in a file
##
if_exist()
{

STR=$1
CHK=$(grep "$STR\>" $INFILE)
print $STR

if [[ "$CHK" = "" ]]  # grep returns no string for no matches
then
   return 0	# no duplicate found
else
   return 1	# duplicate found
fi
}

##
# get_staff_number
##
get_staff_number()
{

while true
do
  print "Employee staff number: \c"
  read NUM
  if [[ "$NUM" != "" ]]
  then
     if all_number $NUM
     then
	NUM_PASS=0
     else
	NUM_PASS=1
     fi
     if chk_str_length $NUM 10
     then
	LEN_PASS=0
     else
	LEN_PASS=1
     fi
     # now check for duplicate ...
     if if_exist $NUM
     then
        DUPLICATE=0
     else
        DUPLICATE=1
	print "staff number: there is already an employee with this number"
	continue_prompt
     fi
     if [[ "$LEN_PASS" = "0" -a "$NUM_PASS" = "0" -a "$DUPLICATE" = "0" ]]
     then
        break
     else
        print "staff number: non-numeric or too many numbers in fields"
        continue_prompt
     fi
   else
      print "staff number: no input detected, this field requires a number."
      continue_prompt
   fi
done
}

##
# get_first_name
##
get_first_name()
{
while true
do
  print "Employee's first name: \c"
  read F_NAME
  if [ "$F_NAME" != "" ]
  then
     if characters $F_NAME
     then
        F_NAME_PASS=0
     else
        F_NAME_PASS=1
     fi
     if chk_str_length $F_NAME 20
     then
        LEN_PASS=0
     else
        LEN_PASS=1
     fi
     # both conditions must be true to get out of this loop
     if [ "$LEN_PASS" = "0" -a "$F_NAME_PASS" = "0" ]
     then
        break
     else
        print "Staff first name: non-numeric character or too many chars"
        continue_prompt
     fi
  else
     print "staff first name: no input detected ..."
     continue_prompt
  fi
done
}
------------------------------------------------------------------------------
##
# get_last_name
##
get_last_name()
{
while true
do
  print "Employee's surname: \c"
  read S_NAME
  if [ "$S_NAME" != "" ]
  then
     if characters $S_NAME
     then
        S_NAME_PASS=0
     else
        S_NAME_PASS=1
     fi
     if chk_str_length $S_NAME 20
     then
        LEN_PASS=0
     else
        LEN_PASS=1
     fi
     if [ "$LEN_PASS" = "0" -a "$S_NAME_PASS" = "0" ]
     then
        break
     else
        print "Staff surname: non character or too many characters"
        continue_prompt
     fi
  else
     print "Staff surname: No input detected. This field requires characters"
     continue_prompt
  fi
done
}
----------------------------------------------------------
##
# get_department
##
get_department()
{
while true
do
  print "Company dept : \c"
  read DEPART
  case $DEPART in
     ACCOUNTS|Accounts|accounts) break;;
     SALES|Sales|sales)          break;;
     IT|It|it)                   break;;
     CLAIMS|Claims|claims)       break;;
     SERVICES|Services|services) break;;
     *) print "Dept: Accounts, Sales, IT, Claims, Services";;
  esac
done
}
-----------------------------------------------------------------------------------
##
# continue_prompt
##
continue_prompt()
{
if [ $# -lt 1 ]
then
   print "continue_prompt: I need a string to display"
   exit 1
fi
while true
do
  print "$STR [Y..N] [$DEFAULT]: \c"
  read ANS
  # if user hits return set the default & determine the return value
  : ${ANS := $DEFAULT}
  if [ "$ANS" = "" ]
  then
     case $ANS in
        Y) return 0;;
        N) return 1;;
     esac
  fi
  # user has selected something
  case $ANS in
    y|Y|YES|Yes) return 0;;
    n|N|NO|No)   return 1;;
    *) print "Answer either Y or N, default is $DEFAULT";;
  esac
  print $ANS
done
}
-------------------------------------------------------------------------------------
##
# add_record
##
add_record()
{
  get_staff_number
  get_first_name
  get_last_name
  get_department
}
##
# Main
##
tput clear
print "\t\t ADD AN EMPLOYEE RECORD \c"
if [ -s $INFILE ]
then
   : #do nothing
else
   print "Info: creating new file to add employee records"
   > $INFILE
fi
add_record
if continue_prompt "Do you want to save this record" "Y"
then
   print "$NUM : $F_NAME : $S_NAME : $DEPART" >> $INFILE
   print "record saved"
   sleep 1
   sort +2 -t: $INFILE > $TEMPFILE 2>/dev/null
   if [ $? -ne 0 ]
   then
      print "Problems trying to sort the file: check it out"
      exit 1
   fi
   mv $TEMPFILE $INFILE
   if [ $? -ne 0 ]
   then
      print "Problems moving the temp sort file ... check it out"
      exit 1
   fi
else
   print "record not saved"
   sleep 1
fi
---------------------------------------------------------------------------------------------------------------
******************
* DELETE RECORDS *
******************

#!/bin/ksh
# dbase_del delete a record

# trap signals
trap "" 2 3 15

DBFILE=DBFILE  # datafile
HOLD1=HOLD1.$$ # tempfile
HOLD2=HOLD2.$$

##
# continue_prompt
##
continue_prompt()
{
STR=$1
DEFAULT=$2
# check we have the right parameters
if [ $# -lt 1 ]; then
  echo "continue_prompt: I need a string to display"
  exit 1
fi
while true
do
  echo "$STR [Y..N] [$DEFAULT] :\c"
  read ANS
  : ${ANS:=$DEFAULT}
  if [ "$ANS" = "" ]; then
     case $ANS in
        Y) return 0;;
        N) return 1;;
     esac
  fi
  case $ANS in
     y|Y|Yes|YES) return 0;;
     n|N|No|NO)   return 1;;
     *) echo "Answer either Y or N, default is $DEFAULT";;
  esac
done
}

##
# display_record
##
display_record()
{
cat <<-!
    EMPLOYEE NUMBER : $CODE
    FIRST NAME      : $F_NAME
    SURNAME         : $S_NAME
    DEPARTMENT      : $DEPART
    !
}

##
# no record
##
no_record()
{
echo -e "Sorry could not find a record with the name $STR"
}

##
# get_record
##
get_record()
{
clear
echo -n "Enter the employee surname"
read STR
if [ "STR" = "q" ]; then
  return 1
fi
REC=0
MATCH=no
if [ "$STR" != "" ]; then
  while read CODE F_NAME S_NAME DEPART
  do
     REC=$(expr $REC + 1)
     tput cup 3 4
     echo -n "searching record ... $REC"
     if [ "$S_NAME" = "$STR"]; then
       MATCH=yes
       display_record
       break
     else
       continue
     fi
   done < $DBFILE
else
  echo "Enter a surname to search for or q to quit"
fi
if [ "$MATCH" = "no" ]; then
  no_record
fi
}

##
# Main
##
SAVEDIFS=$IFS
IFS=:
get_record
if [ "$MATCH" = "yes" ]; then
  if continue_prompt "Do you wish to DELETE this record? " "N"; then
  echo "DEL"
  grep -v $STR $DBFILE > $HOLD1 2>/dev/null
  if [ $? -ne 0 ]; then
    echo "Problems creating temp file $HOLD1 ... check it out"
    exit 1
  fi
  mv $HOLD1 $DBFILE
  if [ $? -ne 0 ]; then
    echo "Problems moving temp file ... check it out"
    exit 1
  fi
  # sort the file after changes
  sort +2 -t: $DBFILE > $HOLD2 2>/dev/null
  if [ $? -ne 0 ]; then
    echo "problems trying to sort the file ... check it out"
    exit
  fi
  mv $HOLD2 $DBFILE
  if [ $? -ne 0 ]; then
    echo "Problems moving the temp sort file ... check it out"
    exit 1
  fi
  else
    echo "no deletion"
  fi # if wish to delete
fi # if match
IFS=$SAVEDIFS  # restore IFS settings
---------------------------------------------------------------------------------------------------
********************
* AMENDING RECORDS *
********************

#!/bin/ksh
# dbasechange - amending a record

trap "" 2 3 15  # ignore signals
DBFILE=DBFILE
HOLD1=HOLD1.$$
HOLD2=HOLD2.$$

##
# continue_prompt
##
continue_prompt()
{
STR=$1
DEFAULT=$2

if [ $# -lt 1 ]; then
  echo "continue_prompt: I need a string to display"
  return 1
fi
while true
do
  echo -n "$STR [Y..N] [$DEFAULT]: "
  read ANS
  : ${ANS:=$DEFAULT}
  if [ "$ANS" = "" ]; then
    case $ANS in 
        Y) return 0;;
        N) return 1;;
    esac
  fi
  case $ANS in
     y|Y|Yes|YES) return 0;;
     n|N|No|NO)   return 1;;
     *) echo "Answer either Y or N, default is $DEFAULT";;
  esac
done
}


##
# display_record
##
display_record()
{
cat <<-!
    EMPLOYEE NUMBER : $CODE
    FIRST NAME      : $F_NAME
    SURNAME         : $S_NAME
    DEPARTMENT      : $DEPART
    !
}


##
# no_record
##
no_record()
{
  echo "Sorry could not find a record with the name $STR"
}

##
# get_record
##
get_record()
{
clear
echo "Enter the employee surname: \c"
read STR
if [ "$STR" = "q" ]; then
  return 1
fi
REC=0
MATCH=no
if [ "$STR" != "" ]; then
  while read CODE F_NAME S_NAME DEPART
  do
    REC=$(expr $REC + 1)
    tput cup 3 4
    echo -n "searching record ... $REC"
    if [ "$S_NAME" = "$STR" ]; then
      MATCH=yes
      display_record
      break
    else
      continue
    fi
  done < $DBFILE
else
   echo "Enter a surname to search for or q to quit"
fi
if [ "$MATCH" = "no" ]; then
  no_record
fi
}

##
# Main
##
SAVEDIFS=$IFS
IFS=:
get_record
if [ "$MATCH" = "yes"]; then
  if continue_prompt "Is this the record you wish to amend?" "Y"; then
    echo "amending"
    echo -n -e "EMPLOYEE No.: $CODE\n" # cannot change employee code
    echo -n "FIRSTNAME: [$F_NAME] > "
    read F_NAME
    : ${F_NAME:=$F_NAME}
    echo -n "SURNAME: [$S_NAME] > "
    read S_NAME
    : ${S_NAME:=$S_NAME}
    echo -n "DEPARTMENT : [$DEPART] > "
    read DEPART
    : ${DEPART:=$DEPART}

    grep -v $CODE $DBFILE > $HOLD1
    if [ $? -ne 0 ]; then
      echo "Problems creating temporary file ... check it out"
      exit 1
    fi
    if continue_prompt "Ready to save this record" "Y"; then
      echo "$CODE : $F_NAME : $S_NAME : $DEPART >> HOLD1
      mv $HOLD1 $DBFILE
      if [ $? -ne 0 ]; then
        echo "Problems moving temporary file ... check it out"
      fi
      echo "record amended"
      # now sort the file after changes
      sort +2 -t: $DBFILE > $HOLD2 2>/dev/null
      if [ $? -ne 0 ]; the
        echo "problems trying to sort the file ... check it out"
        exit 1
      fi
      mv $HOLD2 $DBFILE
      if [ $? -ne 0 ]; then
        echo "Problems moving the temp sort file ... check it out"
        exit 1
      fi
    else # if no amend
      echo "no amending"
    fi  # if wish to delete
fi  # if match
IFS=$SAVEDIFS
--------------------------------------------------------------------------------------------------------------
****************
* VIEW RECORDS *
****************

#!/bin/ksh
# dabaseview - view records

trap "" 2 3 15  # ignore traps
HOLD1=HOLD1.$$
DBFILE=DBFILE

##
# continue_prompt
##
continue_prompt()
{
STR=$1
DEFAULT=$2

if [ $# -lt 1 ]; then
  echo "continue_prompt: I need a string to display"
  return 1
fi
while true
do
   echo -n "$STR [Y..N] [$DEFAULT]: "
   read ANS
   : ${ANS:=$DEFAULT}
   if [ "$ANS" = "" ]; then
      case $ANS in
         Y) return 0;;
         N) return 1;;
      esac
   fi
   case $ANS in
      y|Y|Yes|YES) return 0;;
      n|N|No|NO)   return 1;;
      *) echo "Answer either Y or N, default is $DEFAULT";;
   esac
done
}

##
# display_record
##
display_record()
{
cat <<!
	EMPLOYEE No.	: $CODE
	FIRST NAME      : $F_NAME
	SURNAME		: $S_NAME
	DEPARTMENT	: $DEPART
!
}

##
# no_record
##
no_record()
{
   echo -e "\n\nSorry could not find a record with the name $STR"
}

##
# get_record
##
get_record()
{
clear
echo -n "Enter the employee surname to view or all for all records: "
read STR
if [ "$STR" = "q" ]; then
   return 1
fi
if [ "$STR" = "all" ]; then        # view all records
   echo "Surname    Name    Employee Code"
   echo "-------    -----   -------------"
   cat $DBFILE | awk -F:'{print $2"\t"$3"\t\t"$1}' | more
   return
fi
REC=0
MATCH=no
if [ "$STR" != "" ]; then
   while read CODE F_NAME S_NAME DEPART
   do
      REC=$(expr $REC + 1)
      tput cup 3 4
      echo -n "searching record ..$REC"
      if [ "$S_NAME" = "$STR" ]; then
         MATCH=yes   # found name
         display_record
         break
      else
         continue
      fi
    done < $DBFILE
else
   echo "Enter a surname to search for or q to quit"
fi
if [ "$MATCH" = "no" ]; then
  no_record
fi
}

##
# Main
##
SAVEDIFS=$IFS
IFS=:
get_record
if [ "$MATCH" = "yes" ]; then
   if continue_prompt "Do you wish to print this record?" "N"; then
      	lpr <<-!
      	RECORD No : $REC
	
	EMPLOYEE NUMBER  	: $CODE
	EMPLOYEE NAME    	: $F_NAME
	EMPLOYEE SURNAME 	: $S_NAME
	EMPLOYEE DEPARTMENT	: $DEPART
	!
    else
      "$S_NAME is not print"
    fi
fi
IFS=$SAVEDIFS
-----------------------------------------
********************
* CancellRebill.sh *
********************
#!/bin/sh
################################################################################
#
# MODULE:  CancelRebill.sh
#
# DATE:    07 Decemeber 1999
#
# PROJECT: Customer/1 (UK)
#
# INVOCATION:
#
#  CancelRebill [-t <number of days>]
#
# COMMAND LINE PARAMETERS:
#
#  -t <number of days>    -    Specifies number of days prior to the current
#                              database system date, which defines the range
#                              of dates to consider for selection
#
# DESCRIPTION:
#  This script was developed in response to Service Centre Request 34024
#  A requirement of this request was the production of a script to identify
#  all of those accounts whose balance has been affected by a Cancel Bill
#  and subsequent re-bill, triggered by the receipt of an actual reading
#  soon after the generation of an estimate bill
#
################################################################################

################################################################################
# SOME CONSTANTS
################################################################################

typeset -r ERROR_SUCCESS=0
typeset -r ERROR_FAILURE=1

typeset -r TRUE=0
typeset -r FALSE=1

typeset -r BASEDIR=/home/tx92b01/OSE_SCRIPTS
typeset -r OUTPUT_DIR=$BASEDIR/output
typeset -r OUTPUT_FILE=CancelBill`date +"%Y_%m_%d"`.txt

typeset -r TEMP_ROOT=${BASEDIR}/`basename $(mktemp)`
typeset -r TEMP_FILE1=${TEMP_ROOT}.1
typeset -r TEMP_FILE2=${TEMP_ROOT}.2
typeset -r SPOOL_FILE=${TEMP_ROOT}.lst

typeset -r TOP_STATUS_LINE=0
typeset -r SCRIPT_STATUS_LINE=$((TOP_STATUS_LINE+0))
typeset -r DATE_STATUS_LINE=$((TOP_STATUS_LINE+1))
typeset -r DAYS_STATUS_LINE=$((TOP_STATUS_LINE+2))
typeset -r DB_STATUS_LINE=$((TOP_STATUS_LINE+3))
typeset -r OUTPUT_FILE_STATUS_LINE=$((TOP_STATUS_LINE+4))
typeset -r STATUS_STATUS_LINE=$((TOP_STATUS_LINE+5))

typeset -r TITLE_STATUS_COL=0
typeset -r DATA_STATUS_COL=20

################################################################################
# SOME VARIABLES
################################################################################

typeset TIME_PERIOD=$((30.5*3))

################################################################################
# SOME FUNCTIONS
################################################################################

################################################################################
#
# FUNCTION: fn_tidy()
#
# INPUT PARAMETERS: None
#
# GLOBAL VARIABLES: None
#
# RETURN VALUE:     ERROR_SUCCESS, ERROR_FAILURE
#
# DESCRIPTION:
#  Performs some tidying up
#
################################################################################

fn_tidy()
{
    typeset localret=${ERROR_SUCCESS}

    if [ -f ${TEMP_ROOT}* ] ; then
        rm ${TEMP_ROOT}*
    fi

    return ${localret}
} # fn_tidy

################################################################################
#
# FUNCTION: fn_log()
#
# INPUT PARAMETERS: None
#
# GLOBAL VARIABLES: None
#
# RETURN VALUE:     ERROR_SUCCESS, ERROR_FAILURE
#
# DESCRIPTION:
#
################################################################################

fn_log()
{
    typeset localret=${ERROR_SUCCESS}

    return ${localret}

} # End of fn_log()


################################################################################
#
# FUNCTION: fn_log()
#
# INPUT PARAMETERS: None
#
# GLOBAL VARIABLES: None
#
# RETURN VALUE:     ERROR_SUCCESS, ERROR_FAILURE
#
# DESCRIPTION:
#
################################################################################

fn_displayStatus()
{
    typeset localret=${ERROR_SUCCESS}

    if [ $# -ne 2 ] ; then
	local_return=${ERROR_FAILURE}
    else
        typeset type="$1"
        typeset data="$2"

	if [ $type = SCRIPT ] ; then
	    tput cup ${SCRIPT_STATUS_LINE} ${TITLE_STATUS_COL}
	    printf "Script:"
	    tput cup ${SCRIPT_STATUS_LINE} ${DATA_STATUS_COL}
	    printf $data
	    tput el
        elif [ $type = DATE ] ; then
	    tput cup ${DATE_STATUS_LINE} ${TITLE_STATUS_COL}
	    printf "Date:"
	    tput cup ${DATE_STATUS_LINE} ${DATA_STATUS_COL}
	    printf $data
	    tput el
        elif [ $type = DAYS ] ; then
	    tput cup ${DAYS_STATUS_LINE} ${TITLE_STATUS_COL}
	    printf "Days in period:"
	    tput cup ${DAYS_STATUS_LINE} ${DATA_STATUS_COL}
	    printf $data
	    tput el
        elif [ $type = DB ] ; then
	    tput cup ${DB_STATUS_LINE} ${TITLE_STATUS_COL}
	    printf "Database:"
	    tput cup ${DB_STATUS_LINE} ${DATA_STATUS_COL}
	    printf $data
	    tput el
        elif [ $type = STATUS ] ; then
	    tput cup ${STATUS_STATUS_LINE} ${TITLE_STATUS_COL}
	    printf "Status:"
	    tput cup ${STATUS_STATUS_LINE} ${DATA_STATUS_COL}
	    tput el
	    printf "$data"
        elif [ $type = OUTPUT_FILE ] ; then
	    tput cup ${OUTPUT_FILE_STATUS_LINE} ${TITLE_STATUS_COL}
	    printf "Output File:"
	    tput cup ${OUTPUT_FILE_STATUS_LINE} ${DATA_STATUS_COL}
	    tput el
	    printf "$data"
        else
	    clear
        fi
	    
    fi

    return ${localret}

} # End of fn_log()

################################################################################
#
# FUNCTION: fn_checkEnv()
#
# INPUT PARAMETERS: None
#
# GLOBAL VARIABLES: None
#
# RETURN VALUE:     ERROR_SUCCESS, ERROR_FAILURE
#
# DESCRIPTION:
#  This function checks that ORACLE_USER, ORACLE_PASSWORD and ORACLE_ARC_CONNECT
#  are set. If this is not the case, a message is displayed, and ERROR_FAILURE
#  is returned
#
################################################################################

fn_checkEnv()
{
    typeset localret=${ERROR_SUCCESS}
    typeset bUserSet=${FALSE}
    typeset bPasswordSet=${FALSE}
    typeset bConnectSet=${FALSE}
    typeset iNotSetCount=0
    typeset szNotSet=""
    typeset szPl=" "
    typeset szPl1="s "
    if [ -z "${ORACLE_USER}" ] ; then
        bUserSet=${FALSE}
        iNotSetCount=$((iNotSetCount+1))
        localret=${ERROR_FAILURE}
    else
        bUserSet=${TRUE}
    fi
    if [ -z "${ORACLE_PASSWORD}" ] ; then
        bPasswordSet=${FALSE}
        iNotSetCount=$((iNotSetCount+1))
        localret=${ERROR_FAILURE}
    else
        bPasswordSet=${TRUE}
    fi
    if [ -z "${ORACLE_ARC_CONNECT}" ] ; then
        bConnectSet=${FALSE}
        iNotSetCount=$((iNotSetCount+1))
        localret=${ERROR_FAILURE}
    else
        bConnectSet=${TRUE}
    fi

    if [ ${localret} -eq ${ERROR_FAILURE} ] ; then
        if [ ${iNotSetCount} -ne 1 ] ; then
            szPl="s "
            szPl1=" "
        fi
        szReport="The following environment variable"${szPl}"need"${szPl1}"to be set:"
        if [ ${bUserSet} -eq ${FALSE} ] ; then
            szNotSet=" ORACLE_USER"
        fi
        if [ ${bPasswordSet} -eq ${FALSE} ] ; then
            szNotSet=${szNotSet}" ORACLE_PASSWORD"
        fi
        if [ ${bConnectSet} -eq ${FALSE} ] ; then
            szNotSet=${szNotSet}" ORACLE_ARC_CONNECT"
        fi
        echo $szReport
        echo $szNotSet
    fi

    return ${localret}

} # End of fn_checkEnv()

################################################################################
# THE MAIN BIT
################################################################################

trap "fn_displayStatus STATUS 'Interrupted\n' ; fn_tidy; exit" 2 9
fn_checkEnv
if [ $? -ne ${ERROR_SUCCESS} ] ; then
    printf "Environment not set appropriately\n"
else

while getopts ":s:t:" OPT_FLAG
do
   case $OPT_FLAG in
    "t") TIME_PERIOD=$OPTARG ;;
    "*") ;;
   esac
done

fn_displayStatus "dummy" "clear"
fn_displayStatus SCRIPT `basename $0`
fn_displayStatus DATE `date +"%d/%m/%Y`
fn_displayStatus DAYS ${TIME_PERIOD} 
fn_displayStatus DB ${ORACLE_ARC_CONNECT} 
fn_displayStatus OUTPUT_FILE "${OUTPUT_DIR}/${OUTPUT_FILE}" 
fn_displayStatus STATUS "Getting database partition information...."

PARTITIONS=`sqlplus -s ${ORACLE_USER}/${ORACLE_PASSWORD}@${ORACLE_ARC_CONNECT} << EOD
set heading off
set feedback off
set pages 0
select distinct database from t_tables;
EOD`

>${TEMP_FILE1}
for db in ${PARTITIONS}
do

>${SPOOL_FILE}
fn_displayStatus DB $db
fn_displayStatus STATUS "Selecting...."

sqlplus -s ${ORACLE_USER}/${ORACLE_PASSWORD}@${db} > /dev/null << EOD
set heading off
set feedback off
set pages 0
set colsep ,
spool ${SPOOL_FILE}
 select b.id_ba
 from   cu04tb12 a,
        cu05tb05 b,
        cu02tb01 c,
	cu02tb08 d
 where  a.id_prem = c.id_prem
 and    b.id_ba = c.id_ba
 and    d.id_ba = c.id_ba 
 and    a.cd_rdg_stat in ( 'C', 'R')
 and    a.dt_rdg_stat between (trunc(sysdate) - ${TIME_PERIOD}) and (trunc(sysdate) - 1)
 and    b.cd_pp_stat  = 'SE'
 and    b.dt_pp_stat_upd = to_date(substr(a.ts_bill_unit,1,10)||' 00.00.00', 'YYYY-MM-DD HH24.MI.SS')
 and    d.ts_acty like to_char(a.dt_rdg_stat, 'YYYY-MM-DD') || '%'
 and    d.cd_trans_id = 5600
;
exit
EOD

cat ${SPOOL_FILE} >> ${TEMP_FILE1}
done

fn_displayStatus STATUS "Stripping spaces from output"
sed -e 's/ //g' ${TEMP_FILE1} | sort -n | sort -u > ${TEMP_FILE2}
mv ${TEMP_FILE2} ${OUTPUT_DIR}/${OUTPUT_FILE}
fn_displayStatus STATUS "Complete\n"
fn_tidy

fi

################################################################################
# THE END
################################################################################

*************
* addscript *
*************
#!/usr/bin/ksh
#********************************************************************************
#       Module Id:      addscript
#       Module Type:    Unix Script
#       Version:        v1.0
#       Source Type:    UNIX Shell script
#********************************************************************************
#
#       Purpose:
#                       To add new scripts to the list to be processed by "automate"
#
#       Return Codes:
#                       Success         0
#                       Error           2
#                       Incorrect Usage 100
#
#
#
#********************************************************************************
#
#  Functions:
#
#
#
#********************************************************************************
#
#  File Modification History
#
#********************************************************************************
#
#  Date         Author                  Reason for change
#  ----         ------                  -----------------
# 22/06/00      Diep Le                 Initial Version
#                                      
#********************************************************************************

##
# Define Variables
##
BASEDIR=/home/tx92b01/OSE_SCRIPTS
BIN=$BASEDIR/bin
OSE_SCRIPTDIR=$BASEDIR/scripts
##
# Define Functions
##
header(){
tput clear
cat <<!
#################################################################################

                                  ADD SCRIPT


!
}


get_script(){
	LOOP=0
	while [ $LOOP -eq 0 ]
	do
		echo "Enter the Full pathname to the script that is to be added: \n\n >> \c"
		read SCRIPT
		#
		# Ensure that the script exists
		#
		if [ x"$SCRIPT" = "x" ]
		then
			SCRIPT="<CR>"
		fi
		if [ -s $SCRIPT ]
		then
			LOOP=1
		else
			echo "\nThe File \"$SCRIPT\" specified does not exist! \n"
		fi
	done
}
#
##
# Main Script
##

header

get_script
------------------------------------------------------------------------------------------------------------
************
* automate *
************

#!/usr/bin/ksh
#********************************************************************************
#       Module Id:      automate
#       Module Type:    Unix Script
#       Version:        v1.1
#       Source Type:    UNIX Shell script
#********************************************************************************
#
#       Purpose:
#                       To automate the running of Database intensive OSE reports
#			so that they execute after CORE batch processing has 
#			completed, and before the C/1 online service is available
#			therby minimising the impact on the online service.
#
#       Return Codes:
#                       Success         0
#                       Error           2
#                       Incorrect Usage 100
#
#
#
#********************************************************************************
#
#                       Copyright (C) British Gas Trading 2000
#
#********************************************************************************
#
#  Functions:
#
#		log
#		get_time
#		check_core_finished
#		check_script_windows
#
#
#********************************************************************************

##
# Define Variables
##
BASEDIR=/home/tx92b01/OSE_SCRIPTS
BIN=$BASEDIR/bin
OSE_SCRIPTDIR=$BASEDIR/scripts
DATE=$(date "+%Y%m%d")
NOZEROCHECK=/home/tx92b01/intface/support/capps/logs/NoZeros_$DATE
LOGFILE=$BASEDIR/logs/automate_log_$DATE
>> $LOGFILE

#Define ORACLE Environment

. /home/tx92b01/.cust1_batch.sh
. /home/tx92b01/intface/scripts/.mps_var
. /home/tx92b01/intface/scripts/.mps_redbox
ORACLE_CUST_USER=cusonline
ORACLE_CUST_PASSWORD=C0med1an
export ORACLE_CUST_USER ORACLE_CUST_PASSWORD
export TWO_TASK=$ORACLE_ARC_SERVER 
export CUSTBATCHBIN=$HOME/batch/bin
export CUSTBATCHINCLUDE=$HOME/batch/include
export ORACLE_HOME=/u01/home/dba/oracle/product/7.3.4
export ULOGDIR=$HOME/logging
# Additions to path
export PATH=$PATH:$ORACLE_HOME/bin

##
# Function Definitions
##
#*******************************************************************************
#
# FUNCTION:     log
#
# DESCRIPTION:
#               Writes a line to the log file, adding the date to the start
#               of the line
#
#*******************************************************************************
log ()
{
echo "$(date '+%y%m%d %H:%M') automate : "$* | tee -a $LOGFILE
}
#*******************************************************************************
#
# FUNCTION:     get_time
#
# DESCRIPTION:
#               Evaluates the current time and returns it in minutes from
#		the preceding midnight.
#
#*******************************************************************************
get_time(){
	CURR_TIME=$(date "+%H:%M")
	HRS=$(echo $CURR_TIME | awk -F: '{ print $1 }')
	MIN=$(echo $CURR_TIME | awk -F: '{ print $2 }')
	TOT_MIN=$(bc <<!
$MIN + ( $HRS * 60 )
!)
echo $TOT_MIN
}

#*******************************************************************************
#
# FUNCTION:     check_core_finished
#
# DESCRIPTION:
#               Repeatedly checks the opsod log to ensure that CORE batch 
#		processing has completed before allowing execution of any SQL.
#
#*******************************************************************************
check_core_finished(){
WEEKDAY=$(date "+%a")
#
# If WEEKDAY is Monday then no batch will have been run, therefore just run
# scripts anyway.
#
if [ "$WEEKDAY" = "Mon" ]
then
	CHECK_CORE=1
	log "Monday - Core Batch not running"
else
#
# If NoZeros log file for today exists then core has completed
#
	CHECK_CORE=$(ls -l $NOZEROCHECK* | wc -l)
fi
}


#*******************************************************************************
#
# FUNCTION:     check_script_windows
#
# DESCRIPTION:
#               Checks each script in the steering file "execute.lst" in turn
#		to ensure that its execution window has not passed. It the 
#		time window is still valid the script is then executed.
#
#*******************************************************************************
check_script_windows(){
	for line in $(cat $BASEDIR/execute.lst)
	do
		SCRIPT=$(echo $line | awk -F\| '{ print $1 }')		# Script Name
		WINDOW_MINS=$(echo $line | awk -F\| '{ print $2 }')	# Window in Mins for Script to run
		ONLINE_START=$(echo $line | awk -F\| '{ print $3 }')	# Start time for Online service HH:MM
		HRS=$(echo $ONLINE_START | awk -F: '{ print $1 }')
		MIN=$(echo $ONLINE_START | awk -F: '{ print $2 }')
		START_ONLINE=$(bc <<!
		$MIN + ( $HRS * 60 )
!)
		CURRENT_TIME=$(get_time)
		CHECK_WINDOW=$(expr $CURRENT_TIME + $WINDOW_MINS)
		#
		# If the Current time Plus the Script Window Time crosses the Online service threshold
		# then do not run the script.
		#
		if [ $CHECK_WINDOW -gt $START_ONLINE ]
		then
			log "The time window for running \"$SCRIPT\" has been exceeded. Script not run"
		else
			log "Running Script ...\"$SCRIPT\""
			nohup $OSE_SCRIPTDIR/$SCRIPT &
		fi
	done
}

##
# Main Script
##

log "STARTED"

CHECK_CORE=0
while [ $CHECK_CORE -eq 0 ]
do
	#
	# Repeatedley check that core has finished
	# before attempting to run any sql
	#
	check_core_finished
	if [ $CHECK_CORE -eq 0 ]
	then
		#
		# Wait 5 minutes before checking again
		#
		log "CORE Not completed. Sleeping for 5 Minutes"
		sleep 300
	fi
done
#
# Now that Core has finished, For each script to be run determine whether or not its execution window 
# has been exceeded
#
check_script_windows
log "COMPLETED"
---------------------------------------------------------------------------------------------------------
***********
* killsql *
***********
for pid in $(ps -fu  $LOGNMAME | grep sqlplus | grep -v grep | awk '{ print $2 }')
do
	kill -9 $pid
done
----------------------------------------------------------------------------------------------------------
************
* Makepass *
************
#!/usr/bin/ksh 
BASEDIR=/capps/workarea/tony/newusers
STEERFILE=$BASEDIR/USERLIST
PASSWORD="9UZoM0GhR3V/Q,3.dM"
NEWGROUPS=$BASEDIR/NEWGROUPS
SYSTEM=$(uname -n | sed s/"pust"//g)
> PASSWD_92
> PASSWD_93
> PASSWD_96
> UPDATE_PASSWD_92
> UPDATE_PASSWD_93
> UPDATE_PASSWD_96
#
##
# Function definitions
##
#
make_new_user(){
	user=$1
	group=$2
	USERID="NNN"
	shift
	shift
	USERNAME=$*
	GID=$(grep "^$group:" $NEWGROUPS | awk -F: '{ print $2 }')
	echo $user":"$PASSWORD":"$USERID":"$GID":"$USERNAME":/home/"$user":/usr/bin/ksh"
}

modify_user(){
	echo "Modifying users entry"
	user=$1
	group=$2
	USERID=$3
	shift
	shift
	USERNAME=$*
	GID=$(grep "^$group:" $NEWGROUPS | awk -F: '{ print $2 }')
	echo $user":"$PASSWORD":"$USERID":"$GID":"$USERNAME":/home/"$user":/usr/bin/ksh"
}

##
# Main Script
##
cat $STEERFILE | while read line
do
	NAME=$(echo $line | awk -F, '{ print $1 }')
	USER=$(echo $line | awk -F, '{ print $2 }')
	GROUP=$(echo $line | awk -F, '{ print $3 }')
	UXACC=$(echo $line | awk -F, '{ print $4 }')
	DBACC=$(echo $line | awk -F, '{ print $5 }')
	MACHINES=$(echo $line | awk -F, '{ for(cnt=6;cnt<=NF;cnt++) { printf("%s ",$cnt)} printf("\n") }') 
	##
	# Get Existing Password Entry
	##
	OLDENTRY=$(grep "^$USER:" /etc/passwd)
	if [ x"$OLDENTRY" = "x" ]
	then
		echo "USER: "$USER" Does not have an account"
		for system in $MACHINES
		do
			make_new_user $USER $GROUP $NAME | tee -a PASSWD_$system
		done
	else
		UID=$(echo $OLDENTRY | awk -F: '{ print $3 }')
		modify_user $USER $GROUP $UID $NAME | tee -a UPDATE_PASSWD_$system
	fi
	##
	# Make Password Entry
	##

done


exit


hughest:9UZoM0GhR3V/Q,3.dM:730:107:Tony Hughes:/home/hughest:/usr/bin/ksh
--------------------------------------------------------------------------------------------------------------------
*************
* checkuser *
*************
#!/usr/bin/ksh
##
# Variable defintions
##
BASEDIR=/capps/workarea/tony/newusers
USERLIST=$BASEDIR/userlist
##
# format of userlist
##
#shadm am
#stevensp am
#garchab am
#wynns ace
#dieple business
#baten business

##
# newgroups
##
# ace:800
# aft:801
# am:802
# bst:803
# business:804
# config:805
# fi:806
# ocm:807
# ops:808
# ose24hr:809
# regtest:810

##
# Function Definitions
##
read_file(){
exec 3< $USERLIST
LOOP=0
while [ $LOOP -eq 0 ]
do
	read line <&3
	if [ x"$line" != "x" ]
	then
		user=$(echo $line | awk '{ print $1 }')
		group=$(echo $line | awk '{ print $2 }')
		##
		# Check That user exists in /etc/passwd
		##
		chk=$(grep "^$user:" /etc/passwd | wc -l)
		if [ $chk -eq 0 ]
		then
			echo $user $group | awk '{ printf("User: %-12s Group Required: %-10s USER NOT CREATED\n",$1,$2) }'
		else
			check_user $user $group
		fi
	else
		LOOP=1
	fi
done
}

check_user(){
USER=$1
GROUP=$2
echo $USER $GROUP | awk '{ printf("User: %-12s Group Required: %-10s Actual Group: ",$1,$2) }'
ACTGID=$(grep "^$user:" /etc/passwd | awk -F: '{ print $4 }')
ACTGROUP=$(grep ":$ACTGID:" /etc/group | awk -F: '{ print $1 }')
echo $ACTGROUP" \c"
if [ x"$ACTGROUP" = x"$GROUP" ]
then
	echo "ok"
else
	echo "NOT SET UP"
fi
}
#
##
# Main Script
##

#
# Check each user in Turn
#
read_file
--------------------------------------------------------------------------------------------------------------------
*************
* findalias *
*************
#!/usr/bin/ksh
#
#
# Shell script to read trees of directories
#
#
##
# Variable definitions
##
bold=$(tput smso)
reset=$(tput rmso)

##
#Function definitions
##

display_directory(){
	DIR=$1
	NEST=$2
	cd $DIR
	#
	# Display Direcory name
	#
	echo $bold$DIR$reset
	#
	# Display files 
	#
	for file in $(ls -al | awk '{ if(NR>3) print $0 }' | grep -v "^d" | awk '{ print $NF }' )
	do
		chk=$(grep alias $file | wc -l 2> /dev/null)
		if [ $chk -ne 0 ]
		then
			echo $file" : \n"
			grep alias $file 2> /dev/null
			echo
		fi
	done
	#
	#
	# Display Sub Directories
	#
	for SUB in $(ls -al  | awk '{ if(NR>3) print $0 }' | grep "^d" | awk '{ print $NF }' )
	do
		#
		# Execute recursive call to display_directory in
		# a sub-shell to preserve variables
		#
		if [ "$SUB" != "." ] && [ "$SUB" != ".." ]
		then
			(display_directory $DIR/$SUB $(expr $NEST + 1))
		fi
	done
}


##
# Main program
##
# Check to see if parameter has been passed
if [ $# -ne 1 ]
then
	TOP=$(pwd)
else
	TOP=$1
fi
#
# Change to "TOP" directory
#
cd $TOP
LEVEL=1
display_directory $TOP $LEVEL
--------------------------------------------------------------------------------------------------------------------
********
* Grep *
********
#
# Grep to get around : "/bin/grep: arg list too long" Error
#
PATTERN=$1
LIST=$2
#
# Extract any directory info
#
DIR=$(echo $LIST | awk -F\/ '{ if (NR==1 && NF > 1)
				{
				for(cnt=1;cnt<=NF;cnt++)
				{
					printf("%s/",$(cnt))
				}
				printf("\n")
				}
			}')
			if [ x"$DIR" = "x" ]
			then
				DIR=$(pwd)
			fi
LINES=$(ls -l $LIST | wc -l)
#
# Create temporary directory to allow directories listing to be produced
# for use in subsequent calculations (avoids grep overflow error)
#
OLDIR=$(pwd)
TMPDIR=/tmp/Grep$$
mkdir $TMPDIR  2> /dev/null
rm -f $TMPDIR/* 2> /dev/null
ls $LIST  > $TMPDIR/FILELIST$$
cd $TMPDIR
#
# Split the files into manageable blocks for "grep"
#
split -l 100 $TMPDIR/FILELIST$$
#
# Process the "grep" command
#
cd $DIR 2> /dev/null
for FILE in $(ls $TMPDIR/x*)
do
vi $FILE
	grep $PATTERN $(cat $FILE)
done
#
# Remove the temporary directory
#
cd $OLDIR
rm -rf $TMPDIR
------------------------------------------------------------------------------------------------------------------
************
* menuprog *
************
#!/bin/ksh
#
# Default to menu directory if environment variable not set
#
########################################################################
#
# menu.ksh
#
#
# Shell Script to generate menu system from flat files
#
# V 1.1
#
# Modification History
#
# 1.1	3/10/98		Date Created
#
########################################################################
#
############################
# Variable Definitions
############################
#
MLC=${MLC="/home/capps/workarea/tony/ops"}
MENUTREE=""
BOLD=$(tput smso)
RESET=$(tput rmso)
#
############################
# Function Definitions
############################
#
# Function to display menu
#
Displaymenu(){
MENU=$1
TREE=$TREE$MENU":"
tput clear
Title=$(head -1 $MLC/$MENU)
echo "(v1.1)		"$BOLD$Title$RESET"\n\n"
DisplayOptions
}
#
# Function to display menu options
#
DisplayOptions(){
#
# Initialise Arrays to hold meu information
#
set -A opt_type
set -A opt_text
set -A opt_comm
cnt=0
exec 3< $MLC/$MENU
numopts=$(wc -l < $MLC/$MENU)
numopts=$(expr $numopts - 1)
while [ $cnt -le $numopts ]
do
	read <&3 Menuline
	ix=$cnt
	cnt=$(expr $cnt + 1)
	if [ $cnt -gt 1 ]
	then
		set ${opt_type[$ix]=$(echo $Menuline | awk -F, '{ print $1 }')}
		set ${opt_text[$ix]=$(echo $Menuline | awk -F, '{ print $2 }')}
		set ${opt_comm[$ix]=$(echo $Menuline | awk -F, '{ print $3 }')}
		#
		# Display Menu Option
		#
		echo "	"$ix")	"${opt_text[$ix]}
	fi
done
echo "\n\n"
#
# Get Menu Option
#
fromto 1 $numopts
}
#
# Function to read menu selections
#
fromto(){
	MESG="	Enter Selection ($1 - $2) :"
	FROM=$1
	TO=$2
	ftloop=0
	while [ $ftloop -eq 0 ]
	do
		echo "$MESG \c"
		read FT
		if [ "$FT" = "" ]
		then
			FT=9999
		fi
		if [ "$FT" = "q" ] || [ "$FT" = "Q" ]
		then
			ftloop=1
			set -A opt_type
			set -A opt_comm
			FT=1
			lastmenu=$(echo $TREE | awk -F: '{ print $(NF-2) }')
			set ${opt_type[$FT]="m"}
			set ${opt_comm[$FT]=$lastmenu}
			Striptree
			if [ "$TREE" = "" ]
			then
				exit
			fi
			Striptree
		else
			if [ $FT -lt $FROM ] || [ $FT -gt $TO ]
			then
				echo "		INVALID INPUT ..."	
			else
				ftloop=1
			fi
		fi
	done
	#
	# Process Option
	#
	case $( echo ${opt_type[FT]} | tr "[a-z]" "[A-Z]") in
		"P") ${opt_comm[FT]}
		     lastmenu=$(echo $TREE | awk -F: '{ print $(NF-1) }')
		     Striptree
		     Displaymenu $lastmenu;;
		"M") Displaymenu ${opt_comm[FT]};;
	esac
}
#
# Function to strip off the last item in the TREE variable
#
Striptree(){
	TREE=$(echo $TREE | awk -F: '{ 	for(cnt=1;cnt<(NF-1);cnt++)
				       	{
						printf("%s:",$(cnt))
					}
					printf("\n")
}')
}

#
############################
# Main Program
############################
#
Displaymenu mlc 
-------------------------------------------------------------------------------------------------------------------
********
* tree *
********

#!/usr/bin/ksh
#
#
# Shell script to read trees of directories
#
#
##
# Variable definitions
##
bold=$(tput smso)
reset=$(tput rmso)

##
#Function definitions
##

display_directory(){
	DIR=$1
	NEST=$2
	cd $DIR
	CNT=1
	while [ $CNT -lt $NEST ]
	do
		echo "	\c"
		CNT=$(expr $CNT + 1)
	done
	#
	# Display Direcory name
	#
	echo $bold$DIR$reset
	#
	# Display files indented
	#
	cat <<-!> /tmp/lister$$
	ls -al | awk '{ if(NR>3) print \$0 }' | grep -v "^d" | awk '{ print \$NF }' | pr -8t | awk '{ for(cnt=1;cnt<$NEST;cnt++)
		{
			printf("	")
		}
		print \$0
		}'
	!
	ksh /tmp/lister$$
	rm -f /tmp/lister$$
	#
	#
	# Display Sub Directories
	#
	for SUB in $(ls -al  | awk '{ if(NR>3) print $0 }' | grep "^d" | awk '{ print $NF }' )
	do
		#
		# Execute recursive call to display_directory in
		# a sub-shell to preserve variables
		#
		(display_directory $DIR/$SUB $(expr $NEST + 1))
	done
}


##
# Main program
##

# Check to see if parameter has been passed
if [ $# -ne 1 ]
then
	TOP=$(pwd)
else
	TOP=$1
fi
#
# Change to "TOP" directory
#
cd $TOP
LEVEL=1
display_directory $TOP $LEVEL
---------------------------------------------------------------------------------------------------------------
***********
* gen_sql *
***********
OUT_FILE=/home/dieple/workarea/EPPS/diep.sql
IN_FILE=/home/dieple/workarea/EPPS/example.txt

###
###
grep "^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]" $IN_FILE | awk '{printf("select a.id_mtr_sys, b.id_ba from cu04tb81 a, cu02tb01 b where a.id_prem=b.id_prem and b.cd_ba_stat in (#A#, #T#)  and a.id_mtr_sys=#%s#;\n",$1)}'  | sed s/#/\'/g > $OUT_FILE

---------------------------------------------------------------------------------------------------------------
*********
* count *
*********
#*******************************************************************************
#
# FUNCTION:	jot
#
# DESCRIPTION:  Function to generate numerical lists
#
#*******************************************************************************
jot(){
start=$1
finish=$2
if [ $3 ]
then
	incr=$3
else
	incr=1
fi
if [ $start -lt $finish ]
then
	while [ $start -le $finish ]
	do
		echo $start" "
		start=`expr $start + $incr`
	done
else
	while [ $start -ge $finish ]
	do
		echo $start" "
		start=`expr $start - $incr`
	done
fi
echo
}
for mins in $(jot 1 30)
do
	for secs in $(jot 0 59)
	do
		sleep 1
		echo $mins":"$secs
	done
done
--------------------------------------------------------------------------------------------------------------
***************
* healthcheck *
***************
#!/usr/bin/ksh
#
# Simple script to test that the healtcheck processes are active on Pust92(AACI), 
# Pust56(ESRS), Pust41(EDTM), and Pust35(ESS)
#
# Set Variables
#
BASEDIR=/capps/sql_scripts
CONFIGFILE=$BASEDIR/health_config
#
# Process each entry - system
#
TODAY=$(date '+%d-%m-%y')
LOGFILE=healthck_log_$TODAY
cat $CONFIGFILE | while read line
do
	host=$(echo $line | awk -F, '{ print $1 }')
	system=$(echo $line | awk -F, '{ print $2 }')
	login=$(echo $line | awk -F, '{ print $3 }')
	password=$(echo $line | awk -F, '{ print $4 }')
	check=$(ftp -ni $host <<! | grep healthck_log | wc -l
        user "$login" "$password"
	cd healthchk/logs
	dir $LOGFILE
        pwd
        bye
!
)
if [ $check -gt 0 ]
then
	echo "Healthcheck for "$system" is running ..."
else
	echo "ERROR: Healthcheck for "$system"has not been started. Advise OSE24x7 Immediatley"
fi
done
-------------------------------------------------------------------------------------------------------------------------
*****************
* cp_skip_so125 *
*****************
#!/bin/ksh
#*******************************************************************************
#       Module Id:      CP_SKIP_SO125
#       Module Type:    Unix Script 
#       Version:        v1.1
#       Source Type:    UNIX Shell script
#*******************************************************************************#
#
#       Purpose:
#			To skip transactions for a failed premise in CUBSO125
#			on the database
#
#       Return Codes:
#              		Success 	0
#               	Error   	2
#			Incorrect Usage 100
#
#       Parameters to this script are as follows:
#
#			 -s<stream number>	Specifies the stream that
#						has abended
#
#
#*******************************************************************************
#
#  Functions:  
#		SearchForIdPrem
#		UpdateIDPREM
#		SearchForIdBA
#		UpdateIDBA
#		PrintUsage
#		Log
#		Stop
#
#
#*******************************************************************************

##
# Variables used
##

. $HOME/.cust1_batch.sh

SCRIPT_NAME=$0

DBUSER=$ORACLE_CUST_USER
DBPASSWD=$ORACLE_CUST_PASSWORD

DATABASE1=CR3PRA1
DATABASE2=CR3PRB1

ID_BA=""
ID_PREM=""
MSID=""
MSID_COUNT=""
ABEND_MSG=""
SQL_MSG=""
STREAM_NUM="--"
IDBA_PARTITION_TABLE="'CU02TB01'"
IDPREM_PARTITION_TABLE="'CU09TB39'"
JOB_NAME="CUBSO125"
LOG_DIR=$HOME/logging
CORE_BATCH_USER=`whoami`
SKIP_LOG=$LOG_DIR/skipso125.$(date "+%Y-%m-%d")
SKIP_FORMULA="to_char(add_months(to_date(supp_eff_date,'YYYY-MM-DD'),12000),'YYYY-MM-DD')"

##
# Get local application server
##
APP_SERVER=$(hostname)

#*******************************************************************************
#
# FUNCTION:	log
#
# DESCRIPTION:
#		Writes a line to the log file and to the screen, adding the 
#		date to the start of the line
#
#*******************************************************************************
log ()
{
echo "$JOBNAME - $(date +%Y-%m-%d-%H.%M.%S): "$1 >> $SKIP_LOG 
echo "$JOBNAME - $(date +%Y-%m-%d-%H.%M.%S): "$1
}

#*******************************************************************************
#
# FUNCTION:	Stop
#
# DESCRIPTION:
#
#*******************************************************************************
Stop ()
{
log "$SCRIPT_NAME completed With Errors on $APP_SERVER"
log ""

exit 2
}

#*******************************************************************************
#
# FUNCTION:	SearchForIdPrem
#
# DESCRIPTION:
#		This function searches an C/1 .msg file produced by the 
#		driver to find the id_ba number that has caused the abend.
#		The name of the logfile to search is built up from the job name
#		and stream number passed in on the command line.
#		The selected logfile is then searched for the string for a
#		valid ID_PREM and the following number extracted.
#		A final check is made that the extracted string is not empty
#		
#*******************************************************************************
SearchForIdPrem(){
##
# Build the name of the logfile to search in for the id_prem causing the abend.
##

echo "$STREAM_NUM" | sed ' s/^0// ' | read STREAM_STRING
#SEARCH_LOG_FILE="$(date "+%.1Y-%.1m-%.1d")_${JOB_NAME}_${CORE_BATCH_USER}_$STREAM_STRING.msg"
SEARCH_LOG_FILE=125LOG.TXT
log "Trying to find abend information in $SEARCH_LOG_FILE"

##
# Get the last id_prem from the logfile
##

if [[ -a $BATCHFILE_PATH/$SEARCH_LOG_FILE ]]
then 
	ID_PREM=$(tail -20 $BATCHFILE_PATH/$SEARCH_LOG_FILE  | grep "ID-PREM" | awk '{ print $NF }' | tail -1)
	##
	# If that fails search for PREM:
	##
	if [ x"$ID_PREM" = "x" ]
	then
		ID_PREM=$(tail -20 $BATCHFILE_PATH/$SEARCH_LOG_FILE | grep PREM | awk -F"PREM:" '{ print $2 }' | awk '{ print $1 }' | tail -1)
	fi
else
	
	log "Failed to read logfile $BATCHFILE_PATH/$SEARCH_LOG_FILE"
	Stop
fi
}
#*******************************************************************************
#
# FUNCTION:	SearchForIdBA
#
# DESCRIPTION:
#		This function searches an C/1 .msg file produced by the 
#		driver to find the id_ba number that has caused the abend.
#		The name of the logfile to search is built up from the job name
#		and stream number passed in on the command line.
#		The selected logfile is then searched for the string for a
#		valid ID_BA and the following number extracted.
#		A final check is made that the extracted string is not empty
#		
#*******************************************************************************
SearchForIdBA ()
{
##
# Build the name of the logfile to search in for the id_ba causing the abend.
##

echo "$STREAM_NUM" | sed ' s/^0// ' | read STREAM_STRING
#SEARCH_LOG_FILE="$(date "+%.1Y-%.1m-%.1d")_${JOB_NAME}_${CORE_BATCH_USER}_$STREAM_STRING.msg"
SEARCH_LOG_FILE=125LOG.TXT
log "Trying to find abend information in $SEARCH_LOG_FILE"

##
# Get the last id_ba from the logfile
##

if [[ -a $BATCHFILE_PATH/$SEARCH_LOG_FILE ]]
then 
	tail -40 $BATCHFILE_PATH/$SEARCH_LOG_FILE  | \
		tr -d "[\012]" | read WHOLE_LINE 
	echo $WHOLE_LINE | sed 's/ //g' | \
        sed 's/^.*[Ii][Dd]\-[Bb][Aa][ =:]*//' | \
		cut -c 1-10 | \
		grep '^[0-9]*$' | \
		read ID_BA
else
	
	log "Failed to read logfile $BATCHFILE_PATH/$SEARCH_LOG_FILE"
	Stop
fi

##
# Check that the string found is not empty
# further validation is performed later
##

if [[ ${#ID_BA} != 0 ]]
then
	log "ID_BA $ID_BA found"
else
	clear
 	echo " "
	log "Failed to find valid ID_BA in logfile $SEARCH_LOG_FILE"
 	echo " "
	while :
	do
	echo ""
	echo "From the logfile do you know the ID_BA? y/n"
	echo ""
	read ans
	case $ans in
       		 y|Y|yes|YES|Yes )  	clear
					echo "Please enter the ID_BA"
					echo ""
					read ID_BA
					clear
					echo ""
					break		;;
       		 n|N|no|NO|No ) 	echo "Exiting...."
					     exit 0        ;;                                
       		 * ) 			clear
					echo "Invalid response"  ;;                              
   esac
done

fi

##
# Attempt to find the reason that caused the abend 
##
grep -n "CIS ABEND MESSAGE" $BATCHFILE_PATH/$SEARCH_LOG_FILE | while read ABEND_MSG_LINE
do
	echo "$ABEND_MSG_LINE" | cut -c 4- | read ABEND_MSG 
done

if [[ $ABEND_MSG = "" ]]
then
	log "Failed to find CIS Abend msg from logfile $SEARCH_LOG_FILE"
else
	log "Abend msg -  $ABEND_MSG"	
fi
}

#*******************************************************************************
#
# END OF FUNCTION SearchForIdBA
#
#*******************************************************************************

#*******************************************************************************
#
# FUNCTION:     UpdateIDPREM
#
# DESCRIPTION:
#               This function is called once for each  ID_PREM to be updated
#               It first determines which instance of the database the ID_PREM
#               is held on.
#
#               The following script wide variables are used as input to this
#               function:
#                       ID_PREM           the ID_PREM to update
#
#*******************************************************************************

UpdateIDPREM ()
{

log "Finding out which database owns the ID_PREM $ID_PREM"

SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$DATABASE1 <<END_SQL_1
        set heading OFF;
        select DATABASE from T_PARTITIONS
        where TABLENAME   = $IDPREM_PARTITION_TABLE
          and LOW_VALUE  <= $ID_PREM
          and HIGH_VALUE >= $ID_PREM;
        exit SQL.SQLCODE;
END_SQL_1)

SQL_RESULT=$?
if (( $SQL_RESULT != 0 ))
then
        log "SQL*PLUS $SQL_RESULT occured while selecting from T_PARTITIONS"
        log "The SQL*PLUS return text is shown below"
        log "Phase 1 $SQL_RETURN_TEXT"
        Stop
else
        log "SQL*PLUS OK while selecting from T_PARTITIONS"
        log "The SQL*PLUS return text is shown below"
        log "Phase 1 $SQL_RETURN_TEXT"
fi

##
# Get the database name returned by sql
##
echo "$SQL_RETURN_TEXT" | awk ' !/^$/ {print $0} ' | read IDPREM_DATABASE
log "ID_PREM $ID_PREM found to be on Database Instance $IDPREM_DATABASE"
##
# Log the 'before update' picture
##
SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$DATABASE2 << END_SQL_5
        select * from cu09tb39
        where id_prem = $ID_PREM;
        exit SQL.SQLCODE;
END_SQL_5)

SQL_RESULT=$?

if (( $SQL_RESULT != 0 ))
then
        log "SQL*PLUS $SQL_RESULT occured while selecting from CU09TB39"
        log "The SQL*PLUS return text is shown below"
        log "Phase 5 $SQL_RETURN_TEXT"
        Stop
else
        log "SQL*PLUS OK while selecting from CU09TB39"
        log "The SQL*PLUS return text is shown below"
        log "Phase 5 $SQL_RETURN_TEXT"
fi


##
# Update rows
##
SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$DATABASE2 <<END_SQL_6
        set heading off;
        delete from cu09tb39 
        where id_prem = $ID_PREM;
        exit SQL.SQLCODE;
END_SQL_6)

SQL_RESULT=$?

if (( $SQL_RESULT != 0 ))
then
        log "SQL*PLUS $SQL_RESULT occured while deleting from CU09TB39"
        log "The SQL*PLUS return text is shown below"
        log "Phase 6 $SQL_RETURN_TEXT"
        Stop
else
        log "SQL*PLUS OK while deleting from  CU09TB39"
        log "The SQL*PLUS return text is shown below"
        log "Phase 6 $SQL_RETURN_TEXT"
fi

NumRows=$(expr `echo $SQL_RETURN_TEXT|cut -d' ' -f1`)
if [ $NumRows -eq 0 ]
then
        log "Phase 6 Cannot find ID_PREM $ID_PREM on $DATABASE2"
        Stop
fi


##
# Log the 'after update' picture
##
SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$DATABASE2 << END_SQL_7
        select *
         from CU09TB39
         where id_prem = $ID_PREM;
        exit SQL.SQLCODE;
END_SQL_7)

SQL_RESULT=$?

if (( $SQL_RESULT != 0 ))
then
        log "SQL*PLUS $SQL_RESULT occured while selecting from CU09TB39"
        log "The SQL*PLUS return text is shown below"
        log "Phase 7 $SQL_RETURN_TEXT"
        Stop
else
        log "SQL*PLUS OK while selecting from CU09TB39"
        log "The SQL*PLUS return text is shown below"
        log "Phase 7 $SQL_RETURN_TEXT"
fi


}
#*******************************************************************************
#
# FUNCTION:	UpdateIDBA
#
# DESCRIPTION:
#		This function is called once for each ID_BA to be updated
#		It first determines which instance of the database the ID_BA
#		is held on. 
#
#		The following script wide variables are used as input to this
#		function:
#			ID_BA		the ID_BA to update
#
#*******************************************************************************

UpdateIDBA ()
{

log "Finding out which database owns the ID_BA $ID_BA"

SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$DATABASE1 <<END_SQL_1
        set heading OFF;
        select DATABASE from T_PARTITIONS
        where TABLENAME   = $IDBA_PARTITION_TABLE
          and LOW_VALUE  <= $ID_BA 
          and HIGH_VALUE >= $ID_BA;
        exit SQL.SQLCODE;
END_SQL_1)

SQL_RESULT=$?
if (( $SQL_RESULT != 0 ))
then
        log "SQL*PLUS $SQL_RESULT occured while selecting from T_PARTITIONS"
        log "The SQL*PLUS return text is shown below"
        log "Phase 1 $SQL_RETURN_TEXT"
        Stop
else
        log "SQL*PLUS OK while selecting from T_PARTITIONS"
        log "The SQL*PLUS return text is shown below"
        log "Phase 1 $SQL_RETURN_TEXT"
fi

##
# Get the database name returned by sql
##
echo "$SQL_RETURN_TEXT" | awk ' !/^$/ {print $0} ' | read IDBA_DATABASE
log "ID_BA $ID_BA found to be on Database Instance $IDBA_DATABASE"


##
# Determine Premise
##
SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$IDBA_DATABASE << END_SQL_2
        set heading off;
        select id_prem
          from CU02TB01
         where id_ba = $ID_BA;
        exit SQL.SQLCODE;
END_SQL_2)

SQL_RESULT=$?

if (( $SQL_RESULT != 0 ))
then
        log "SQL*PLUS $SQL_RESULT occured while selecting from CU02TB01"
        log "The SQL*PLUS return text is shown below"
        log "Phase 2 $SQL_RETURN_TEXT"
        Stop
else
        log "SQL*PLUS OK while selecting from CU02TB01"
        log "The SQL*PLUS return text is shown below"
        log "Phase 2 ID_PREM = $SQL_RETURN_TEXT"
fi

echo "$SQL_RETURN_TEXT" | grep "no rows selected"
if [[ $? = 0 ]]
then
        log "Phase 2 Cannot find ID_BA $ID_BA on $IDBA_DATABASE"
        Stop
fi

echo "$SQL_RETURN_TEXT" | awk ' !/^$/ {print $0} ' | read ID_PREM
if [[ -z ${ID_PREM} ]]
then
        log "Phase 2 Cannot find ID_BA $ID_BA on $IDBA_DATABASE"
        Stop
fi


##
# Determine MSID Using ID_PREM
##
SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$IDBA_DATABASE << END_SQL_3
        set heading off;
        select id_mtr_sys
          from CU09TB04
         where id_prem = $ID_PREM;
        exit SQL.SQLCODE;
END_SQL_3)

SQL_RESULT=$?

if (( $SQL_RESULT != 0 ))
then
        log "SQL*PLUS $SQL_RESULT occured while selecting from CU09TB04"
        log "The SQL*PLUS return text is shown below"
        log "Phase 3 $SQL_RETURN_TEXT"
        Stop
else
        log "SQL*PLUS OK while selecting from CU09TB04"
        log "The SQL*PLUS return text is shown below"
        log "Phase 3 ID_MTR_SYS = $SQL_RETURN_TEXT"
fi

echo "$SQL_RETURN_TEXT" | grep "no rows selected"
if [[ $? = 0 ]]
then
        log "Phase 3 Cannot find ID_PREM $ID_PREM on $IDBA_DATABASE"
        Stop
fi

echo "$SQL_RETURN_TEXT" | awk ' !/^$/ {print $0} ' | read MSID
if [[ -z ${MSID} ]]
then
        log "Phase 3 Cannot find ID_PREM $ID_PREM on $IDBA_DATABASE"
        Stop
fi


##
# Determine if valid Fix on Fail
##
SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$DATABASE2 << END_SQL_4
        set heading off;
        select sum(decode(id_prem,0,2,3))
          from IN07TB01
         where msid = $MSID;
        exit SQL.SQLCODE;
END_SQL_4)

SQL_RESULT=$?

if (( $SQL_RESULT != 0 ))
then
        log "SQL*PLUS $SQL_RESULT occured while selecting from IN07TB01"
        log "The SQL*PLUS return text is shown below"
        log "Phase 4 $SQL_RETURN_TEXT"
        Stop
else
        log "SQL*PLUS OK while selecting from IN07TB01"
        log "The SQL*PLUS return text is shown below"
        log "Phase 4 $SQL_RETURN_TEXT"
fi

echo "$SQL_RETURN_TEXT" | awk ' !/^$/ {print $0} ' | read MSID_COUNT
if [[ ${MSID_COUNT} -ne 5 ]]
then
        log "WARNING - This Skip script is inappropriate for this failure"
        Stop
fi

##
# Log the 'before update' picture
##
SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$DATABASE2 << END_SQL_5
        select msid, id_prem, supp_eff_date 
          from IN07TB01 
         where msid = $MSID;
        exit SQL.SQLCODE;
END_SQL_5)

SQL_RESULT=$?

if (( $SQL_RESULT != 0 ))
then
        log "SQL*PLUS $SQL_RESULT occured while selecting from IN07TB01"
        log "The SQL*PLUS return text is shown below"
        log "Phase 5 $SQL_RETURN_TEXT"
        Stop
else
        log "SQL*PLUS OK while selecting from IN07TB01"
        log "The SQL*PLUS return text is shown below"
        log "Phase 5 $SQL_RETURN_TEXT"
fi


##
# Update rows
##
SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$DATABASE2 <<END_SQL_6
        set heading off;
        update IN07TB01 
           set supp_eff_date = $SKIP_FORMULA
        where msid = $MSID
          and id_prem = 0;
        exit SQL.SQLCODE;
END_SQL_6)

SQL_RESULT=$?

if (( $SQL_RESULT != 0 ))
then
	log "SQL*PLUS $SQL_RESULT occured while updating IN07TB01"
        log "The SQL*PLUS return text is shown below"
        log "Phase 6 $SQL_RETURN_TEXT"
        Stop
else
	log "SQL*PLUS OK while updating IN07TB01"
        log "The SQL*PLUS return text is shown below"
        log "Phase 6 $SQL_RETURN_TEXT"
fi

NumRows=$(expr `echo $SQL_RETURN_TEXT|cut -d' ' -f1`)
if [ $NumRows -eq 0 ]
then
        log "Phase 6 Cannot find MSID $MSID on $DATABASE2"
        Stop
fi


##
# Log the 'after update' picture
##
SQL_RETURN_TEXT=$(sqlplus -s $DBUSER/$DBPASSWD@$DATABASE2 << END_SQL_7
        select msid, id_prem, supp_eff_date 
          from IN07TB01 
         where msid = $MSID;
        exit SQL.SQLCODE;
END_SQL_7)

SQL_RESULT=$?

if (( $SQL_RESULT != 0 ))
then
        log "SQL*PLUS $SQL_RESULT occured while selecting from IN07TB01"
        log "The SQL*PLUS return text is shown below"
        log "Phase 7 $SQL_RETURN_TEXT"
        Stop
else
        log "SQL*PLUS OK while selecting from IN07TB01"
        log "The SQL*PLUS return text is shown below"
        log "Phase 7 $SQL_RETURN_TEXT"
fi


}
#*******************************************************************************
#
# END OF FUNCTION:	UpdateIDBA
#
#******************************************************************************* 
#*******************************************************************************
#
# FUNCTION:	PrintUsage
#
# DESCRIPTION:
#		Print the correct command line to call the script
#
#*******************************************************************************

PrintUsage ()
{
echo "Usage: $SCRIPT_NAME -s<stream number>"
exit 100
}
#*******************************************************************************
#
# END OF FUNCTION PrintUsage
#
#*******************************************************************************

#*******************************************************************************
#
# Main Function
#
#*******************************************************************************

##
# Validate options and input parameters
##

if [[ $# != 1 ]]
then
	PrintUsage
fi

while getopts ":s:" options
do
        case $options in

 		s)	STREAM_NUM=$OPTARG;;

 		\?)	PrintUsage;; 

                *)   ;;
        esac
done


if [[ $SEARCH_LOG = "TRUE" ]] && [[ $STREAM_NUM  = "--" ]]
then
	echo "The stream number must be supplied"
	PrintUsage
fi

##
# First of all determine if the id_prem is available in the logfile
##
	SearchForIdPrem

	if [ x"$ID_PREM" != "x" ]
	then
	##
	# Remove the offending row from the driving cursor
	##
		UpdateIDPREM
	else
	##
	# Get the id_ba to process from the msg file for the abended stream
	##
		SearchForIdBA

	##
	# Update the IN07TB01 to remove the offending row from the driving cursor
	##
        	UpdateIDBA
	fi

##
# Log program end
##

log "$JOBNAME completed OK on $APP_SERVER"

exit 0
#*******************************************************************************
#
# END OF SCRIPT: CP_SKIP_SO125
#
#*******************************************************************************
-----------------------------------------------------------------------------------------------------------------------
**********
* geftp *
**********
#!/bin/ksh
####################################################################
#
#	geftp.ksh	(puftp.ksh)
#
#	v 1.0	4/12/1998
#
#	Shell script to perform menu driven ftp between TCP/IP hosts
#
#
####################################################################
#
##############
# Variables
##############
#
bold=$(tput smso)
reset=$(tput rmso)
ME=/home/capps/workarea/tony/$(basename $0)
ITEMS=${ITEMS=15}
TYPE=${TYPE="binary"}
#
# Determine the invocation mode of the script
# either "put" or "get"
#
if [ "$(basename $0)" = "geftp" ]
then
	MODE="GET"
	REMDIR=$1
else
	MODE="PUT"
	if [ $# -gt 1 ]
	then
		OPDIR=$1
	else
		OPDIR=${OPDIR=/home/capps/workarea/tony/download}
	fi
fi
OPDIR=${OPDIR=/home/capps/workarea/tony/download}
#
################
# Functions
################
#
#####################################################
# Function to ensure "echo" works for BSD and Sys V
#####################################################
#
which_echo(){
NULL=/dev/null
if echo -n | grep 'n' > $NULL 2>&1
then
	N=''
	C='\c'
else
	N='-n '
	C=''
fi
}
######################
# function to  provide 
# numerical lists
######################
#
jot(){
start=$1
finish=$2
if [ $3 ]
then
	incr=$3
else
	incr=1
fi
if [ $start -lt $finish ]
then
	while [ $start -le $finish ]
	do
		echo $N$start" "$C
		start=`expr $start + $incr`
	done
else
	while [ $start -ge $finish ]
	do
		echo $N$start" "$C
		start=`expr $start - $incr`
	done
fi
echo
}
#
###################################
# Function to display menu header
###################################
#
header(){
	tput clear
	cat <<!
####################### FTP FILE TRANSFER MENU #######################

!
	echo "Remote: "$bold$HOST$reset" Directory: "$bold$REMDIR$reset" Transfer: "$bold$TYPE$reset
	echo "\nLocal: "$bold$OPDIR$reset" Mode: "$bold$MODE$reset
	echo
}

#
###########################
# Function to display menus
###########################
#
menu(){
	loop=0
	while [ $loop -eq 0 ]
	do
		#
		# Initialise Menu Array
		#
		set -A menuline
		set -A filetype
		linecnt=0
		menuitems=$(dirlist | wc -l)
		menuitems=$(expr $menuitems - 2)
		if [ $menuitems -le 15 ]
		then
			ITEMS=$menuitems
		fi
		for filename in $(dirlist | awk '{ if(NR>2){ print substr($1,1,1) $9 } }')
		do
			linecnt=$(expr $linecnt + 1)
			FT=$(echo $filename | awk '{ print substr($1,1,1)}')
			case $FT in
				"d")	set ${filetype[$linecnt]="DIR"};;
				"-")	set ${filetype[$linecnt]="FILE"};;
				"l")	set ${filetype[$linecnt]="LINK"};;
				*)	set ${filetype[$linecnt]="SPEC"};;
			esac
			set ${menuline[$linecnt]=$(echo $filename | awk '{ print substr($1,2,length($1)) }')}

			if [ $linecnt -eq $ITEMS ]
			then
				REDRAW=1
				while [ $REDRAW -eq 1 ]
				do
					header
					display_items $linecnt
				done
				if [ $REDRAW -eq 2 ]
				then
					break
				fi
				header
				linecnt=0
				set -A menuline
				set -A filetype
				if [ 1$menuitems -le 115 ]
				then
					ITEMS=$menuitems
				else
					menuitems=$(expr $menuitems - 15)
					if [ $menuitems -lt 15 ]
					then
						ITEMS=$menuitems
					else
						ITEMS=15
					fi
				fi
			fi
		done
		ITEMS=15
	done
}
#
#################################
# Function to display menu items
#################################
#
display_items(){
	max=$1
	for lcnt in $(jot 1 $max)
	do
		echo $lcnt")	"${menuline[$lcnt]}" ("${filetype[$lcnt]}")" | \
		awk '{ printf(" %-4s %-25s %8s\n",$1,$2,$3) }'
	done
	getsel $max
}

#
###############################
# Function to display remote
# working directory
###############################
#
getcwd(){
	if [ "$REMDIR" = "" ]
	then
		ftp -ni $HOST <<!
		user "$LOGINAME" "$PASSWORD"
		pwd
		bye
!
	else
		echo $REMDIR
	fi
}
#
#############################
# Function to list directory 
# contents either local or
# remote depending on $MODE
#############################
#
dirlist(){
	if [ "$MODE" = "GET" ]
	then
		ftp -ni $HOST <<!
		user "$LOGINAME" "$PASSWORD"
		cd $REMDIR
		dir
		bye
!
	else
		cd $OPDIR
		ls -al
	fi
}
#
############################
# Function to process
# selection
############################
#
getsel(){
	REDRAW=0
	max=$1
	echo
	echo $N"Enter Selection: (1-$max) "$C
	read sel
	if [ "$sel" = "" ]
	then
		sel="n"
	fi
	case "$sel" in
		"q")	exit;;
		"a")	TYPE="ascii"
			REDRAW=1;;
		"b")	TYPE="binary"
			REDRAW=1;;
		"n")	;;
		"p")	MODE="PUT"
			ME=/home/capps/workarea/tony/puftp
			REDRAW=2;;
		"g")	MODE="GET"
			ME=/home/capps/workarea/tony/geftp
			REDRAW=2;;
		"h")	help
			REDRAW=1;;
		*)	if [ x"${filetype[$sel]}" = "xDIR" ]
			then
				if [ "$MODE" = "GET" ]
				then
					if [ "${menuline[$sel]}" = ".." ]
					then
						NEWREMDIR=$(echo $REMDIR | awk -F\/ '{ \
						for(cnt=2;cnt<NF;cnt++)
						{
							printf("\/%s",$(cnt))
						}
						printf("\n")
						}')
					else
						NEWREMDIR=$REMDIR"/"${menuline[$sel]}
					fi
					export OPDIR
					#DEBUG
					echo ksh $ME $NEWREMDIR
					read xxx
					ksh $ME $NEWREMDIR
					REDRAW=1
				else
					if [ "${menuline[$sel]}" = ".." ]
					then
						NEWOPDIR=$(echo $OPDIR | awk -F\/ '{ \
						for(cnt=2;cnt<NF;cnt++)
						{
							printf("\/%s",$(cnt))
						}
						printf("\n")
						}')
					else
						NEWOPDIR=$OPDIR"/"${menuline[$sel]}
					fi
					export REMDIR
					#DEBUG
					echo ksh $ME $NEWOPDIR
					read xxx
					ksh $ME $NEWOPDIR
					REDRAW=1
				fi
			else
			#
			#  Get or Put  the file
			#
			if [ "$MODE" = "GET" ]
			then
				getfile ${menuline[$sel]}
			else
				putfile ${menuline[$sel]}
			fi
			REDRAW=1
		fi;;
	esac
}

#
#############################
# Function to "get" selected
# file.
#############################
#
getfile(){
	remotefile=$1
	ftp -ni $HOST <<!> /dev/null 2>&1
	user "$LOGINAME" "$PASSWORD"
	$TYPE
	cd $REMDIR
	lcd $OPDIR
	get $remotefile
	bye
!
}
#
#############################
# Function to "put" selected
# file.
#############################
#
putfile(){
	localfile=$1
	ftp -ni $HOST <<!> /dev/null 2>&1
	user "$LOGINAME" "$PASSWORD"
	$TYPE
	cd $REMDIR
	lcd $OPDIR
	get $localfile
	bye
!
}
#
############################
# Function to display help
############################
#
help(){
	tput clear
	cat <<! | more
#################### FTP MENU SYSTEM HELP SCREEN ######################

	Key			Function
	a			Switch to ASCII mode transfer
	b			Switch to BINARY mode transfer
	p			Switch to PUT mode. Send file from
				Local host, and directory indicated
				to Remote host.
	g			Switch to GET mode. Get files from
				Remote host, and directory indicated
				and transfer them to the local host.
	n			View next screen.
	<Enter>			View next screen.
	q			Quit.
	h			Display this screen.
	<1-15>			Select file or directory. If selection
				is a directory, then a listing for the
				new directory is displayed. If it is a 
				file, then the file is transferred
				depending on current mode (get or put).

!
}
#
###########################
# Function to set up FTP
# connection.
###########################
#
setup(){
	tput clear
	cat <<!
#################### SET UP FTP CONNECTION ######################

!
	echo $N"Enter Remote Host Name: "$C
	read HOST
	echo $N"Enter Login Name: "$C
	read LOGINAME
	echo $N"Enter Password: "$C
	stty -echo
	read PASSWORD
	stty echo
	echo
	export LOGINAME PASSWORD HOST
}
#
#######################
# Main Program
#######################
which_echo
REMIDR=$1
if [ x"$LOGINAME" = "x" ] || [ x"$HOST" = "x" ] || [ x"$PASSWORD" = "x" ] 
then
	setup
fi
if [ x"$REMDIR" = "x" ]
then
	REMDIR=$(getcwd | awk '{ print $2 }' | sed s/\"//g)
fi
menu
-------------------------------------------------------------------------------------------------------------------------
*********
* puftp *
*********
#!/bin/ksh
####################################################################
#
#	geftp.ksh	(puftp.ksh)
#
#	Shell script to perform menu driven ftp between TCP/IP hosts
#
####################################################################
#
##############
# Variables
##############
#
bold=$(tput smso)
reset=$(tput rmso)
ME=/home/capps/workarea/tony/$(basename $0)
ITEMS=${ITEMS=15}
TYPE=${TYPE="binary"}
#
# Determine the invocation mode of the script
# either "put" or "get"
#
if [ "$(basename $0)" = "geftp" ]
then
	MODE="GET"
	REMDIR=$1
else
	MODE="PUT"
	if [ $# -gt 1 ]
	then
		OPDIR=$1
	else
		OPDIR=${OPDIR=/home/capps/workarea/tony/download}
	fi
fi
OPDIR=${OPDIR=/home/capps/workarea/tony/download}
#
################
# Functions
################
#
#####################################################
# Function to ensure "echo" works for BSD and Sys V
#####################################################
#
which_echo(){
NULL=/dev/null
if echo -n | grep 'n' > $NULL 2>&1
then
	N=''
	C='\c'
else
	N='-n '
	C=''
fi
}
######################
# function to  provide 
# numerical lists
######################
#
jot(){
start=$1
finish=$2
if [ $3 ]
then
	incr=$3
else
	incr=1
fi
if [ $start -lt $finish ]
then
	while [ $start -le $finish ]
	do
		echo $N$start" "$C
		start=`expr $start + $incr`
	done
else
	while [ $start -ge $finish ]
	do
		echo $N$start" "$C
		start=`expr $start - $incr`
	done
fi
echo
}
#
###################################
# Function to display menu header
###################################
#
header(){
	tput clear
	cat <<!
####################### FTP FILE TRANSFER MENU #######################

!
	echo "Remote: "$bold$HOST$reset" Directory: "$bold$REMDIR$reset" Transfer: "$bold$TYPE$reset
	echo "\nLocal: "$bold$OPDIR$reset" Mode: "$bold$MODE$reset
	echo
}

#
###########################
# Function to display menus
###########################
#
menu(){
	loop=0
	while [ $loop -eq 0 ]
	do
		#
		# Initialise Menu Array
		#
		set -A menuline
		set -A filetype
		linecnt=0
		menuitems=$(dirlist | wc -l)
		menuitems=$(expr $menuitems - 2)
		if [ $menuitems -le 15 ]
		then
			ITEMS=$menuitems
		fi
		for filename in $(dirlist | awk '{ if(NR>2){ print substr($1,1,1) $9 } }')
		do
			linecnt=$(expr $linecnt + 1)
			FT=$(echo $filename | awk '{ print substr($1,1,1)}')
			case $FT in
				"d")	set ${filetype[$linecnt]="DIR"};;
				"-")	set ${filetype[$linecnt]="FILE"};;
				"l")	set ${filetype[$linecnt]="LINK"};;
				*)	set ${filetype[$linecnt]="SPEC"};;
			esac
			set ${menuline[$linecnt]=$(echo $filename | awk '{ print substr($1,2,length($1)) }')}

			if [ $linecnt -eq $ITEMS ]
			then
				REDRAW=1
				while [ $REDRAW -eq 1 ]
				do
					header
					display_items $linecnt
				done
				if [ $REDRAW -eq 2 ]
				then
					break
				fi
				header
				linecnt=0
				set -A menuline
				set -A filetype
				if [ 1$menuitems -le 115 ]
				then
					ITEMS=$menuitems
				else
					menuitems=$(expr $menuitems - 15)
					if [ $menuitems -lt 15 ]
					then
						ITEMS=$menuitems
					else
						ITEMS=15
					fi
				fi
			fi
		done
		ITEMS=15
	done
}
#
#################################
# Function to display menu items
#################################
#
display_items(){
	max=$1
	for lcnt in $(jot 1 $max)
	do
		echo $lcnt")	"${menuline[$lcnt]}" ("${filetype[$lcnt]}")" | \
		awk '{ printf(" %-4s %-25s %8s\n",$1,$2,$3) }'
	done
	getsel $max
}

#
###############################
# Function to display remote
# working directory
###############################
#
getcwd(){
	if [ "$REMDIR" = "" ]
	then
		ftp -ni $HOST <<!
		user "$LOGINAME" "$PASSWORD"
		pwd
		bye
!
	else
		echo $REMDIR
	fi
}
#
#############################
# Function to list directory 
# contents either local or
# remote depending on $MODE
#############################
#
dirlist(){
	if [ "$MODE" = "GET" ]
	then
		ftp -ni $HOST <<!
		user "$LOGINAME" "$PASSWORD"
		cd $REMDIR
		dir
		bye
!
	else
		cd $OPDIR
		ls -al
	fi
}
#
############################
# Function to process
# selection
############################
#
getsel(){
	REDRAW=0
	max=$1
	echo
	echo $N"Enter Selection: (1-$max) "$C
	read sel
	if [ "$sel" = "" ]
	then
		sel="n"
	fi
	case "$sel" in
		"q")	exit;;
		"a")	TYPE="ascii"
			REDRAW=1;;
		"b")	TYPE="binary"
			REDRAW=1;;
		"n")	;;
		"p")	MODE="PUT"
			ME=/home/capps/workarea/tony/puftp
			REDRAW=2;;
		"g")	MODE="GET"
			ME=/home/capps/workarea/tony/geftp
			REDRAW=2;;
		"h")	help
			REDRAW=1;;
		*)	if [ x"${filetype[$sel]}" = "xDIR" ]
			then
				if [ "$MODE" = "GET" ]
				then
					if [ "${menuline[$sel]}" = ".." ]
					then
						NEWREMDIR=$(echo $REMDIR | awk -F\/ '{ \
						for(cnt=2;cnt<NF;cnt++)
						{
							printf("\/%s",$(cnt))
						}
						printf("\n")
						}')
					else
						NEWREMDIR=$REMDIR"/"${menuline[$sel]}
					fi
					export OPDIR
					#DEBUG
					echo ksh $ME $NEWREMDIR
					read xxx
					ksh $ME $NEWREMDIR
					REDRAW=1
				else
					if [ "${menuline[$sel]}" = ".." ]
					then
						NEWOPDIR=$(echo $OPDIR | awk -F\/ '{ \
						for(cnt=2;cnt<NF;cnt++)
						{
							printf("\/%s",$(cnt))
						}
						printf("\n")
						}')
					else
						NEWOPDIR=$OPDIR"/"${menuline[$sel]}
					fi
					export REMDIR
					#DEBUG
					echo ksh $ME $NEWOPDIR
					read xxx
					ksh $ME $NEWOPDIR
					REDRAW=1
				fi
			else
			#
			#  Get or Put  the file
			#
			if [ "$MODE" = "GET" ]
			then
				getfile ${menuline[$sel]}
			else
				putfile ${menuline[$sel]}
			fi
			REDRAW=1
		fi;;
	esac
}

#
#############################
# Function to "get" selected
# file.
#############################
#
getfile(){
	remotefile=$1
	ftp -ni $HOST <<!> /dev/null 2>&1
	user "$LOGINAME" "$PASSWORD"
	$TYPE
	cd $REMDIR
	lcd $OPDIR
	get $remotefile
	bye
!
}
#
#############################
# Function to "put" selected
# file.
#############################
#
putfile(){
	localfile=$1
	ftp -ni $HOST <<!> /dev/null 2>&1
	user "$LOGINAME" "$PASSWORD"
	$TYPE
	cd $REMDIR
	lcd $OPDIR
	get $localfile
	bye
!
}
#
############################
# Function to display help
############################
#
help(){
	tput clear
	cat <<! | more
#################### FTP MENU SYSTEM HELP SCREEN ######################

	Key			Function
	a			Switch to ASCII mode transfer
	b			Switch to BINARY mode transfer
	p			Switch to PUT mode. Send file from
				Local host, and directory indicated
				to Remote host.
	g			Switch to GET mode. Get files from
				Remote host, and directory indicated
				and transfer them to the local host.
	n			View next screen.
	<Enter>			View next screen.
	q			Quit.
	h			Display this screen.
	<1-15>			Select file or directory. If selection
				is a directory, then a listing for the
				new directory is displayed. If it is a 
				file, then the file is transferred
				depending on current mode (get or put).

!
}
#
###########################
# Function to set up FTP
# connection.
###########################
#
setup(){
	tput clear
	cat <<!
#################### SET UP FTP CONNECTION ######################

!
	echo $N"Enter Remote Host Name: "$C
	read HOST
	echo $N"Enter Login Name: "$C
	read LOGINAME
	echo $N"Enter Password: "$C
	stty -echo
	read PASSWORD
	stty echo
	echo
	export LOGINAME PASSWORD HOST
}
#
#######################
# Main Program
#######################
which_echo
REMIDR=$1
if [ x"$LOGINAME" = "x" ] || [ x"$HOST" = "x" ] || [ x"$PASSWORD" = "x" ] 
then
	setup
fi
if [ x"$REMDIR" = "x" ]
then
	REMDIR=$(getcwd | awk '{ print $2 }' | sed s/\"//g)
fi
menu
----------------------------------------------------------------------------------------------------------------------
************
* getstuff *
************

cat /etc/group | while read line
do
	group=$(echo $line | awk -F: '{ print $1 }')
	groupid=$(echo $line | awk -F: '{ print $3 }')
	echo $group " id = "$groupid
	echo $group | awk '{ for(cnt=1;cnt<=length($1);cnt++)
				{
					printf("#")
				}
				printf("\n")
			}'

	echo "\nMember Users: \n"
	echo $line | awk -F: '{ print $NF }' | tr "," "\n" > LIST
	cat /etc/passwd | grep "[0-9]:"$groupid":" | awk -F: '{ print $1 }' >> LIST
	cat LIST | sort -u | pr -5t
	echo "\n		--------------------------    \n"
done
-----------------------------------------------------------------------------------------------------------------------
***********
* viewjob *
***********
#!/usr/bin/ksh
#*******************************************************************************
#       Module Id:      viewjob
#       Module Type:    Unix Script 
#       Version:        v1.0
#       Source Type:    UNIX Shell script
#*******************************************************************************#
#
#       Purpose:
#			
#			
#	Parameters:	P1	Jobname to investigate
#
#       Return Codes:
#              		Success 	0
#               	Error   	2
#			Incorrect Usage 100
#
#
#
#*******************************************************************************
#
#  Functions:  
#		header	
#
#
#*******************************************************************************

##
# Define Variables
##
LOGFILES=$(grep ":103:102:" /etc/passwd | awk -F\: '{ print $(NF-1)}')/logging
JOBNAME=$1
TODAY=$(date "+%b %d")
OPSODLOG=/opt/ultracomp/rboxuser/opsod/log_exec/opsod.log
BOLD=$(tput smso)
RESET=$(tput rmso)
HOST=$(uname -n)

##
# Function Definitions
##

usage(){
	if [ $1 -ne 1 ]
	then
		echo "usage: viewjob <JOBNAME>"
		exit
	fi 
}

header(){
tput clear
cat <<!
Checking Streams for : $JOBNAME on $HOST

Key: C=Completed	S=Started	A=Aborted 	J=Pending Start		R=Running


Streams:

!

cd $LOGFILES
STREAMS=$(ls -ltr | grep -i $JOBNAME | grep ".msg$" | grep "$TODAY" | awk -F\_ '{ print $NF }' | sed s/".msg"/""/g)
STREAMS=$(echo "$STREAMS" | sort -n | awk '{ printf("%s ",$1) }')
echo $STREAMS
STATUSLINE=""
ABORTED=""
for STREAM in $STREAMS
do
	#
	# Check OPSOD.LOG
	#
	STATUS=$(grep "$JOBNAME" $OPSODLOG | egrep "JOB|STARTED|COMPLETED|ABORTED" | egrep "_00$STREAM | _0$STREAM | _$STREAM" | tail -1 | awk '{ print $3 }')
	case "x$STATUS" in
		"xSTARTED")	echo "S \c"
				STATUSLINE=$STATUSLINE"S ";;
		"xCOMPLETED")	echo "C \c"
				STATUSLINE=$STATUSLINE"C ";;
		"xJOB")		echo "J \c"
				STATUSLINE=$STATUSLINE"J ";;
		"xABORTED")	echo $BOLD"A"$RESET" \c"
				ABORTED=$ABORTED"$STREAM "
				STATUSLINE=$STATUSLINE$BOLD"A"$RESET" ";;
		"x")		echo "R \c"
				STATUSLINE=$STATUSLINE"R ";;
	esac	
	if [ $STREAM -gt 9 ]
	then
		STATUSLINE=$STATUSLINE" "
		echo " \c"
	fi
done
if [ x"$ABORTED" = "x" ]
then
	ABORTED="NONE"
fi
echo
echo "\n\nABORTED STREAMS: "$ABORTED
echo
LOOP=1
while [ $LOOP -eq 1 ]
do
	echo "\nView which stream of $JOBNAME ? (Q to quit) : "$(echo $STREAMS | tr " " ",")
	echo ">> \c"
	read STREAM
	if [ x"$STREAM" = "x" ]
	then
		echo "INVALID SELECTION"
	else
		if [ "$STREAM" = "Q" ] || [ "$STREAM" = "q" ]
		then
			echo "Viewjob: completed"
			exit
		fi
		VALID=0
		for CHECK in $STREAMS
		do
			if [ "$CHECK" = "$STREAM" ]
			then
				VALID=1
			fi
		done	
		if [ $VALID -eq 0 ]
		then
			echo "INVALID SELECTION"
		else
			FILENAME=$(ls -ltr | grep -i $JOBNAME | egrep "_00$STREAM.msg|_0$STREAM.msg|_$STREAM.msg" | tail -1 | awk '{ print $NF }')
			echo "VIEWING STREAM: $STREAM FILENAME"$FILENAME
			view $LOGFILES/$FILENAME

		fi
	fi
	tput clear
	cat <<!
Checking Streams for : $JOBNAME on $HOST

Key: C=Completed	S=Started	A=Aborted 	J=Pending Start		R=Running


Streams:

!
	echo $STREAMS
	echo "$STATUSLINE"
	echo "\nABORTED STREAMS: "$ABORTED"\n"
done
}

##
# Main Program
##

##
# Check Usage
## 

usage $#

##
# Display header
##

header
-----------------------------------------------------------------------------------------------------------------------
*******
* ten *
*******
tenlong(){
var=$1
	CHKLEN=$(echo $var | wc -c)
	if [ $CHKLEN -ne 11 ]
	then
		for pad in $(jot $CHKLEN 10)
		do
			var="0"$var
		done
	fi
	echo "$var"
}
######################
# function to  provide 
# numerical lists
######################
#
jot(){
start=$1
finish=$2
if [ $3 ]
then
	incr=$3
else
	incr=1
fi
if [ $start -lt $finish ]
then
	while [ $start -le $finish ]
	do
		echo $N$start" "$C
		start=`expr $start + $incr`
	done
else
	while [ $start -ge $finish ]
	do
		echo $N$start" "$C
		start=`expr $start - $incr`
	done
fi
echo
}
tenlong 1111
tenlong 221
tenlong 71111
tenlong 101111
tenlong 1991
-----------------------------------------------------------------------------------------------------------------------
*************
* ampod.htm *
*************

<html>

<head>
<meta http-equiv="Content-Language" content="en-gb">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Ampod Status</title>
<meta name="Microsoft Theme" content="blends 011">
</head>

<body background="blegtext.gif" bgcolor="#CCCCCC" text="#000000" link="#993300" vlink="#0000FF" alink="#FF9900">

<!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">
<p align="center"><img border="0" src="am.jpg" width="520" height="47"></p>
<p align="center"><img border="0" src="ampodstats.jpg" width="550" height="82"></p>
<p align="center"><b>Thursday 05 October</b></p>
<p align="center">Last Updated: <b>17:01:00</b></p>
<p align="center">(This page updates every 15 mins - please refresh view
periodically)</p>
<!--mstheme--></font>
<table border="1" width="100%" bordercolorlight="#999999" bordercolordark="#000000">
  <tr>
    <td width="40%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">
      <p align="center"><b>Reports</b><!--mstheme--></font></td>
    <td width="8%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b>Status</b><!--mstheme--></font></td>
    <td width="43%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">
      <p align="center"><b>Tasks</b><!--mstheme--></font></td>
    <td width="9%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b>Status</b><!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="40%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Peer
      Group Data Report<!--mstheme--></font></td>
    <td width="8%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">COMPLETED</font></b><!--mstheme--></font></td>
    <td width="43%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Current
      Pre-Payment Suspense Code<!--mstheme--></font></td>
    <td width="9%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">4100000005</font></b><!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="40%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Glenda's
      Report (Tue)<!--mstheme--></font></td>
    <td width="8%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">NOT RUN TODAY</font></b><!--mstheme--></font></td>
    <td width="43%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Current
      Suspense Code<!--mstheme--></font></td>
    <td width="9%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">2500000005</font></b><!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="40%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Judy
      Hardicre's Refund Report (Wed/Fri)<!--mstheme--></font></td>
    <td width="8%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">NOT RUN TODAY</font></b><!--mstheme--></font></td>
    <td width="43%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">ADDACS
      Check<!--mstheme--></font></td>
    <td width="9%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">COMPLETED</font></b><!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="40%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Nick
      Bates Daily Report<!--mstheme--></font></td>
    <td width="8%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">COMPLETED</font></b><!--mstheme--></font></td>
    <td width="43%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Delete
      of CU04TB54 &amp; CU04TB82<!--mstheme--></font></td>
    <td width="9%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">COMPLETED</font></b><!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="40%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
    <td width="8%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
    <td width="43%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Check_ack.sql<!--mstheme--></font></td>
    <td width="9%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">PENDING</font></b><!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="40%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
    <td width="8%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
    <td width="43%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Batch
      Predictions AM<!--mstheme--></font></td>
    <td width="9%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">COMPLETED</font></b><!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="40%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
    <td width="8%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
    <td width="43%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Batch
      Predictions PM<!--mstheme--></font></td>
    <td width="9%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">COMPLETED</font></b><!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="40%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
    <td width="8%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">&nbsp;<!--mstheme--></font></td>
    <td width="43%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">Process
      Edtmarr interface files<!--mstheme--></font></td>
    <td width="9%"><!--mstheme--><font face="Trebuchet MS, Arial, Helvetica"><b><font size="1">PENDING</font></b><!--mstheme--></font></td>
  </tr>
</table>
<!--mstheme--><font face="Trebuchet MS, Arial, Helvetica">
<p align="center"><b><font size="1"><a href="file://ose-healthcheck/predictions/index.htm">Batch
Predictions Pages</a></font></b></p>
<!--mstheme--></font>

</body>

</html>
-------------------------------------------------------------------------------------------------------------------------
*****************
* generate_html *
*****************

gen_html(){
cnt=0
IPFILE=$1
TITLE="Friday"
cat $IPFILE | while read line
do
	cnt=$(expr $cnt + 1)
	case $cnt in
		2)	DATE_TIME=$(echo $line | awk '{ print $1" "$2 }');;
		3)	SUSCODE=$(echo $line | awk '{ print $NF }' | sed s/\)//g);;
		8)	DDUPLOADS=$(echo $line | awk '{ print $NF }');;
		9)	VDD=$(echo $line | awk '{ print $NF }' | sed s/#//g);;
		10)	MREADS=$(echo $line | awk '{ print $NF }');;
		11)	EBILLS=$(echo $line | awk '{ print $NF }');;
		12)	REFUNDS=$(echo $line | awk '{ print $NF }');;
		13)	WELCOME=$(echo $line | awk '{ print $NF }');;
		14)	DBTREC=$(echo $line | awk '{ print $NF }');;
		15)	ACTACC=$(echo $line | awk '{ print $NF }');;
		16)	METRE=$(echo $line | awk '{ print $NF }');;
		17)	WFMS=$(echo $line | awk '{ print $NF }');;
		18)	FORDERS=$(echo $line | awk '{ print $NF }');;
		19)	CPARTRDS=$(echo $line | awk '{ print $NF }');;
		20)	EMR=$(echo $line | awk '{ print $NF }');;
		21)	D10S=$(echo $line | awk '{ print $NF }');;
		22)	D149S=$(echo $line | awk '{ print $NF }');;
		23)	UMSIDS=$(echo $line | awk '{ print $NF }');;
		24)	D4S=$(echo $line | awk '{ print $NF }');;
		25)	CIS=$(echo $line | awk '{ print $NF }');;
		*)	echo > /dev/null;
	esac
done
DATE_STAMP=$(grep "This data is correct" $IPFILE)
cat <<!
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>$TITLE</title>
<meta name="Microsoft Theme" content="tmbuddha 011">
</head>

<body background bgcolor="#FFFFFF" text="#000000" link="#FF0000" vlink="#FFD700" alink="#808080">

<!--mstheme--><font face="Tahoma, Arial, Helvetica">
<div align="center">
  <center><!--mstheme--></font>
  <pre><font face="Arial"><b><u><font size="4">$DATE_TIME predictions for C/1 Batch</font></u></b><span style="font-size: 10.0pt"><o:p>
</o:p>
</span></font></pre>
  <!--mstheme--><font face="Tahoma, Arial, Helvetica"></center>
</div>
<div align="center">
  <center><!--mstheme--></font>
  <pre><span style="font-size: 10.0pt"><font face="Arial">are as follows: (Suspense Code = <b>$SUSCODE</b>)<o:p>
</o:p>
</font></span></pre>
  <!--mstheme--><font face="Tahoma, Arial, Helvetica"></center>
</div>
<!--mstheme--></font>
<table border="1" width="100%" bordercolorlight="#CCCCCC" bordercolordark="#666666">
  <tr>
    <td width="50%" valign="top"><!--mstheme--><font face="Tahoma, Arial, Helvetica">
      <div align="center">
        <center><!--mstheme--></font>
        <pre><span style="font-size: 10.0pt"><font face="Arial"><u><b>BATCH PREDICTED VOLUMES </b></u><o:p>
</o:p>
<o:p>
</o:p>
</font></span></pre>
        <!--mstheme--><font face="Tahoma, Arial, Helvetica"></center>
      </div>
      <!--mstheme--></font>
      <!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Direct Debit Uploads $DDUPLOADS<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Value of Direct Debits $VDD<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Meter Reads $MREADS<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Estimated bills $EBILLS<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Refunds $REFUNDS<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Welcome Letters $WELCOME<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Debt Recovery Letters $DBTREC<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Active Accounts $ACTACC<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Meter Reroutes $METRE<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">WFM's $WFMS<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Field Orders $FORDERS<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Counterpart Reads $CPARTRDS<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Exceptional Meter Reads $EMR<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Number of D10 Files $D10S<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Number of D149 Files $D149S<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Unmapped MSID's $UMSIDS<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Number of D4 Files $D4S<o:p>
</o:p>
</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
            <pre style="line-height: 100%"><span style="font-size: 10.0pt"><font face="Arial">Number of Cash items in suspense $CIS</font></span></pre>
            <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font><!--msthemelist--></td>
        </tr>
      <!--msthemelist--></table>
      <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font></td>
    <td width="50%" valign="top"><!--mstheme--><font face="Tahoma, Arial, Helvetica">
      <div align="center">
        <center><!--mstheme--></font>
        <pre><span style="font-size: 10.0pt"><font face="Arial"><u><b>METER READ FILE INFORMATION</b></u><o:p>
</o:p>
<o:p>
</o:p>
</font></span></pre>
        <!--mstheme--><font face="Tahoma, Arial, Helvetica"></center>
      </div>
!
#
# Dynamically Generate this bit
#
cat $1 | grep "Meter Reads from" | while read line
do
	part1=$(echo $line | awk '{ print $1" "$2" "$3" "$4 }')
	part2=$(echo $line | awk '{ print $5" "$6" "$7 }')
cat <<!
      <address>
        <span style="font-size: 10.0pt"><font face="Arial">$part1
        $part2<o:p>
        </o:p>
        </font></span>
      </address>
!
done
cat <<!
      <p>&nbsp;<!--mstheme--></font></td>
  </tr>
</table>
<!--mstheme--><font face="Tahoma, Arial, Helvetica">
<div align="center">
  <center><!--mstheme--></font>
  <pre><span style="font-size: 10.0pt"><font face="Arial"><b>This data is correct as at $DATE_STAMP</b>.<o:p>
</o:p>
</font></span></pre>
  <!--mstheme--><font face="Tahoma, Arial, Helvetica"></center>
</div>
<!--mstheme--></font>
<pre><span style="font-size: 10.0pt"><font face="Arial"><o:p>
</o:p>
</font></span></pre>
<!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
<p align="center"><font size="3"><a href="index.htm">Back to Main Screen</a></font></p>
</body>

</html>
!
}

gen_html $1
-------------------------------------------------------------------------------------------------------------------------
*************
* index.htm *
*************
<html>

<head>
<meta http-equiv="Content-Language" content="en-gb">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>AM</title>
<meta name="Microsoft Theme" content="tmbuddha 011">
</head>

<body background bgcolor="#FFFFFF" text="#000000" link="#FF0000" vlink="#FFD700" alink="#808080">

<!--mstheme--><font face="Tahoma, Arial, Helvetica">
<p align="center"><img border="0" src="predict.gif" width="545" height="68"></p>
<p align="center"><b>Week Commencing Tuesday 19 September</b></p>
<div align="center">
  <center><!--mstheme--></font>
<table border="1" width="74%" bordercolorlight="#CCCCCC" bordercolordark="#666666">
  <tr>
    <td width="49%"><!--msTheme--><font face="Tahoma, Arial, Helvetica"><b>AM</b><!--mstheme--></font></td>
    <td width="51%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><b>PM</b><!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="49%" valign="top"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
      <!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="monam.htm">Monday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="tueam.htm">Tuesday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="wedam.htm">Wednesday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="thuam.htm">Thursday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="friam.htm">Friday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="satam.htm">Saturday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
      <!--msthemelist--></table>
      <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font></td>
    <td width="51%" valign="top"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
      <!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="monpm.htm">Monday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="tuepm.htm">Tuesday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="wedpm.htm">Wednesday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="thupm.htm">Thursday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="fripm.htm">Friday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="satpm.htm">Saturday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
      <!--msthemelist--></table>
      <!--mstheme--><font face="Tahoma, Arial, Helvetica">
      <p>&nbsp;<!--mstheme--></font></td>
  </tr>
</table>
  <!--mstheme--><font face="Tahoma, Arial, Helvetica"></center>
</div>
<p align="center">
<marquee>Click on the links to view the statistics for the required day - AM or
PM</marquee>
</p>
<!--mstheme--></font>

</body>

</html>
--------------------------------------------------------------------------------------------------------------------------
*************
* index_gen *
*************
BASEDIR=/capps/sql_scripts/html_templates
HOST="10.16.7.4"
USERNAME="osecheck"
PASSWORD="osecheck"
export HOST USERNAME PASSWORD
DAY=$(date "+%a")
DATE=$(date "+%A %d %B")

##
# Functions
##


#*******************************************************************************
#
# FUNCTION:     sender
#
# DESCRIPTION:
#               Transfer Mondays blank html documents to batch predictions 
#		intranet directory.
#
#
#*******************************************************************************
sender(){
cd $BASEDIR
HOST="10.16.7.4"
ftp -ni $HOST <<! 2> /dev/null
user "$USERNAME" "$PASSWORD"
cd Am
cd predict
cd html
mput *.htm
bye
!
}


gen_index(){
cat <<!> $BASEDIR/index.htm
<html>

<head>
<meta http-equiv="Content-Language" content="en-gb">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Batch Predictions Main Menu</title>
<meta name="Microsoft Theme" content="tmbuddha 011">
</head>

<body background bgcolor="#FFFFFF" text="#000000" link="#FF0000" vlink="#FFD700" alink="#808080">

<!--mstheme--><font face="Tahoma, Arial, Helvetica">
<p align="center"><img border="0" src="ose.gif" width="452" height="50"></p>
<p align="center"><img border="0" src="predict.gif" width="545" height="68"></p>
<p align="center"><b>Week Commencing $DATE</b></p>
<div align="center">
  <center><!--mstheme--></font>
<table border="1" width="74%" bordercolorlight="#CCCCCC" bordercolordark="#666666">
  <tr>
    <td width="49%"><!--msTheme--><font face="Tahoma, Arial, Helvetica"><b>AM</b><!--mstheme--></font></td>
    <td width="51%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><b>PM</b><!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="49%" valign="top"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
      <!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="monam.htm">Monday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="tueam.htm">Tuesday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="wedam.htm">Wednesday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="thuam.htm">Thursday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="friam.htm">Friday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="satam.htm">Saturday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
      <!--msthemelist--></table>
      <!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font></td>
    <td width="51%" valign="top"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><!--mstheme--></font>
      <!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="monpm.htm">Monday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="tuepm.htm">Tuesday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="wedpm.htm">Wednesday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="thupm.htm">Thursday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="fripm.htm">Friday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
        <!--msthemelist--><tr>
          <!--msthemelist--><td valign="baseline" width="42"><img src="buddhabul1.gif" width="16" height="16" hspace="13"></td>
          <td valign="top" width="100%"><!--mstheme--><font face="Tahoma, Arial, Helvetica"><a href="satpm.htm">Saturday
            </a><!--mstheme--></font><!--msthemelist--></td>
        </tr>
      <!--msthemelist--></table>
      <!--mstheme--><font face="Tahoma, Arial, Helvetica">
      <p>&nbsp;<!--mstheme--></font></td>
  </tr>
</table>
  <!--mstheme--><font face="Tahoma, Arial, Helvetica"></center>
</div>
<p align="center">
<marquee>Click on the links to view the statistics for the required day - AM or
PM</marquee>
</p>
<!--mstheme--></font>

</body>

</html>
!
}

gen_index

sender
--------------------------------------------------------------------------------------------------------------------------
***************
* console_lib *
***************
#!/bin/ksh
#set -x
LINES=126

lock ()
{
	/usr/bin/echo "The following objects are locked on ${ORACLE_SID} ...\n"
	DB_run_query_pipe <<!
	set pages 200
	set feedback off
	column sid     format 999 Heading "Sid"
	column command format a8 heading "Command"
column object_name format a25 heading "Table"
column username format a10 heading "User"
select o.object_name ,s.username,l.sid,l.type,l.ctime,l.block,
decode(s.command
   ,6,'Update'
   ,2,'Insert'
   ,7,'Delete',s.command) "Command"
from v\$lock l, v\$session s , user_objects o
where l.sid != 2
and  s.sid = l .sid
and o.object_id (+) = l.id1;
!
}



table ()
{
DB_run_query_pipe <<!
set pages 300
set feedback off
ttitle 'Report of Tables'
column segment_name heading 'Name' format a22
column siz heading 'Size (mb) ' format '99,990.99'
column nxt heading 'Nxt' format '990.99'
column dt heading 'Analyzed'
column tbs heading 'Tablespace' format a9
column count heading 'Ex' format 99
select segment_name,t.tablespace_name tbs
      ,sum(bytes)/1024/1024 siz,num_rows
      ,to_char(last_analyzed,'DD-Mon-YY') dt
      ,next_extent/(1024*1024) nxt,count(*) count
from  user_tables   t
   , user_extents e
where t.table_name = e.segment_name
and t.table_name like '%${CONSOLE_FILTER}%'
group by e.segment_name,t.tablespace_name
,num_rows,to_char(last_analyzed,'DD-Mon-YY')
,next_extent
order by siz desc;
!
}

free_space_query ()
{
	if [ "${CONSOLE_FILTER}" = "" ] ; then
		CONSOLE_FILTER="%"
	else
		/usr/bin/echo "Filter of ${CONSOLE_FILTER}"
	fi
DB_run_query_pipe <<!
set feedback off pages 200
ttitle center "Free Space"
column byt heading "Space (Mb)" format 999,990.99
column maxx heading "Largest (Mb)" format 999,990.99
column c heading "Number"
select tablespace_name,sum(bytes)/(1024*1024) byt,count(*) c
,max(bytes)/(1024*1024) Maxx
from dba_free_space
where tablespace_name like '%${CONSOLE_FILTER}%'
group by tablespace_name
/
!
}

free_space ()
{
free_space_query
X=0

while [ ${X} != 1 ]
do
   /usr/bin/echo "Free Space : (c,q,e)> \c"

   read OPT

   case ${OPT} in
      c) echo "Coalesce which tablespace? \c"
         read TS
         DB_run_query "alter tablespace ${TS} coalesce;"
         free_space_query ;;
      q) free_space_query ;;
      e) X=1 ;;
   esac
done
}

killer_what () {
	/usr/bin/echo "What SID? \c"
	read SID

	DB_run_query_pipe <<EOF
set serveroutput on size 1000000
	set feedback off lines ${LINES}
declare
      w_loc number :=0;
w_string varchar2(32000);
cursor c1 is
   select sql_text 
   from v\$session s, v\$sqltext t
   where s.sid = ${SID}
   and sql_hasH_value = hash_value
   and sql_Address = Address
   order by sid,piece;
begin
for w_rec in c1 loop
    w_string := w_string || w_rec.sql_text;
end loop;

    while length(w_string) >= ${LINES} loop
    w_loc := instr(substr(w_string,1,${LINES}),',',-1);

    if w_loc = 0 then
    w_loc := instr(substr(w_string,1,80),' ',-1);
    end if;
    dbms_output.put_line(substr(w_string,1,w_loc));
    w_string := substr(w_string,w_loc+1);
    end loop;
    dbms_output.put_line(w_string);
end;
/
EOF
unset SID
}

killer_query () {
DB_run_query_pipe <<EOF
set array 3
set feedback off
column machine format a15
column command format 9999999
column sid format 999
column program format a15
set pages 200
select sid,serial#,machine,program,osuser,command from v\$session
where osuser != 'oracle'
and program not like 'oracle%';
EOF
}


killer () {
	killer_query
	X=0
	while [ ${X} != 1 ] ; do

	/usr/bin/echo "Killer : (q,k,w,e,h)> \c"
	read OPTION

	case ${OPTION} in
		q) killer_query ;;
		k) kill_it ;;
		w) killer_what ;;
		e|E) X=1 ;;
		h) killer_help ;;
	esac
	done
}

kill_it () {
	/usr/bin/echo "What SID? \c"
	read SID

	DB_run_query_pipe << ! | read SERIAL
	set pages 0
	set feedback off
	select rtrim(serial#) from v\$session where sid = ${SID};
!

	/usr/bin/echo "${SERIAL}"
	if [ "${SERIAL}" = '' ] ; then
		echo "Invalid SID"
	else
	DB_run_query_pipe <<EOF
	alter system kill session '${SID},${SERIAL}';
EOF
	unset SID
	fi
}

killer_help () {
	/usr/bin/echo "\nk\tkill
q\tQuery
w\tWhat are they doing
e\texit"
}

################################################################################
# Object analysis

object () {
DB_run_query_pipe <<!
set pages 100
set feedback off
ttitle left 'GSF' -
   center 'Report of Object Sizes'  -
   right MYDATE skip 1 left ' '
column segment_name heading 'Object Name' format a28
column object_type heading 'Type' format a5
column size heading 'Size (bytes)'
column seg heading 'Ext' format 9,999
column ate NOPRINT new_value MYDATE
column nxtm heading '(Mb)' format '990.99'



select segment_name
,o.object_type
,to_char(sum(bytes),'9,999,999,999') "Size"
,count(*) seg,to_char(sysdate,'DD-Mon-YYYY') ate
,nvl(i.next_extent,t.next_extent)/(1024*1024) nxtm
from user_extents u, user_objects o,user_indexes i,user_tables t
where o.object_name = u.segment_name
and o.object_name = i.index_name (+)
and o.object_name = t.table_name (+)
and o.object_name like '%${CONSOLE_FILTER}%'
group by segment_name,o.object_type,sysdate,nvl(i.next_extent,t.next_extent)
order by 3 desc;
!
}

################################################################################
# Get Source Code out of database

get_source () {
	/usr/bin/echo "Which object do you want? \c"
	read OBJ

	DB_object_exists ${OBJ}
	if [ $? != 0 ] ; then
		/usr/bin/echo "Object ${OBJ} does not exist."
	else
		DB_run_query_pipe<<!
		set termout off
		spool ${OBJ}.source
		set pages 0
		set feedback off
		set long 4000
		select text from user_source where name = upper('${OBJ}');
!
		/usr/bin/echo "Source written to ${OBJ}.source"
	fi
}

################################################################################
# Reports on Indexs

index () {
	DB_run_query_pipe <<!
	set feedback off
	set pages 300
	ttitle 'Report of Indexes'
	break on nexxt
	repfooter skip 1 center 'U-Users, I-GS_INDEX, D-GS_DATA'
	column segment_name heading 'Name' format a20
	column pos heading 'Pos'       format 99
	column name heading 'On' format a30
	column sizze heading 'Size(Mb)' format 9,990.99
	column nexxt heading 'Next' format 990.99
	column ext heading 'Ext' format 990
	break on sizee
	break on e.segment_name
	select e.segment_name,ic.table_name||'.'||ic.column_name name
	,column_position pos
	,sum(bytes)/(1024*1024) sizze
	,decode(i.tablespace_name,'USERS','U','GS_INDEX','I','GS_DATA','D') tabs
	,next_extent/(1024*1024) nexxt
	,count(e.segment_name) ext
	from user_ind_columns ic
	   , user_indexes  i
	   , user_extents e
	where ic.index_name = i.index_name
	and   ic.index_name = e.segment_name
	and i.index_name like '%${CONSOLE_FILTER}%'
	group by e.segment_name,ic.table_name||'.'||ic.column_name
	,column_position
	,decode(i.tablespace_name,'USERS','U','GS_INDEX','I','GS_DATA','D')
	,next_extent/(1024*1024)
	order by e.segment_name,column_position;
!
}

################################################################################
# Comments on tables

comment () {
	DB_run_query_pipe <<!
	set feedback off
	set pages 200
	select table_name,comments from user_tab_comments;
!
}

################################################################################
# Time parallel processes have been active (you can see 
# if parallel is being used)

para () {
	for X in  0 1 2 3 4 5 6 7
	do
	TIME=`ps -ef | grep ora_p00${X}_${ORACLE_SID} | grep -v grep | cut -c42-47`

	/usr/bin/echo "$TIME \c"
	done
	/usr/bin/echo "\n"
}


desc () {
	/usr/bin/echo "Describe which object? \c"
	read OBJ

	DB_object_exists ${OBJ}
	if [ $? != 0 ] ; then
		/usr/bin/echo "Object ${OBJ} does not exist."
	else
		DB_desc ${OBJ}
	fi
}


what () {
	session='$session'
	/usr/bin/echo \
	"          The following things are being run on $ORACLE_SID from the server\n" \
   "          -----------------------------------------------------------------"

for TEMP in `ps -ef |grep $ORACLE_SID | grep LOCAL=YES |  cut -c 16-21 | sort | uniq`
do
	PROCESS=`echo ${TEMP}`
	echo "\n"
	DB_run_query_pipe <<!
	break on sid
	set pages 0
	set feedback off
	select 'User '||username||' ('||SID||') logged on at '||
	to_char(logon_time,'DD-Mon-YY HH24:mi')||' from the machine '||machine||
	' (command '||command||') and is running statement'
	from v\$session where process = to_char(${PROCESS});

	select sid,sql_text "Text"
	from v\$session s, v\$sqltext t
	where s.process =  to_char(${PROCESS})
	and sql_hasH_value = hash_value
	and sql_Address = Address
	order by sid,piece;
!
	done

	if [ $# = 0 ] ; then
		/usr/bin/echo "\nPress any key for client sessions"
		read dummy
	fi

	/usr/bin/echo "            The following client sessions are active
            -----------------------------------------\n"

	for ACLIENT in `DB_run_query_pipe <<EOD
	set pages 0
	select sid from v\$session where machine !=  nvl('${HOSTNAME}' ,'hercules')
	and program not like 'oracle%'
	and schemaname != 'SYS' and status = 'ACTIVE';
EOD
`
	do

	if [ ${ACLIENT} = 'no' ] ; then
		/usr/bin/echo "There are no active client sessions"
		return
	else
		DB_run_query_pipe <<!
		set pages 0
		set feedback off
		select 'The user '||username||' on machine '||machine||' from '||program
		from v\$session where sid = ${ACLIENT}
		and program not like 'oracle%';

		select sql_text "Text"
		from v\$session s, v\$sqltext t
		where s.sid =  ${ACLIENT}
		and sql_hasH_value = hash_value
		and sql_Address = Address
		order by piece;
!
fi
done
}

analyze () {
	/usr/bin/echo "Analyze which table? \c" ; read TAB
	DB_object_exists ${TAB}
	if [ $? != 0 ] ; then
		/usr/bin/echo "Table ${TAB} does not exists."
	else
		/usr/bin/echo "Percent? \c" ; read PCNT
		if [ ${PCNT} = 0 ] ; then
			DB_run_query "analyze table ${TAB} compute statistics;" &
		else
			DB_run_query "analyze table ${TAB} estimate statistics sample ${PCNT} percent;" &
		fi
	fi
}


################################################################################

explain () {

   killer_query
   X=0
   while [ ${X} != 1 ] ; do

   /usr/bin/echo "Explain : (x,q,w,e,h)> \c"
   read OPTION

   case ${OPTION} in
      q) killer_query ;;
      x) get_query ;;
      e|E) X=1 ;;
      h) killer_help ;;
   esac
   done

}

get_query () {
	/usr/bin/echo "What SID? \c"
	read SID

   DB_run_query_pipe <<ENDOFFILE > /tmp/$$.sql
   set feedback off
	set serveroutput on
	declare
		w_text varchar2(4000);
		cursor c1 is
		select sql_text
		from v\$session s, v\$sqltext t
		where s.sid = ${SID}
		and sql_hasH_value = hash_value
		and sql_Address = Address
		order by  piece;
	begin
		dbms_output.put_line('explain plan set statement_id = ''$$'' for ');
		for w_rec in c1 loop
			w_text := w_text || w_rec.sql_text;
		end loop;
		dbms_output.put_line(w_text);
		dbms_output.put_line(';');
	end;
/
ENDOFFILE

DB_run /tmp/$$.sql
sleep 5

DB_run_query_pipe <<EOF
select lpad(' ',2*(level-1))||operation||' '||options
||' '||object_name
||' '||DECODE(id, 0, 'Cost = '||position) "Query_Plan"
from plan_table
start with  id = 0 and statement_id  = '$$'
connect by prior id = parent_id and  statement_id = '$$';
EOF

DB_run_query_pipe<<!
set feedback off
delete from plan_table where statement_id = '$$'
;
!

}

views ()
{

DB_run_query_pipe<<!
select view_name from user_views;
!


}


procs () 
{
DB_run_query_pipe<<!
set pages 200
set feedback off
col object_name form a30
col object_type form a20
select object_name,object_type,status 
from user_objects 
where object_type like 'PA%'
or object_type in ('FUNCTION','PROCEDURE');
!
}




filter ()
{
	/usr/bin/echo "Set filter to? \c " 
	read FILTER
	CONSOLE_FILTER=`echo $FILTER | tr '[a-z]' '[A-Z]'`
}

longops ()
{
DB_run_query_pipe<<!
set pages 200
select sofar/totalwork,s.sid from v\$session_longops L, v\$session S
where totalwork !=0 and S.status = 'ACTIVE'
and s.sid = l.sid;
!
}


cmd ()
{
echo "What number\c"
read NO
case $NO in
1) CMD="CREATE TABLE  " ;;
2) CMD="INSERT  " ;;
3) CMD="SELECT  " ;;
4) CMD="CREATE CLUSTER  " ;;
5) CMD="ALTER CLUSTER  " ;;
6) CMD="UPDATE  " ;;
7) CMD="DELETE  " ;;
8) CMD="DROP CLUSTER  " ;;
9) CMD="CREATE INDEX  " ;;
10) CMD="DROP INDEX  " ;;
11) CMD="ALTER INDEX  " ;;
12) CMD="DROP TABLE  " ;;
13) CMD="CREATE SEQUENCE  " ;;
14) CMD="ALTER SEQUENCE  " ;;
15) CMD="ALTER TABLE  " ;;
16) CMD="DROP SEQUENCE  " ;;
17) CMD="GRANT  " ;;
18) CMD="REVOKE  " ;;
19) CMD="CREATE SYNONYM  " ;;
20) CMD="DROP SYNONYM  " ;;
21) CMD="CREATE VIEW  " ;;
22) CMD="DROP VIEW  " ;;
23) CMD="VALIDATE INDEX  " ;;
24) CMD="CREATE PROCEDURE  " ;;
25) CMD="ALTER PROCEDURE  " ;;
26) CMD="LOCK TABLE  " ;;
27) CMD="NO OPERATION  " ;;
28) CMD="RENAME  " ;;
29) CMD="COMMENT  " ;;
30) CMD="AUDIT  " ;;
31) CMD="NOAUDIT  " ;;
32) CMD="CREATE DATABASE LINK  " ;;
33) CMD="DROP DATABASE LINK  " ;;
34) CMD="CREATE DATABASE  " ;;
35) CMD="ALTER DATABASE  " ;;
36) CMD="CREATE ROLLBACK SEGMENT  " ;;
37) CMD="ALTER ROLLBACK SEGMENT  " ;;
38) CMD="DROP ROLLBACK SEGMENT  " ;;
39) CMD="CREATE TABLESPACE  " ;;
40) CMD="ALTER TABLESPACE  " ;;
41) CMD="DROP TABLESPACE  " ;;
42) CMD="ALTER SESSION  " ;;
43) CMD="ALTER USER  " ;;
44) CMD="COMMIT  " ;;
45) CMD="ROLLBACK  " ;;
46) CMD="SAVEPOINT  " ;;
47) CMD="PL/SQL EXECUTE  " ;;
48) CMD="SET TRANSACTION  " ;;
49) CMD="ALTER SYSTEM SWITCH LOG  " ;;
50) CMD="EXPLAIN  " ;;
51) CMD="CREATE USER  " ;;
52) CMD="CREATE ROLE  " ;;
53) CMD="DROP USER  " ;;
54) CMD="DROP ROLE  " ;;
55) CMD="SET ROLE  " ;;
56) CMD="CREATE SCHEMA  " ;;
57) CMD="CREATE CONTROL FILE  " ;;
58) CMD="ALTER TRACING  " ;;
59) CMD="CREATE TRIGGER  " ;;
60) CMD="ALTER TRIGGER  " ;;
61) CMD="DROP TRIGGER  " ;;
62) CMD="ANALYZE TABLE  " ;;
63) CMD="ANALYZE INDEX  " ;;
64) CMD="ANALYZE CLUSTER  " ;;
65) CMD="CREATE PROFILE  " ;;
66) CMD="DROP PROFILE  " ;;
67) CMD="ALTER PROFILE  " ;;
68) CMD="DROP PROCEDURE  " ;;
69) CMD="DROP PROCEDURE  " ;;
70) CMD="ALTER RESOURCE COST  " ;;
71) CMD="CREATE SNAPSHOT LOG  " ;;
72) CMD="ALTER SNAPSHOT LOG  " ;;
73) CMD="DROP SNAPSHOT LOG  " ;;
74) CMD="CREATE SNAPSHOT  " ;;
75) CMD="ALTER SNAPSHOT  " ;;
76) CMD="DROP SNAPSHOT  " ;;
79) CMD="ALTER ROLE  " ;;
85) CMD="TRUNCATE TABLE  " ;;
86) CMD="TRUNCATE CLUSTER  " ;;
88) CMD="ALTER VIEW  " ;;
91) CMD="CREATE FUNCTION  " ;;
92) CMD="ALTER FUNCTION  " ;;
93) CMD="DROP FUNCTION  " ;;
94) CMD="CREATE PACKAGE  " ;;
95) CMD="ALTER PACKAGE  " ;;
96) CMD="DROP PACKAGE  " ;;
97) CMD="CREATE PACKAGE BODY  " ;;
98) CMD="ALTER PACKAGE BODY  " ;;
99) CMD="DROP PACKAGE BODY  " ;;
*) CMD="Unknown" ;;
esac
echo $CMD
}
------------------------------------------------------------------------------------------------------------------
***********
* console *
***********
#!/bin/ksh
# set -x

help ()
{
	/usr/bin/echo "Commands
---------
l\tDisplays locks on ${ORACLE_SID}
w\tWhat's running
k\tKill a session
i\tIndex information
t\tTable information
v\tView information
o\tObject information
f\tFreeSpace on Tablespace
c\tObject comments
a\tAnalyze Table
p\tParallel
pr\tProcedures/Functions/Packages
d\tDescribe Object
g\tGet source from database
x\tExplain Plan
cmd\tCommand
top\ttop
%\t% job complete
GSF\tGSF Console
fi\tFilter
e\tExit
q\tQuit"
}

. console_lib

/usr/bin/echo "Database Console for ${ORACLE_SID}."

while [ 1 -lt 2 ] ; do
	/usr/bin/echo "Console : (a,l,w,k,i,d,t,p,o,pr,f,g,h,x,%,gsf,c,e)> \c"
	read OPT
	case ${OPT} in 
		a|A)	analyze ;;
		l|L)	lock ;;
		w|W)	what  ;;
		d|D)	desc ;;
		k|K)	killer ;;
		g|G)	get_source ;;
		i|I)  	index ;;
		v|V)	views ;;
		t|T) 	table  ;;
		o|O) 	object ;;
		p|P) 	para  ;;
		pr|PR) 	procs  ;;
		GSF|gsf) gsf_console  ;;
		f|F)	free_space ;;
		h|H) 	help ;;
		c|C) 	comment ;;
		x|X) 	explain ;;
		fi|FI) 	filter ;;
		%)  	longops ;;
	   cmd|CMD) 	cmd ;;
	   top|TOP) 	top ;;
		!) 	ksh ;;
		e|q) 	exit ;;
	esac
done
---------------------------------------------------------------------------------------------------------------------
*********************
* create_address.sh *
*********************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : 
#               
#
# Called by   : ia_daemon.sh
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

log()
{
  echo "$(date +%Y-%m-%d-%H:%M:%S): "$* | tee -a ${IA_HOME}/log/$(basename $0)".$$"
}

error_chk(){

ES=$1
MOD=$2

if [[ $ES != "0" ]]
then
    log "***********************************************"
    echo "$MOD : Failed"
    log "***********************************************"
    exit 1
else
    log "***********************************************"
    echo "$MOD : Finished Successfully"
    log "***********************************************"
fi
}

chk_index_exists()
{
if [[ $# != 5 ]]
then 
   echo "
	I need 5 parameters for this function call:
	TABLENAME=$1
   COLUMNAME=$2
   TABLESPACE=$3
	INI=$4
	NXT=$5
	exit 1"
fi

TABLENAME=$(echo $1 | tr '[a-z]' '[A-Z]')
COL=$(echo $2 | tr '[a-z]' '[A-Z]')
TABLESPACE=$3
INI=$4
NXT=$5

SQL_TEXT=`DB_run_query_pipe<<!
whenever sqlerror exit sql.sqlcode
set heading off
set feedback off
set pages 0
select index_name
from all_ind_columns
where table_name = '$TABLENAME'
and column_name = '$COL';
exit sql.sqlcode
!`
error_chk $? chk_index_exists

if [ -z ${SQL_TEXT} ]; then
   echo "Index not detected, building..."
   create_index ${TABLENAME} ${COL} ${TABLESPACE} ${INI} ${NXT}
else
  echo "Index ${SQL_TEXT} detected"
fi
}


create_index(){
TABLENAME=$1
COL=$2
TABLESPACE=$3
INI=$4
NXT=$5
IDX_NAME=${TABLENAME}_${COL}_IDX

log "Creating index $IDX_NAME..."
DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
create  index $IDX_NAME on
        ${TABLENAME}($COL)
        nologging tablespace $TABLESPACE pctfree 0
        storage(initial ${INI} next ${NXT} pctincrease 0);
exit sql.sqlcode
!
CE=$?
error_chk $CE create_index
}


drop_table()
{

TABLE=$1

if DB_object_exists ${TABLE}
then

cat <<! | DB_run_query_pipe
whenever sqlerror exit sql.sqlcode
drop table ${TABLE};
exit sql.sqlcode
!
CE=$?
error_chk $CE drop_table
fi
}


create_table_address(){

if [[ $# != 4 ]]
then 
   echo "\n
	I need 4 parameters for this function call:
	NAME=$1
   TABLESPACE=$2
	INI=$3
	NXT=$4
	exit"
fi

NAME=$1
TBLSPACE=$2
INI=$3
NXT=$4

DB_run_query_pipe <<!
Prompt
Prompt Creating table ${NAME} ...
Prompt
whenever sqlerror exit sql.sqlcode
create table $NAME
tablespace $TBLSPACE pctfree 0 pctused 99
storage ( initial ${INI} next ${NXT} pctincrease 0) nologging
as
select  b.ptcabs house_id,
		  b.house_name,
        b.house_number,
        d.street_1,
        d.street_2,
        d.district,
        c.town_name,
        c.county_name,
        d.postcode,
        rownum seq
from    load_house b,
        load_town c,
        load_code d
where   substr(b.ptcabs,1,4) = c.posttown_code
and     substr(b.ptcabs,1,4) = d.posttown_code
and     b.street_code = d.street_code;
exit sql.sqlcode;
!
CE="$?"
error_chk $CE CREATE_TABLE_ADDRESS
}


####
# Main
####

# Set up standard variables and functions

. ${HOME}/prod/bin/ia_vars.sh

log Started
log "check for indexes on table load_town"
chk_index_exists load_town posttown_code ia_index 5M 5M

log "check for indexes on table load_code"
chk_index_exists load_code posttown_code ia_index 5M 5M

log "check for indexes on table load_code"
chk_index_exists load_code street_code ia_index 5M 5M

drop_table ADDRESS

log "creating table address ..."
create_table_address ADDRESS IA_ADDRESS 100M 100M

log "running Jari's routine to swap ptcabs for house_ids"
$IA_HKEYS/gen_hkeys.sh ADDRESS HOUSE_ID
error_chk $? gen_hkeys.sh

log "creating index for table ia_address"
chk_index_exists ia_address house_id ia_index 50M 50M

# ============================[END]==================================
*******************
* create_index.sh *
*******************
DB_run_query_pipe<<!
create index dim2k_ind
on DIM2K (HOUSE_ID)
tablespace IA_INDEX
storage (initial 200m next 100m pctincrease 0)
pctfree 0 nologging;
!

B_run_query_pipe<<!
create unique index dim2k_seq_ind
on dim2k (seq)  
tablespace ia_index 
storage( initial 100M  next 100M  pctincrease 0)
pctfree 0 nologging;
!
--------------------------------------------------------------------------------------------------
*******
* de2 *
*******
TABLE=DIM2K
DUPES=DIM2K_DUPES
KEEPS=DIM2K_KEEPS
DB_run_query_pipe<<!
whenever sqlerror exit failure
alter table ${TABLE} nologging;

create table ${DUPES}
tablespace USERS
storage (initial 1m next 1m pctincrease 0) 
pctused 99 pctfree 0 nologging
as
select rowid DIM_ID,id from ${TABLE}
where (id) in 
(select id from ${TABLE}
group by id having count(*) >1)
;

create table ${KEEPS}
tablespace USERS
storage (initial 1m next 1m pctincrease 0) 
pctused 99 pctfree 0 nologging
as
select min(rowid) K_ID,id
from ${DUPES}
group by id;
!
----------------------------------------------------------------------------------------------------
*************
* dedupe.sh *
*************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : Removes duplicate entries on the IA_LOAD_DIM2K.
#               
#
# Called by   : combine_harvester.sh
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

usage()
{
echo "Usage: $0 DIM2K_table"
exit 1
}


remove_dupes ()
{
DB_run_query_pipe<<!
whenever sqlerror exit failure
alter table ${TABLE} nologging;

create table ${DUPES}
tablespace USERS
storage (initial 1m next 1m pctincrease 0) 
pctused 99 pctfree 0 nologging
as
select rowid DIM_ID,id from ${TABLE}
where (id) in 
(select id from ${TABLE}
group by id having count(*) >1)
;

create table ${KEEPS}
tablespace USERS
storage (initial 1m next 1m pctincrease 0) 
pctused 99 pctfree 0 nologging
as
select min(rowid) K_ID,id
from ${DUPES}
group by id;

delete from ${DUPES} where rowid in (select K_ID from ${KEEPS});
!
if [ $? != 0 ] ; then
	exit 201
fi

TMP=`DB_run_query_pipe<<! 
delete from ${TABLE} where rowid in (select DIM_ID   from ${DUPES});
!
` 

TMP=`echo $TMP | awk '{print $1}'`

#${IA_BIN}/ia_reports.sh DUPE $TMP

DB_run_query_pipe<<!
drop table ${DUPES};
drop table ${KEEPS};
!

if [ $? != 0 ] ; then
	exit 201
fi
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

. ia_vars.sh

TABLE=$1
DUPES=${TABLE}_DUPES
KEEPS=${TABLE}_KEEPS

remove_dupes
# ============================[END]==================================
**************
* ia_vars.sh *
**************
#!/bin/ksh
#set -x
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Usage       : %M%
#
# Description : Defines all IA environmental variables for
#               Unix, NAMS, Cobol 
#
# Exit Status : n/a
#
# Called by   : All IA shell programs
#
# What Usage  : %W% %G%
#
# =====================================================================

IA_HOME=${HOME}/prod

IA_SHELL=${IA_HOME}/shell
IA_PROC=${IA_SHELL}/proc
IA_LOG=${IA_HOME}/log               # Oracle logs and runtime event logs
IA_BAD=${IA_HOME}/bad               # Oracle generated bad files
IA_WORKSPACE=${IA_HOME}/workspace   # generic IA program workspace
IA_LOAD=${IA_HOME}/load             # generic IA load file area
IA_TEMPLATES=${IA_HOME}/templates   # cob files for dcu loads
IA_REPORTS=${IA_HOME}/reports       # Reports on suppression processing
IA_BIN=${IA_HOME}/bin               # Reports on suppression processing
IA_MF=${IA_HOME}/mf                 # Target directory for zipped data from Hercules
IA_RESOLVE=${IA_SHELL}/resolve	   # type a & b resolve scripts
IA_HKEYS=${IA_SHELL}/house_keys	   # ptcabs for house id swapping routine


IA_ERRLOG=${IA_HOME}/log/IA_ERRORS.log # IA error log file

IA_NEW=${IA_HOME}/new                # Target for new suppression files
IA_OLD=${IA_HOME}/old                # Target for old suppression files

#Unix Nams Envs
IA_NAMS_BASE=/workspace01/pp2/nams   # Full path to NAMS tree
IA_NAMS_WS1=/workspace02
IA_NAMS_WS2=/workspace02
IA_NAMS_SID=PP_DEV  

#IA Oracle DBMS Env
IA_ORA_SID=PP_DEV

# Micro Focus COBOL variables
IA_COBDIR=/opt/thirdpp/lib/cobol   # Full path to Micro Focus COBOL
IA_COBPATH=${IA_NAMS_BASE}/pgms   # Cobrun dynamic load directories



#----------------------------------------------------------------------
# IA_ERROR_LOG - Log all IA related errors
# usage: IA_ERROR_LOG <message_string>
#----------------------------------------------------------------------
IA_ERROR_LOG ()
{
typeset -u APPNAME
APPNAME=$1
MESSG=$2
echo `date '+%d%m%y %H:%M:%S'` $APPNAME ">" ${MESSG} >> ${IA_ERRLOG}
}

#----------------------------------------------------------------------
load_start ()
{
if [ $# != 1 ] ; then
	echo "Pass name"
else
	ls -ltr ${IA_LOG}/$1.log.* | awk '{print $9}' > /tmp/${1}.start
fi
}

load_end ()
{
if [ $# != 1 ] ; then
	echo "Pass name"
else
	ls -ltr ${IA_LOG}/$1.log.* | awk '{print $9}' > /tmp/${1}.end
fi

LOADED=0
TMP_LOADED=0
FAILED=0
TMP_FAILED=0
for FILE in `comm -3 /tmp/${1}.start /tmp/${1}.end` ; do
TMP_LOADED=`grep  "successfully loaded" ${FILE} | awk '{print $1}'`
TMP_FAILED=`grep  "data errors" ${FILE} | awk '{print $1}'`
LOADED=`expr ${LOADED} + ${TMP_LOADED}`
FAILED=`expr ${FAILED} + ${TMP_FAILED}`
done

${IA_BIN}/ia_reports.sh LOAD   ${LOADED}
${IA_BIN}/ia_reports.sh FAILED ${FAILED}

}

tidy_dcu ()
{
#set -x
rm -f c.c c.out colinfo 2>/dev/null
}

LOAD_TBLSP=LOAD_DATA
TEMP_TBLSP=LOAD_DATA
LOAD_IDX_TBLSP=LOAD_DATA  # used for seq no's i.e housekey generation
CAND_TBLSP=CANDIDATE
DIM2K_IDX=DIM2KIDX
-----------------------------------------------------------------------------------------------
****************
* gen_hkeys.sh *
****************
#!/bin/ksh
#set -x
# =====================================================================
#
# Script Name : gen_hkeys.sh  
#
# Version     : 1.1 - 04/05/01
#
# Usage       : gen_hkeys.sh table_name [column_name] 
#
# Description : This script generates new IA house keys for unregistered
#               NAMS ptcabs from the supplied <table_name> 
#
# Exit Status : 
#
#       0       Successful run
#       1       Error in run parameters - see usage
#       3       Application not registered with ia_job_control
#
# Called by   : Script Controller Application /
#               or can be run stand alone
#
# What Usage  : @(#)gen_hkeys.sh	1.1 04/05/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

# -------------
# GLOBAL PARAMS
# -------------

APPNAME="GENHKEYS"          # used for IA job control/error pool id
IA_HOUSE_KEY_TB=HOUSE_KEYS  # ia house key table

# --------------------
# FUNCTIONS/PROCEDURES
# --------------------

Usage ()
{
echo "Usage:$0\ttable_name [column_name]
\ttable_name\tname of source table containing PTCABS keys
\tcolumn_name\source table PTCABS column name, defaults to HOUSE_ID if not specified"
exit 1
}


#----------------------------------------------------------------------
# CHECK_APP_REGISTERED - returns app ID if registere
#----------------------------------------------------------------------
Check_App_Reg ()
{
DB_run_query_pipe<<!
set heading off
set pages 0
set feedback off
select ia_app_id
from ia_job_control
where appname = '$APPNAME';
!
}



#----------------------------------------------------------------------
# CHECK_STATUS
#----------------------------------------------------------------------
Check_Status ()
{
DB_run_query_pipe<<!
set heading off
set pages 0
set feedback off
select stage + to_number(decode(stagestatus,'FINISHED',1,'RUNNING','0','0')) 
from ia_job_control 
where ia_app_id = $IA_APP_ID
and stage != totalstages 
or stagestatus = 'RUNNING';
!
}

#----------------------------------------------------------------------
# CHECK_COLUMN_EXISTS - returns 0=not exists 1=exists
#----------------------------------------------------------------------
Check_Column_Exists ()
{
DB_run_query_pipe<<!
set heading off
set pages 0
set feedback off 
select count(*) from all_tables 
where table_name = '$TABLE'; 
!
}


#----------------------------------------------------------------------
# CHECK_FOR_SEQ_INDEX - returns index_name if exists  
#----------------------------------------------------------------------
Check_SEQ_Index ()
{
# check index exists
DB_run_query_pipe<<!
set heading off
set feedback off
set pages 0
select index_name 
from all_ind_columns 
where table_name = '$TABLE'
and column_name = 'SEQ';
!
}


#----------------------------------------------------------------------
# BUILD_SEQ_INDEX - creates index on SEQ column for the input table 
#----------------------------------------------------------------------
Build_SEQ_Index ()
{
#COLLEN=11   # length of PTCABS
#IDX_INIT=`echo "$COLLEN * $RECCOUNT / 1024 " | bc`
#IDX_NEXT=$IDX_INIT
INI=$1
NXT=$2
IDX_NAME=${TABLE}_SEQ

RETVAL=`DB_run_query_pipe<<!
CREATE UNIQUE INDEX $IDX_NAME 
 ON ${TABLE}(SEQ)  STORAGE(
     INITIAL $INI  NEXT $NXT  PCTINCREASE 0)
NOLOGGING TABLESPACE USERS pctfree 0;
!`

DB_object_exists $IDX_NAME
if [ $? -ne 0 ]; then
   echo "Index $IDX_NAME build failed, aborting"
   echo $RETVAL
   exit 4
else
   echo "Index $IDX_NAME built"
fi
}



#----------------------------------------------------------------------
# VERIFY_SOURCE_TABLE - checks index on SEQ exists 
#----------------------------------------------------------------------
Verify_Source_Table ()
{
# check column exists
COLEXISTS=`Check_Column_Exists| awk '{print $1}'`
if [ $COLEXISTS -eq 0 ]; then
  echo "Table/Column $TABLE.$COLUMN_NAME not found"
  exit 2
fi


IDX_NAME=`Check_SEQ_Index| awk '{print $1}'`
if [ -z $IDX_NAME ]; then
   echo "Index not detected, building.."
   Build_SEQ_Index 100M 100M
else
  echo "Index $IDX_NAME detected"
fi
}



#----------------------------------------------------------------------
# GENERATE_IA_HOUSE_ID - assigns an IA House Id to non registered PTCABS 
#----------------------------------------------------------------------
Generate_IA_House_ID ()
{
echo "Generating IA house identifiers for non registered PTCABS id's" 

# if server has multiprocessor OPQ capability
# switch APPEND hint to PARALLEL 

DB_run_query_pipe<<!
set serveroutput on size 1000000;
declare
  
    w_stage number(10) := 1;
    w_commit number(10)     := 50000;
    w_chunks number(10)     := 0;
    w_chunk  number(10)     := 0;
    w_start_seq  number(10) := 0; 
    w_end_seq number(10)    := w_commit;

    w_total_recs number(10);

    jcRec   ia_job_control%Rowtype;

begin
 
   --get the IA app id and status 
   select ia_app_id,lastseq,stagestatus  
   into jcRec.ia_app_id,jcRec.lastseq,jcRec.stagestatus
   from ia_job_control where ia_app_id = '$IA_APP_ID';

   if jcRec.stagestatus = 'RUNNING' then
      w_start_seq := jcRec.lastseq;
      w_end_seq := w_start_seq + w_commit;
      jcRec.message := 'Job restarted at Stage '||w_stage;
   else
      jcRec.stagestatus := 'RUNNING';
      w_start_seq := 0;
      jcRec.message := 'Running Stage '||w_stage;
   end if;

   select count(*) into w_total_recs
   from $TABLE where seq > w_start_seq;

	w_chunks := ceil(w_total_recs / w_commit);


   --update the ia_job control stats
   update ia_job_control
   set lastseq = w_start_seq
      ,batch = 0
      ,stage = w_stage 
      ,ofbatches = w_chunks
      ,batchsize = w_commit 
      ,rectotal = w_total_recs 
      ,message = jcRec.message 
      ,stagestatus = jcRec.stagestatus
      ,timestamp = to_char(sysdate,'DD-MM-YYYY HH24:MI:SS')
   where ia_app_id = jcRec.ia_app_id;

   commit;
	For chunk in 1..w_chunks Loop
	
	    insert /*+ APPEND */ into $IA_HOUSE_KEY_TB  
       select  b.$COLUMN_NAME,house_keys_SEQ.nextval  
       from    (select distinct $COLUMN_NAME from $TABLE
	      	    where (seq > w_start_seq and seq < w_end_seq + 1)) b
       where not exists (select '1' from $IA_HOUSE_KEY_TB  a
                         where a.ptcabs = b.$COLUMN_NAME);
		 
        --update the ia_job control stats
        w_chunk := w_chunk + 1;  -- used for reporting
        update ia_job_control
        set lastseq = w_end_seq
           ,timestamp = to_char(sysdate,'DD-MM-YYYY HH24:MI:SS')
           ,batch = w_chunk
        where ia_app_id = jcRec.ia_app_id;
       commit;
	
		w_start_seq := w_end_seq;
		w_end_seq := w_end_seq + w_commit;
	End Loop;

   --update the ia_job control stats
   update ia_job_control
   set stagestatus = 'FINISHED'
       ,message = w_chunk||' of '||w_chunks||' processed'
      ,timestamp = to_char(sysdate,'DD-MM-YYYY HH24:MI:SS')
   where ia_app_id = jcRec.ia_app_id;
   commit;

exception
	When Others Then
		Dbms_Output.Put_Line('last successfull commit seqno:'||w_start_seq);
		Dbms_Output.Put_Line(SqlErrm); 
end;
/
!

}


#----------------------------------------------------------------------
# SWITCH_IDENTIFIERS - replaces the NAMS PTCABS from the specified
#                      table with the new IA house id 
#----------------------------------------------------------------------
Switch_Identifiers ()
{
echo "Switching old PTCABS identifiers to new IA house id's for $TABLE"


DB_run_query_pipe<<!

set serveroutput on size 1000000;
declare
    w_stage  number(10) := 2;
    w_commit number(10) := 50000;
    w_chunks number(10) := 0;
    w_chunk  number(10) := 0;

    w_start_seq  number(10) ;
    w_end_seq number(10) := w_commit;

    w_total_recs number(10);

    jcRec ia_job_control%Rowtype;

begin

   --get the IA app id and status 
   select ia_app_id,lastseq,stagestatus  
   into jcRec.ia_app_id,jcRec.lastseq,jcRec.stagestatus
   from ia_job_control where ia_app_id = '$IA_APP_ID';

   if jcRec.stagestatus = 'RUNNING' then
      w_start_seq := jcRec.lastseq;
      w_end_seq := w_start_seq + w_commit;
      jcRec.message := 'Job restarted at Stage '||w_stage;
   else
      jcRec.stagestatus := 'RUNNING';
      w_start_seq := 0;
      jcRec.message := 'Running Stage '||w_stage;
   end if;

   select count(*) into w_total_recs
   from $TABLE where seq > w_start_seq;

   w_chunks := ceil(w_total_recs / w_commit);

  --update the ia_job control stats
   update ia_job_control
   set lastseq = w_start_seq
      ,batch = 0
      ,stage = w_stage 
      ,ofbatches = w_chunks
      ,batchsize = w_commit 
      ,rectotal = w_total_recs 
      ,message = jcRec.message 
      ,stagestatus = jcRec.stagestatus
      ,timestamp = to_char(sysdate,'DD-MM-YYYY HH24:MI:SS')
   where ia_app_id = jcRec.ia_app_id;

   commit;


   For chunk in 1..w_chunks Loop
       update /*+ RULE*/ ${TABLE} a 
       set $COLUMN_NAME = (select house_id 
              from $IA_HOUSE_KEY_TB b 
              where a.$COLUMN_NAME = b.ptcabs)
       where seq > w_start_seq and seq < w_end_seq + 1;

 
        --update the ia_job control stats
        w_chunk := w_chunk + 1;  -- used for reporting
        update ia_job_control
        set lastseq = w_end_seq
           ,timestamp = to_char(sysdate,'DD-MM-YYYY HH24:MI:SS')
           ,batch = w_chunk
        where ia_app_id = jcRec.ia_app_id;
       commit;
 
      w_start_seq := w_end_seq;
      w_end_seq := w_end_seq + w_commit;

   End Loop;


   --update the ia_job control stats
   update ia_job_control
   set stagestatus = 'FINISHED'
       ,message = w_chunk||' of '||w_chunks||' processed'
      ,timestamp = to_char(sysdate,'DD-MM-YYYY HH24:MI:SS')
   where ia_app_id = jcRec.ia_app_id;
   commit;


exception
   When Others Then
      Dbms_Output.Put_Line('last successfull commit seqno:'||w_start_seq);
      Dbms_Output.Put_Line(SqlErrm);
end;
/
!

}


#----------------------------------------------------------------------
# RENAME_TABLE - renames the specified table after processing to
#                indicate new IA house identifies have been assigned
#                Also renames the index
#----------------------------------------------------------------------
Rename_Table ()
{
# rename the table to TABLE_IA to indicate change of
# house identifier system NAMS PTCABS -> new IA PTCABS 

# check if destination table already exists

RETVAL=`DB_run_query_pipe<<!
set feedback off
set pages 0
set heading off
select count(*) from all_tables
where table_name = 'IA_${TABLE}';
!`

TABEXISTS=`echo $RETVAL|awk '{print $1}'`

if [ $TABEXISTS -eq 1 ]; then 
echo "Destination table already exists - now removing"
DB_run_query_pipe<<!
Drop table IA_${TABLE};
!
fi

echo "Renaming table $TABLE to IA_${TABLE}"
echo "Dropping index $IDX_NAME";

DB_run_query_pipe<<!
alter table $TABLE rename to IA_${TABLE};
drop index $IDX_NAME;
!
}


#--------------------------------------------------------------------
# M A I N
#--------------------------------------------------------------------

# need to add in pp2_vars and PP2 error pooling

if [ $# -lt 1 ] 
then
  Usage 
fi


# load PP2 environment vars
. ia_vars.sh


typeset -u TABLE 
typeset -u COLUMN_NAME

TABLE=$1
COLUMN_NAME=$2

# if no $2 supplied - default to HOUSE_ID
if [ -z $COLUMN_NAME ]; then
  COLUMN_NAME=HOUSE_ID
fi


# check if registered with ia_job_control

IA_APP_ID=`Check_App_Reg | awk '{print $1}'`
if [ -z $IA_APP_ID ]; then
   echo "Application $APPNAME does not appear to be registered"
   exit 3
else
   echo "Application Name: $APPNAME - ID: $IA_APP_ID"
fi

# app is registered so we get the jobs status

restart=`Check_Status | awk '{print $1}'`
case $restart in
   ''|1) echo "Starting from Stage 1";
         Verify_Source_Table    # checks if the source table has index on SEQ no
         Generate_IA_House_ID   # generate IA house keys for unregistered PTCABS
         Switch_Identifiers     # update the source table with new IA house keys
         Rename_Table;;         # rename source table to table_IA to indicate
                                # change of PTCABS system

      2) echo "Restarting from Stage 2";
         Verify_Source_Table    # uses same check for index to see if the table exists
         Switch_Identifiers     # update the source table with new IA house keys
         Rename_Table;;         # rename source table to table_IA to indicate 

esac



# --------------------------------------------------------------[END]-
***************
* ia_grant.sh *
***************
DB_run_query_pipe<<!
create public synonym address for ia_address;
create public synonym dim2k for dim2k;
create public synonym dim2k_sample for dim2k_sample;
create public synonym pc_events for load_pc_events;
!

for USER in IA_NORM IA_INSIGHT
do
DB_run_query_pipe<<!
grant select on ia_address     to $USER;
grant select on dim2k          to $USER;
grant select on load_pc_events to $USER;
grant select on dim2k_sample   to $USER;
!
done
---------------------------------------------------------------------------------------
***************
* load_ccj.sh *
***************
#!/bin/ksh
set -x
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : Loads CCJ data, either full file to LOAD_CCJ or 
#               sorted file to CHANGED_CCJ
#
# Called by   : Script Controller Application xyz.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0 " 
   exit 1
}

load ()
{
dcu -t ${TABLE} -ts LOAD_DATA \
	-i ${INPUT} \
	-pc ${IA_TEMPLATES}/${FEED}${COB} \
	-log ${IA_LOG}/${FEED}.log -b ${IA_BAD}/${FEED}.bad \
	-ftype IBM  -sync \
	-stoini 200m -stonxt 50m  -stopcti 0 \
	-opt 'OPTIONS (DIRECT=TRUE)' \
	-stopctf 0 -stopctu 99 \
	-s ${IA_WORKSPACE}/create_${FEED}.sql \
	-l ${IA_WORKSPACE}/ldr_${FEED}.ctl \
	-h ${IA_WORKSPACE}/rec_${FEED} \
	-seqname SEQ -seqsize 7 -seqstart 1 -seqinc 1  
} 

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ] && [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

. ia_vars.sh

FEED=ccj

if [ $# = 1 ] ; then
   COB=.cob
   INPUT=${IA_NEW}/ccj
   TABLE=LOAD_${FEED}
else
   COB=_sorted.cob
   INPUT=ccj
   TABLE=CHANGED_${FEED}
fi

load_start ${FEED}
load
rm -r c.c c.out colinfofile nohup.out
load_end ${FEED}

# ============================[END]==================================
****************
* load_code.sh *
****************
#!/bin/ksh
# =====================================================================
#
# Script Name : load_code.sh
#
# Version     : 1.1 - 04/04/01
#
# Description : Loads CODE data to LOAD_CODE
#               
# Called by   : ia_daemon.sh
#               or can be run stand alone
#
# What Usage  : @(#)load_code.sh	1.1 04/04/01
#
# =====================================================================


/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0 " 
   exit 1
}

load ()
{
dcu -t LOAD_code -ts LOAD_DATA \
	-i ${IA_LOAD}/code \
	-pc ${IA_TEMPLATES}/code.cob \
	-log ${IA_LOG}/${FEED}.log -bad ${IA_BAD}/${FEED}/bad \
	-ftype IBM  -sync \
	-stoini 25m -stonxt 5m   -stopcti 0 \
	-opt 'OPTIONS (DIRECT=TRUE)' \
	-stopctf 0 -stopctu 99  \
   -s ${IA_WORKSPACE}/create_${FEED}.sql \
   -l ${IA_WORKSPACE}/ldr_${FEED}.ctl \
   -h ${IA_WORKSPACE}/rec_${FEED}
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

. ia_vars.sh

FEED=code ; export FEED
${IA_BIN}/ia_reports.sh INIT
load_start code
load
load_end   code
rm -r c.c c.out colinfofile nohup.out

${IA_BIN}/ia_reports.sh END
# ============================[END]==================================
********************
* load_coldlist.sh *
********************
#!/bin/ksh

##
# Adding customer's cold list to the database
##

log()
{
  echo "$(date +%Y-%m-%d-%H:%M:%S): "$* | tee -a ${IA_HOME}/log/$(basename $0)".$$" 2>/dev/null
}


error_chk(){

ES=$1
MOD=$2

if [[ $ES != "0" ]]
then
    log "*****************************************"
    log "$MOD : Failed"
    log "*****************************************"
    exit 1
else
    log "*****************************************"
    log "$MOD : Finished Successfully"
    log "*****************************************"
fi
}

drop_table()
{

TABLE=$1

DB_run_query_pipe<<!
whenever sqlerror exit sql.sqlcode
drop table ${TABLE};
exit sql.sqlcode
!
error_chk $? drop_table
}


create_LIST_INFO()
{
log "*** Creating table LIST_INFO ..."
if DB_object_not_exists list_info; then
   log "*** table list_info not exists, creating ..."

   DB_run_query_pipe <<!
   whenever sqlerror exit sql.sqlcode
   Prompt creating table list_info ...
   CREATE TABLE LIST_INFO ( 
   list_name varchar2(30),
   start_date date,
   end_date date)
   TABLESPACE USERS
   PCTFREE 0   PCTUSED 99
   INITRANS 1   MAXTRANS 255
   STORAGE ( 
   INITIAL 10M NEXT 10M PCTINCREASE 0
   MINEXTENTS 1 MAXEXTENTS 1017 )
   NOCACHE; 
   exit sql.sqlcode;
!
   error_chk $? "creating table list_info"
else
   log "*** table exists not creating ..."
fi
}


usage()
{
   log "I need two parameters"
   log "Usage: $(basename $0) <<Name of List>> <<File Location>>"
   exit 1
}


##
# check that the name of the list is not already on the 
# LIST_INFO table, error if it is
##
chk_list()
{
#set -x
LISTNAME=$1

log "*** checking listname exists on table list_info ..."
SQL_RET=`DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
set heading off
set pages 0
select list_name from list_info
where list_name='${LISTNAME}';
exit sql.sqlcode;
!`
error_chk $? "selecting list_name from list_info"
CHK=$(echo $SQL_RET | awk '{print $1}')

if [ "${CHK}" = "no" ]; then
  log "${LISTNAME} not exists on LIST_INFO ..."
else
  log "${LISTNAME} already on database"
  log "aborting program ..."
  exit 2
fi
}


##
# Check to see if the file is in the specified location
##
chk_file()
{
FILE_NAME=$1
DIR=$2
log "*** Checking file existence..."
if [[ ! -f ${DIR}/${FILE_NAME} ]]
then
    log "*** ${FILE_NAME} is not in location ${DIR} "
    log "aborting program ..."
    exit 3
else
    log "${FILE_NAME} exists ..."
fi
}


##
# Check for the record length
##
chk_record_length()
{

FILE_NAME=$1
DIR=$2
RECLENGTH=333

log "*** Checking file record length ..."
LINES=$(wc -l < ${DIR}/${FILE_NAME} | awk '{print $1}')

ls -l ${DIR} | grep ${FILE_NAME} | while read line
do
   NAME=$(echo $line | awk '{print $NF}')
   if [ "${NAME}" = "${FILE_NAME}" ]; then
       SIZE=$(echo $line | awk '{print $5}')
       CHK=$(expr ${SIZE} / ${RECLENGTH})
       if [[ ${CHK} != ${LINES} ]]; then
          log "Record length is not as per spec"
          log "Aborting program ..."
          exit 5
       else
          log "Record length check OK ..."
       fi
   fi
done
}


update_FILE_INFO_table()
{
log "*** checking for existenece on  table FILE_INFO ..."
SQL_RET=`DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
set heading off
set pages 0
select client_code from file_info
where client_code='COLD';
exit sql.sqlcode;
!`
error_chk $? "selecting client_code COLD from FILE_INFO"
CHK=$(echo $SQL_RET | awk '{print $1}')

if [ "${CHK}" = "no" ]; then
   log "*** updating table FILE_INFO ..."
   DB_run_query_pipe <<!
   whenever sqlerror exit sql.sqlcode
   insert into FILE_INFO values ('COLD', 'Cold List Load', 332, 'U');
   exit sql.sqlcode
!
   error_chk $? "updating table FILE_INFO"
else
  log "*** Client_code COLD already on database"
#  log "Aborting program ..."
#  exit 6
fi
}


update_FILE_DETAILS_table()
{
log "*** checking for existenece on  table FILE_DETAILS ..."
SQL_RET=`DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
set heading off
set pages 0
select client_code from file_details
where client_code='COLD';
exit sql.sqlcode;
!`
error_chk $? "selecting client_code COLD from FILE_DETAILS"
CHK=$(echo $SQL_RET | awk '{print $1}')

if [ "${CHK}" = "no" ]; then
log "*** updating table FILE_DETAILS ..."
DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
insert into FILE_DETAILS values ('COLD', 'TITLE', 'D', 10, 1);
insert into FILE_DETAILS values ('COLD', 'FORENAME', 'D', 20, 11);
insert into FILE_DETAILS values ('COLD', 'SECOND_INITIAL', 'D', 4, 31);
insert into FILE_DETAILS values ('COLD', 'SURNAME', 'N', 30, 35);
insert into FILE_DETAILS values ('COLD', 'ADDR1', 'A', 40, 65);
insert into FILE_DETAILS values ('COLD', 'ADDR2', 'A', 40, 105);
insert into FILE_DETAILS values ('COLD', 'ADDR3', 'A', 40, 145);
insert into FILE_DETAILS values ('COLD', 'ADDR4', 'A', 40, 185);
insert into FILE_DETAILS values ('COLD', 'ADDR5', 'A', 40, 225);
insert into FILE_DETAILS values ('COLD', 'POSTCODE', 'P', 8, 265);
insert into FILE_DETAILS values ('COLD', 'USER_DEFINED_1', 'D', 30, 273);
insert into FILE_DETAILS values ('COLD', 'USER_DEFINED_2', 'D', 30, 303);
exit sql.sqlcode
!
error_chk $? "updating table FILE_INFO"
else 
   log "*** Client_code COLD already exists,  not updating details ..."
fi
}


##
# Rename the table after it has gone through the NAMS routine
# and then add the following columns SALACIOUS, FOREIGN, BUSINESS
# to that table.
##
rename_table()
{
TABLENAME=$1

log "**** Check for existence table ..."
if DB_object_exists ${TABLENAME}; then
DB_run_query_pipe <<!
Prompt dropping table ${TABLENAME} ...
whenever sqlerror exit sql.sqlcode
drop table ${TABLENAME};
!
fi

log "*** Renaming table CLIENT_LOAD_COLD to ${TABLENAME} "
DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
rename CLIENT_LOAD_COLD to ${TABLENAME};
exit sql.sqlcode;
!
}


add_columns()
{
TABLENAME=$1
log "*** Adding Salacious, Foreign, Business columns to LIST_INFO"
if [[ "$(uname -n)" = "athena" ]]; then
DB_run_query_pipe <<!
    whenever sqlerror exit sql.sqlcode
    alter table ${TABLENAME}
    add (
    SALACIOUS varchar2(1),
    FOREIGN   varchar2(1),
    BUSINESS  varchar2(1),
    GENDER    varchar2(1));
    exit sql.sqlcode;
!
else
DB_run_query_pipe <<!
    whenever sqlerror exit sql.sqlcode
    alter table ${TABLENAME}
    add (
    SALACIOUS varchar2(1),
    FOREIGN   varchar2(1),
    BUSINESS  varchar2(1));
    exit sql.sqlcode;
!
fi
}

##
# Add an entry to table LIST_INFO
##
add_entry()
{
LISTNAME=$1
log "*** Add an entry into LIST_INFO ..."

SQL_RET=`DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
set heading off
set pages 0
select LIST_NAME from LIST_INFO
where LIST_NAME='${LISTNAME}';
exit sql.sqlcode;
!`
error_chk $? "Check for ${LISTNAME} existence"
CHK=$(echo $SQL_RET | awk '{print $1}')

if [ "${CHK}" = "no" ]; then
   log "*** updating table LIST_INFO ... "
   DB_run_query_pipe <<!
   whenever sqlerror exit sql.sqlcode
   insert into LIST_INFO values ('${LISTNAME}', sysdate, NULL);
   exit sql.sqlcode;
!
   error_chk $? "insert entry into LIST_INFO"
else
  log "*** ${LISTNAME} already on database"
fi
}

##
# This routine is for testing purposes
# for TYPE_A matching
##
title_to_gender()
{
TABLE=$1

DB_run_query_pipe <<!
create or replace function title_to_gender (title varchar2)
return varchar2
as
begin
   if upper(title) in ('MR') then return 'M';
   elsif upper(title) in ('MRS','MISS','MS') then return 'F';
   else return ' ';
   end if;
end;
!

DB_run_query_pipe <<! 
whenever sqlerror exit sql.sqlcode
set heading off
set feedback off
set pages 0
update ia_${TABLE}
set gender = title_to_gender(title);
!
}


##
# run through salacious routine
##
run_salacious()
{
TABLE=${1}

log "*** Invoking Salacious routine ..."
${IA_SHELL}/proc/salacious.sh ${TABLE} SEQ "FORENAME||SECOND_INITIAL||SURNAME||' '||FORENAME||' '||SURNAME" SALACIOUS
}


##
# run through foreign routine
##
run_foreign()
{
TABLE=$1

log "**** Invoking Foreign routine ... "
${IA_SHELL}/proc/abroad.sh ${TABLE} SEQ "addr1||' '||addr2||' '||addr3||' '||addr4||' '||addr5||' '||postcode" FOREIGN
}


##
# run through business routine
##
run_business()
{
TABLE=$1
ID_COLUMN=$2
SEARCHSTR=$3
POSTCODE_COL=$4
UPDATE_COL=$5

log "**** Invoking Business routine ... "
${IA_SHELL}/proc/business.sh ${TABLE} SEQ "addr1||' '||addr2||' '||addr3||' '||addr4||' '||addr5 postcode" business
}


##
# Main
##
#set -x

if [[ $# != 2 ]]; then
   log "******* Error: wrong parameter passed "
   usage
fi

FILE_NAME=$1
LOCATION=$2

if [[ $(uname -n) = "athena" ]]
then
    . $HOME/dev/bin/ia_vars.sh
else
    . $HOME/prod/bin/ia_vars.sh
fi


##
# check that the name of the list is not already
# on the LIST_INFO table
##
chk_list ${FILE_NAME}

##
# Check to see if the file is in the specified location
##
chk_file ${FILE_NAME} ${LOCATION}

##
# Check the file record
##
chk_record_length ${FILE_NAME} ${LOCATION}

##
# creating the table LIST_INFO
##
create_LIST_INFO

##
# Inserting standard layout to FILE_INFO
##
update_FILE_INFO_table

##
# Inserting field details into table FILE_DETAILS
##
update_FILE_DETAILS_table

##
# Run the NAMS routing ...
## 
#set -x
log "***** Invoking nams routing ..."
if [[ "$(uname -n)" = "athena" ]]
then
    #${IA_SHELL}/namscontrol/nams.sh $HOME/dev COLD ${LOCATION}/${FILE_NAME}
    ${IA_SHELL}/namscontrol/nams.sh $HOME/dev COLD ${FILE_NAME}
    error_chk $? nams.sh
else
    # ${IA_SHELL}/namscontrol/nams.sh $HOME/prod COLD ${LOCATION}/${FILE_NAME}
    ${IA_SHELL}/namscontrol/nams.sh $HOME/prod COLD ${FILE_NAME}
    error_chk $? nams.sh
fi

##
# Rename table 
##
rename_table ${FILE_NAME}
error_chk $? rename_table

##
# and add columns Salacious, Foreign, Business
##
add_columns ${FILE_NAME}
error_chk $? add_columns

##
# Run the newly created table through Jari's HOUSE_KEYS swapping routine
# NB After Jari's routine the table will be renamed to IA_"TABLENAME"
##
log "**** Invoking HOUSE_KEYS routine "
if [[ "$(uname -n)" = "athena" ]]
then
    ${IA_SHELL}/house_keys/diep_test_run.sh ${HOME}/dev/ ${FILE_NAME} HOUSE_ID
    error_chk $? "Jari's routine"
else
    ${IA_SHELL}/house_keys/diep_test_run.sh ${HOME}/prod/ ${FILE_NAME} HOUSE_ID
fi


if [[ "$(uname -n)" = "athena" ]]; then
   title_to_gender ${FILE_NAME}
fi

##
# Run type A matching routine
##
log "**** Invoking type_A matching ..."
${IA_SHELL}/resolve/type_a.sh IA_${FILE_NAME}
error_chk $? "TYPE A routine"


##
# Add an entry to table LIST_INFO
##
add_entry ${FILE_NAME}
error_chk $? "add entry"

##
# run the salacious routine
##
run_salacious "IA_"${FILE_NAME} 
error_chk $? run_salacious


##
# run through foreign routine
##
run_foreign IA_${FILE_NAME} 
error_chk $? run_foreign


##
# run through business routine
##
log "**** Invoking Business routine ..."
run_business "IA_${FILE_NAME}" 
error_chk $? run_business
---------------------------------------------------------------------------------------------------------------
**********************
* load_complaints.sh *
**********************
#!/bin/ksh
# =====================================================================
#
# Script Name : load_complaints.sh
#
# Version     : 1.3 - 03/30/01
#
# Description : Loads Complaints data to LOAD_COMPLAINTS table
#               Data must reside in $IA_LOAD
#
# Called by   : Script Controller Application run_complaints.sh /
#               or can be run stand alone
#
# What Usage  : @(#)load_complaints.sh	1.3 03/30/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  "
   exit 1
}

fixed_block ()
{
	filename=${IA_LOAD}/complaints
	cat ${filename} | tr -d "
"| awk '{printf "%-80s\n",$0}' > ${filename}.out
}

load ()
{
dcu -t LOAD_${FILE} -ts LOAD_DATA \
	-i ${IA_LOAD}/${FILE} \
	-pc ${IA_TEMPLATES}/${FILE}.cob \
	-log ${IA_LOG}/${FILE}.log -b ${IA_BAD}/${FILE}.bad \
	-ftype IBM  -sync \
	-stoini 200K -stonxt 50K  -stopcti 0 \
	-opt 'OPTIONS (DIRECT=TRUE)' \
	-stopctf 0 -stopctu 99 \
	-s ${IA_WORKSPACE}/create_${FILE}.sql \
	-l ${IA_WORKSPACE}/ldr_${FILE}.ctl \
	-h ${IA_WORKSPACE}/rec_${FILE} \
	-seqname SEQ -seqsize 6 -seqstart 1 -seqinc 1
} 

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

####################
# Set up standard variables

. ia_vars.sh

FILE=complaints
#fixed_block
load_start ${FILE}
load
load_end ${FILE}

rm -r colinfofile c.c c.out nohup.out 2>/dev/null

# ============================[END]==================================
********************
* load_deceased.sh *
********************
#!/bin/ksh
# =====================================================================
#
# Script Name : load_deceased.sh
#
# Version     : 1.4 - 04/10/01
#
# Description : Loads Deceased data to LOAD_DECEASED table.
#               
#
# Called by   : Script Controller Application run_deceased.sh /
#               or can be run stand alone
#
# What Usage  : @(#)load_deceased.sh	1.4 04/10/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  "
   exit 1
}

load ()
{
dcu -t LOAD_DECEASED -ts LOAD_DATA \
	-i ${IA_LOAD}/${FILE} \
	-pc ${IA_TEMPLATES}/${FILE}.cob \
	-log ${IA_LOG}/${FILE}.log -b ${IA_BAD}/${FILE}.bad \
	-ftype IBM  -sync \
	-stoini 25m -stonxt 5m  -stopcti 0 \
	-opt 'OPTIONS (DIRECT=TRUE)' \
	-stopctf 0 -stopctu 99 \
	-s ${IA_WORKSPACE}/create_${FILE}.sql \
	-l ${IA_WORKSPACE}/ldr_${FILE}.ctl \
	-h ${IA_WORKSPACE}/rec_${FILE} \
	-seqname SEQ -seqsize 7 -seqstart 1 -seqinc 1
} 

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

. ia_vars.sh

FILE=deceased
load_start ${FILE}
load
rm -r colinfofile c.c c.out nohup.out 2>/dev/null
load_end ${FILE}
# ============================[END]==================================
*****************
* load_dim2k.sh *
*****************
#!/usr/bin/ksh
#set -x


Usage ()
{
   /usr/bin/echo "Usage : $0  ia_home"
   exit 1
}

load ()
{
STARTSEQ=$1

time dcu -t ${FEED} -ts DIM2K \
        -i ${IA_HOME}/dim2k/dim${NUM} \
        -pc ${IA_TEMPLATES}/${FEED}.cob \
        -log ${IA_LOG}/${FEED}.log -b ${IA_BAD}/${FEED}.bad \
        -ftype IBM  -sync \
        -stoini 100m -stonxt 100m  -stopcti 0 \
        -opt 'OPTIONS (DIRECT=TRUE)' \
        -stopctf 0 -stopctu 99 \
        -s ${IA_WORKSPACE}/create_${FEED}.sql \
        -l ${IA_WORKSPACE}/ldr_${FEED}.ctl \
        -h ${IA_WORKSPACE}/rec_${FEED} \
        -seqname SEQ -seqsize 11 -seqstart ${STARTSEQ} -seqinc 1 ${APPEND} \
		-sqlchg ${IA_SHELL}/dim2k/MY  
echo "Number is ${NUM}, START ${STARTSEQ}"
} 

get_seq()
{
#set -x
INFILE=$1

if [[ $(uname -n) = "athena" ]]; then
   REC_LEN=348
else
   REC_LEN=344
fi


line=$(ls -ltr /workspace01/ia/dims/${INFILE} )
SIZE=$(echo $line | awk '{print $5}')
SEQNUM=$(expr $SIZE / $REC_LEN)
echo $SEQNUM
}

loading()
{
#set -x
FEED=dim2k ; export FEED

SEQNO=1
for NUM in 1 2 3 4 5 6 7 8 9
do
   if [ ${NUM} = 1 ]; then
      APPEND=""
      STARTSEQ=$SEQNO
	   cd $HOME/prod/dim2k
 	   pkunzip dim${NUM}.zip
      RECSIZE=$(get_seq dim${NUM})
	   load_start ${FEED}
	   load $STARTSEQ
	   load_end ${FEED}
   else
      APPEND="-append"
      STARTSEQ=$SEQNO
	   cd $HOME/prod/dim2k
 	   pkunzip dim${NUM}.zip
      RECSIZE=$(get_seq dim${NUM})
	   load_start ${FEED}
	   load $STARTSEQ
	   load_end ${FEED}
	   rm dim${NUM}
   fi
   SEQNO=`expr $SEQNO + $RECSIZE`
done
}

##
# main
##

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

if [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of paramters passed."
   usage
fi

# Set up standard variables
IA_HOME=$1
. ${IA_HOME}/bin/ia_vars.sh

loading
----------------------------------------------------------------------------------------------
*****************
* load_house.sh *
*****************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : Loads House data to LOAD_HOUSE. used to create ADDRESS
#               
#
# Called by   : ia_daemon.sh
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0"
   exit 1
}

load ()
{
dcu -t LOAD_HOUSE -ts LOAD_DATA \
	-i ${IA_LOAD}/house \
	-pc ${IA_TEMPLATES}/${FILE}.cob \
	-log ${IA_LOG}/${FILE}.log -bad ${IA_BAD}/${FILE}.bad \
	-ftype IBM  -sync \
	-stoini 200m -stonxt 50m  -stopcti 0 \
	-opt 'OPTIONS (DIRECT=TRUE)' \
	-stopctf 0 -stopctu 99 \
	-s ${IA_WORKSPACE}/create_${FILE}.sql \
   -l ${IA_WORKSPACE}/ldr_${FILE}.ctl \
   -h ${IA_WORKSPACE}/rec_${FILE}
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

. ia_vars.sh

FILE=house
${IA_BIN}/ia_reports.sh INIT
load_start ${FILE}
load
load_end   ${FILE}

rm -r c.c c.out colinfofile nohup.out >/dev/null
${IA_BIN}/ia_reports.sh END
# ============================[END]==================================
*******************
* load_insight.sh *
*******************
#!/bin/ksh
set -x
# =====================================================================
#
# Script Name : %M% 
#
# Version     : %I% - %G%
#
# Description : Loads INSIGHT data to either LOAD_INSIGHT (for full data)
#               or CHANGED_INSIGHT (for file containing types)
#
# Called by   : Script Controller Application xyz.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  type (full/partial)"
   exit 1
}

load ()
{
dcu -t ${TABLE} -ts LOAD_DATA \
	-i ${INPUT} \
	-pc ${IA_TEMPLATES}/${FILE}${COB} \
	-log ${IA_LOG}/${FILE}.log -b ${IA_BAD}/${FILE}.bad \
	-ftype IBM  -sync \
	-stoini 100m -stonxt 100m  -stopcti 0 \
	-opt 'OPTIONS (DIRECT=TRUE)' \
	-stopctf 0 -stopctu 99 \
	-s ${IA_WORKSPACE}/create_${FILE}.sql \
	-l ${IA_WORKSPACE}/ldr_${FILE}.ctl \
	-h ${IA_WORKSPACE}/rec_${FILE} \
	-seqname SEQ -seqsize 8 -seqstart 1 -seqinc 1 -append
} 

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------


if [ $# != 1 ] && [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

# Set up standard variables

. ia_vars.sh

FILE=insight
if [ $# = 1 ] ; then
   COB=.cob
   INPUT=${IA_NEW}/${FILE}
   TABLE=LOAD_${FILE}
else 
   COB=_sorted.cob
   INPUT=insight
   TABLE=CHANGED_${FILE}
fi
load_start ${FILE}
load
rm -r c.c c.out nohup.out colinfofile 2>/dev/null
load_end ${FILE}

# ============================[END]==================================
***************
* load_mov.sh *
***************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : 
#               
#
# Called by   : Script Controller Application xyz.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  mover/movin
\tfile     - name of file (mover or movin)"
   exit 1
}

load ()
{
dcu -t ${TABLE} -ts LOAD_DATA \
	-i ${INPUT} \
	-pc ${IA_TEMPLATES}/${FILE}${COB} \
	-log ${IA_LOG}/${FILE}.log -b ${IA_BAD}/${FILE}.bad \
	-ftype IBM  -sync \
	-stoini 100m -stonxt 20m  -stopcti 0 \
	-opt 'OPTIONS (DIRECT=TRUE)' \
	-stopctf 0 -stopctu 99 \
	-s ${IA_WORKSPACE}/create_${FILE}.sql \
	-l ${IA_WORKSPACE}/ldr_${FILE}.ctl \
	-h ${IA_WORKSPACE}/rec_${FILE}  \
	-seqstart 1 -seqname SEQ -seqstart 1 -seqinc 1 -reclim 10000
} 
# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 2 ] && [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

# Set up standard variables

. ia_vars.sh

TYPE=`echo $1 | tr '[A-Z]' '[a-z]'`
if [ ${TYPE} != 'mover' ] && [ ${TYPE} != 'movin' ] ; then
        echo "Must pass mover or movin."
        usage
else
        FILE=${TYPE}
fi

if [ $# = 2 ] ; then
	COB=.cob
	INPUT=${IA_NEW}/${FILE}
	TABLE=LOAD_${FILE}
else
	COB=_sorted.cob
	INPUT=${FILE}
	TABLE=CHANGED_${FILE}
fi

load_start ${FILE}
load
rm -r c.c c.out colinfofile nohup.out
load_end ${FILE}

# ============================[END]==================================
***************
* load_mps.sh *
***************
#!/bin/ksh
# =====================================================================
#
# Script Name : load_mps.sh
#
# Version     : 1.1 - 04/02/01
#
# Description : Loads data to table LOAD_MPS
#               
#
# Called by   : Script Controller Application run_mps.sh /
#               or can be run stand alone
#
# What Usage  : @(#)load_mps.sh	1.1 04/02/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0"
   exit 1
}

load ()
{
dcu -t LOAD_MPS -ts LOAD_DATA \
	-i ${IA_LOAD}/${FILE} \
	-pc ${IA_TEMPLATES}/mps.cob \
	-log ${IA_LOG}/mps.log -b ${IA_BAD}/mps.bad \
	-ftype IBM  -sync \
	-stoini 20m -stonxt 10m  -stopcti 0 \
	-opt 'OPTIONS (DIRECT=TRUE)' \
	-stopctf 0 -stopctu 99 \
	-s ${IA_WORKSPACE}/create_${FILE}.sql \
	-l ${IA_WORKSPACE}/ldr_${FILE}.ctl \
	-h ${IA_WORKSPACE}/rec_${FILE} \
	-seqname SEQ -seqsize 7 -seqstart 1 -seqinc 1
} 

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

# Set up standard variables

. ia_vars.sh

FILE=mps
load_start ${FILE}
load
load_end ${FILE}

rm -r c.c c.out colinfofile nohup.out 2>/dev/null

# ============================[END]==================================
***************
* load_paf.sh *
***************
#!/bin/ksh
# =====================================================================
#
# Script Name : load_paf.sh
#
# Version     : 1.1 - 04/04/01
#
# Description : Loads PAF Feedback information
#               
#
# Called by   : ia_daemon.sh
#               or can be run stand alone
#
# What Usage  : @(#)load_paf.sh	1.1 04/04/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"
usage ()
{
   /usr/bin/echo "Usage : $0"
   exit 1
}

load ()
{
dcu -t ${FEED} -ts LOAD_DATA \
        -i ${IA_LOAD}/paf \
        -pc ${IA_TEMPLATES}/${FEED}.cob \
        -log ${IA_LOG}/${FEED}.log -b ${IA_BAD}/${FEED}.bad \
        -ftype IBM  -sync \
        -stoini 60m -stonxt 10m  -stopcti 0 \
        -opt 'OPTIONS (DIRECT=TRUE)' \
        -stopctf 0 -stopctu 99 \
        -s ${IA_WORKSPACE}/create_${FEED}.sql \
        -l ${IA_WORKSPACE}/ldr_${FEED}.ctl \
        -h ${IA_WORKSPACE}/rec_${FEED} 
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

. ia_vars.sh

FEED=paf  ; export FEED
${IA_BIN}/ia_reports.sh INIT
load_start ${FEED}
load
load_end   ${FEED}
rm -r c.c c.out colinfofile nohup.out
${IA_BIN}/ia_reports.sh END

# ============================[END]==================================
*********************
* load_pc_events.sh *
*********************
#!/bin/ksh
# =====================================================================
#
# Script Name : load_pc_events.sh 
#
# Version     : 1.2 - 04/10/01
#
# Description : Loads the Postcode events data
#               
#
# Called by   : Run stand alone
#               
#
# What Usage  : @(#)load_pc_events.sh	1.2 04/10/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0 "
   exit 1
}

load ()
{
dcu -t LOAD_${FEED} -ts PC_EVENTS \
        -i ${IA_LOAD}/pc_events \
        -pc ${IA_TEMPLATES}/${FEED}.cob \
        -log ${IA_LOG}/${FEED}.log -b ${IA_BAD}/${FEED}.bad \
        -ftype IBM  -sync \
        -stoini 500m -stonxt 50m  -stopcti 0 \
        -opt 'OPTIONS (DIRECT=TRUE)' \
        -stopctf 0 -stopctu 99 \
        -s ${IA_WORKSPACE}/create_${FEED}.sql \
        -l ${IA_WORKSPACE}/ldr_${FEED}.ctl \
        -h ${IA_WORKSPACE}/rec_${FEED} \
        -seqname SEQ -seqsize 7 -seqstart 1 -seqinc 1 
} 

create_index ()
{
DB_run_query_pipe<<!
Create index PC_EVENTS_I on LOAD_PC_EVENTS (POSTCODE)
tablespace PC_EVENTS
storage (initial 50m next 50m pctincrease 0) pctfree 0 nologging;
!
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------


if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

# Set up standard variables

. ia_vars.sh 

FEED=pc_events ; export FEED
${IA_BIN}/ia_reports.sh INIT 
load_start ${FEED}
load
load_end ${FEED}
rm -r c.c c.out colinfofile nohup.out 2>/dev/null
create_index 
${IA_BIN}/ia_reports.sh END
# ============================[END]==================================
****************
* load_town.sh *
****************
#!/bin/ksh
# =====================================================================
#
# Script Name : load_town.sh
#
# Version     : 1.1 - 04/04/01
#
# Description : Loads town data to LOAD_TOWN
#               
#
# Called by   : ia_daemon.sh
#               or can be run stand alone
#
# What Usage  : @(#)load_town.sh	1.1 04/04/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0"
   exit 1
}

load ()
{
dcu -t LOAD_${FEED} -ts LOAD_DATA \
	-i ${IA_LOAD}/town \
	-pc ${IA_TEMPLATES}/${FEED}.cob \
	-log ${IA_LOG}/${FEED}.log -b ${IA_BAD}/${FEED}.bad \
	-ftype IBM  -sync \
	-stoini 70K -stonxt 50K  -stopcti 0 \
	-opt 'OPTIONS (DIRECT=TRUE)' \
	-stopctf 0 -stopctu 99 \
	-s ${IA_WORKSPACE}/create_${FEED}.sql \
	-l ${IA_WORKSPACE}/ldr_${FEED}.ctl \
	-h ${IA_WORKSPACE}/rec_${FEED} 
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

# Set up standard variables

FEED=town ; export FEED
. ia_vars.sh

${IA_BIN}/ia_reports.sh INIT
load_start ${FEED}
load
rm -r c.c c.out colinfofile nohup.out >/dev/null
load_end   ${FEED}
${IA_BIN}/ia_reports.sh END 

# ============================[END]==================================
***************
* load_tps.sh *
***************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : 
#               
#
# Called by   : Script Controller Application xyz.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  load_type"
   exit 1
}

load ()
{
dcu -t ${TABLE} -ts LOAD_DATA \
	-i ${INPUT} \
	-pc ${IA_TEMPLATES}/${FILE}${COB} \
	-log ${IA_LOG}/${FILE}.log -b ${IA_BAD}/${FILE}.bad \
	-ftype IBM  -sync \
	-stoini 150m -stonxt 50m  -stopcti 0 \
	-opt 'OPTIONS (DIRECT=TRUE)' \
	-stopctf 0 -stopctu 99 \
	-s ${IA_WORKSPACE}/create_${FILE}.sql \
	-l ${IA_WORKSPACE}/ldr_${FILE}.ctl \
	-h ${IA_WORKSPACE}/rec_${FILE}   \
	-seqname  SEQ -seqstart 1 -seqinc 1 -seqsize 9
} 
# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ]  && [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi


. ia_vars.sh

FILE=tps
if [ $# = 1 ] ; then
   COB=.cob
   INPUT=${IA_NEW}/tps
   TABLE=LOAD_${FILE}
else
   COB=_sorted.cob
   INPUT=tps 
   TABLE=CHANGED_${FILE}
fi
load_start ${FILE}
load
rm -r c.c c.out colinfofile nohup.out >/dev/null
load_end   ${FILE}

# ============================[END]==================================
****************
* match_ccj.sh *
****************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : Matches CCJ data
#               
#
# Called by   : Script Controller Application run_ccj.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  "
   exit 1
}

join_resolve_output ()
{
SOURCE=$1
# Joins output from Resolve back to original data

	if DB_object_exists MATCHED_CCJ_1 ; then
		DB_run_query 'drop table MATCHED_CCJ_1;'
	fi

	if DB_object_exists MATCHED_CCJ ; then
		DB_run_query 'rename MATCHED_CCJ to MATCHED_CCJ_1;'
	fi

	if [ $# != 1 ] ; then
		echo "join_resolve_output needs a parameter."
		exit 1
	else
		if DB_object_not_exists $1 ; then
			echo "Table $1 does not exist."
			exit 2
		fi
	fi


	if [ ${SOURCE} = 'CHANGED_CCJ' ] ; then
		COLS=",MULTIPLIER,TYPE"
	fi
	DB_run_query_pipe<<!
	whenever sqlerror exit failure
	Prompt Joining INPUT_XREF to ${SOURCE}...
	create table  MATCHED_CCJ 
	tablespace INPUT_SUPPRESSIONS
	storage (initial 5m next 5m pctincrease 0) 
	pctfree 0 pctused 99 nologging 
	as
	select ID
	,decode(sign(months_between(sysdate,to_date(lpad(court_date,5,'0'),'RRDDD'))/06-1),1,0,-1,1) CCJ_6 
	,decode(sign(months_between(sysdate,to_date(lpad(court_date,5,'0'),'RRDDD'))/12-1),1,0,-1,1) CCJ_12
	,decode(sign(months_between(sysdate,to_date(lpad(court_date,5,'0'),'RRDDD'))/24-1),1,0,-1,1) CCJ_24
	,decode(sign(months_between(sysdate,to_date(lpad(court_date,5,'0'),'RRDDD'))/36-1),1,0,-1,1) CCJ_36
	,decode(sign(months_between(sysdate,to_date(lpad(court_date,5,'0'),'RRDDD'))/72-1),1,0,-1,1) CCJ_72
	,COURT_DATE,MATCH_LEVEL${COLS}
	from INPUT_XREF x, ${SOURCE} s
	where s.SEQ = x.SEQ;
!

if DB_object_exists CCJ ; then
   DB_run_query_pipe<<!
   drop table CCJ;
!
fi
}

create_sum ()
{
DB_run_query_pipe<<!
whenever sqlerror exit failure
create table SUM_MATCHED_CCJ
tablespace INPUT_SUPPRESSIONS
storage (initial 5m next 5m pctincrease 0)
pctfree 0 pctused 99
nologging as
select id
,sum(ccj_6 ) ccj_6
,sum(ccj_12) ccj_12
,sum(ccj_24) ccj_24
,sum(ccj_36) ccj_36 
,sum(ccj_72) ccj_72
,match_level
from
(select id,ccj_6,ccj_12,ccj_24,ccj_36,ccj_72,match_level from matched_ccj_1
union all
select id
,ccj_6 *multiplier
,ccj_12*multiplier
,ccj_24*multiplier
,ccj_36*multiplier
,ccj_72*multiplier
,match_level from matched_ccj)
group by id,match_level
;
!
if [ $? != 0 ] ; then
	echo "Error somewhere"
	exit 5
else
	DB_run_query 'drop table matched_ccj_1;'
	DB_run_query 'rename matched_ccj to matched_ccj_1;'
	DB_run_query 'rename sum_matched_ccj to matched_ccj;'
	create_ccj
fi
}


create_ccj()
{
DB_run_query_pipe<<!
create table CCJ
tablespace INPUT_SUPPRESSIONS
storage (initial 10m next 10m pctincrease 0)
pctused 99 pctfree 0 nologging 
as
select id
,sum(ccj_6 * decode(MATCH_LEVEL,'H',1,0)) H_ccj_6 
,sum(ccj_12* decode(MATCH_LEVEL,'H',1,0)) H_ccj_12
,sum(ccj_24* decode(MATCH_LEVEL,'H',1,0)) H_ccj_24
,sum(ccj_36* decode(MATCH_LEVEL,'H',1,0)) H_ccj_36
,sum(ccj_72* decode(MATCH_LEVEL,'H',1,0)) H_ccj_72
,sum(ccj_6 * decode(MATCH_LEVEL,'F',1,0)) F_ccj_6
,sum(ccj_12* decode(MATCH_LEVEL,'F',1,0)) F_ccj_12
,sum(ccj_24* decode(MATCH_LEVEL,'F',1,0)) F_ccj_24
,sum(ccj_36* decode(MATCH_LEVEL,'F',1,0)) F_ccj_36
,sum(ccj_72* decode(MATCH_LEVEL,'F',1,0)) F_ccj_72
,sum(ccj_6 * decode(MATCH_LEVEL,'S',1,0)) S_ccj_6
,sum(ccj_12* decode(MATCH_LEVEL,'S',1,0)) S_ccj_12
,sum(ccj_24* decode(MATCH_LEVEL,'S',1,0)) S_ccj_24
,sum(ccj_36* decode(MATCH_LEVEL,'S',1,0)) S_ccj_36
,sum(ccj_72* decode(MATCH_LEVEL,'S',1,0)) S_ccj_72
from MATCHED_CCJ
group by id
;
!
}



# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 1 ] && [ $# != 2 ] ; then
   /usr/bin/echo "Wrong number of parameters passed ($#)"
   usage
fi

set -x
. ia_vars.sh

PEOPLE=$1

if [ $# = 2 ] ; then
	${IA_RESOLVE}/type_b.sh ${PEOPLE} IA_LOAD_CCJ
	join_resolve_output IA_LOAD_CCJ
	DB_run_query 'rename IA_LOAD_CCJ to ALL_CCJ;'
	create_ccj
else
	${IA_RESOLVE}/type_b.sh ${PEOPLE} IA_CHANGED_CCJ
	join_resolve_output IA_CHANGED_CCJ
	create_sum 
fi
# ============================[END]==================================
***********************
* match_complaints.sh *
***********************
#!/bin/ksh
# =====================================================================
#
# Script Name : match_complaints.sh
#
# Version     : 1.4 - 03/30/01
#
# Description : Matches complaint data
#               
#
# Called by   : Script Controller Application run_complaints.sh /
#               or can be run stand alone
#
# What Usage  : @(#)match_complaints.sh	1.4 03/30/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  people_table"
   exit 1
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of parameters passed ($#)"
   usage
fi

# Set up standard variables

. ia_vars.sh

PEOPLE=$1
if DB_object_not_exists ${PEOPLE} ; then
	echo "Table ${PEOPLE} does not exist"
	exit 2
fi

${IA_RESOLVE}/type_b.sh ${PEOPLE} IA_LOAD_COMPLAINTS

if DB_object_exists COMPLAINTS ; then
	DB_run_query 'drop table COMPLAINTS;'
fi

DB_run_query_pipe<<!
whenever sqlerror exit failure
Prompt Creating final table COMPLAINTS...
Create table COMPLAINTS
tablespace INPUT_SUPPRESSIONS
storage (initial 1m next 1m pctincrease 0)
pctfree 0 pctused 99
nologging as
select id
,max(decode(match_level,'H',1,0)) H_COM
,max(decode(match_level,'F',1,0)) F_COM
,max(decode(match_level,'S',1,0)) S_COM
from input_xref 
group by id;
!

if DB_object_exists ALL_COMPLAINTS ; then
	DB_run_query 'drop table ALL_COMPLAINTS;'
fi

DB_run_query_pipe<<!
Prompt Renaming IA_LOAD_COMPLAINTS to ALL_COMPLAINTS...
Rename IA_LOAD_COMPLAINTS to ALL_COMPLAINTS;
!

${IA_BIN}/ia_reports.sh MATCH

# ============================[END]==================================
*********************
* match_deceased.sh *
*********************
#!/bin/ksh
# =====================================================================
#
# Script Name : match_deceased.sh
#
# Version     : 1.2 - 04/02/01
#
# Description : Matches deceased data to People data.
#               
#
# Called by   : Script Controller Application run_deceased.sh /
#               or can be run stand alone
#
# What Usage  : @(#)match_deceased.sh	1.2 04/02/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  people_table"
   exit 1
}


create_final_table ()
{
${IA_SHELL}/resolve/type_b.sh ${PEOPLE} IA_LOAD_DECEASED

if DB_object_exists DECEASED ; then
	DB_run_query 'drop table DECEASED;'
fi

DB_run_query_pipe<<!
whenever sqlerror exit failure
Prompt Creating final table DECEASED...
Create table DECEASED
tablespace INPUT_SUPPRESSIONS
storage (initial 1m next 1m pctincrease 0)
pctfree 0 pctused 99
nologging as
select id
,max(decode(match_level,'H',1,0)) H_DEC 
,max(decode(match_level,'F',1,0)) F_DEC 
,max(decode(match_level,'S',1,0)) S_DEC 
from input_xref 
group by id;
!

if DB_object_exists ALL_DECEASED ; then
	DB_run_query 'drop table ALL_DECEASED;'
fi

DB_run_query_pipe<<!
Prompt Renaming IA_LOAD_DECEASED to ALL_DECEASED...
Rename IA_LOAD_DECEASED to ALL_DECEASED;
!

}
# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of parameters passed ($#)"
   usage
fi

. ia_vars.sh

PEOPLE=$1
if DB_object_not_exists ${PEOPLE} ; then
   echo "Table ${PEOPLE} does not exist"
   exit 2
fi

create_final_table

${IA_BIN}/ia_reports.sh MATCH

# ============================[END]==================================
********************
* match_insight.sh *
********************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : Matches Insight data. Changes have a 2 step approach,
#               
#
# Called by   : Script Controller Application run_insight.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  "
   exit 1
}

create_final_table ()
{
if DB_object_exists INSIGHT ; then
	DB_run_query 'drop table INSIGHT;'
fi

DB_run_query_pipe<<!
whenever sqlerror exit failure
Prompt Creating final table INSIGHT...
Create table INSIGHT
tablespace INPUT_SUPPRESSIONS
storage (initial 10m next 10m pctincrease 0)
pctfree 0 pctused 99 nologging
as
select id
,sum(decode(match_level,'H',1,0))   H_INS
,sum(decode(match_level,'F',1,0))   F_INS
,sum(decode(match_level,'S',1,0))   S_INS
,decode(max(decode(match_level,'S',1,0))*max(decode(worst_status
     ,'S',1 ,'.',2 ,'0',3,'1',4,'2',5,'3',6,'4',7,'5',8,'6',9,'V',10,'R',11,'D',12,'W',13,0))
     ,1,'S' ,2,'.' ,3,'0',4,'1',5,'2',6,'3',7,'4',8,'5',9,'6',10,'V',11,'R',12,'D',13,'W','') S_WORST
,decode(max(decode(match_level,'S',1,0))*max(decode(current_status
     ,'S',1 ,'.',2 ,'0',3,'1',4,'2',5,'3',6,'4',7,'5',8,'6',9,'V',10,'R',11,'D',12,'W',13,0))
     ,1,'S' ,2,'.' ,3,'0',4,'1',5,'2',6,'3',7,'4',8,'5',9,'6',10,'V',11,'R',12,'D',13,'W','') S_CURRENT
from matched_insight 
group by id;
!
}

join_resolve_output ()
{
# Joins output from Resolve back to original data

	if [ $# != 1 ] ; then
		echo "join_resolve_output needs a parameter."
		exit 1
	else
		if ! DB_object_exists $1 ; then
			echo "Table $1 does not exist."
			exit 2
		fi
	fi

	DB_run_query_pipe<<!
	whenever sqlerror exit failure
	Prompt Joining INPUT_XREF to $1...
	create table  MATCHED_INSIGHT 
	tablespace INPUT_SUPPRESSIONS
	storage (initial 50m next 50m pctincrease 0) pctfree 0
	nologging as
	select ID,COMPANY_ID,ACCOUNT_NUMBER,WORST_STATUS,CURRENT_STATUS,MATCH_LEVEL
	from INPUT_XREF x, ${1} s
	where s.SEQ = x.SEQ;
!
}

update_unchanged ()
{
# Creates new MATCHED_INSIGHT from old one, joining to new input data

	if DB_object_exists MATCHED_INSIGHT_1 ; then
		DB_run_query 'drop table MATCHED_INSIGHT_1;'
	fi
	DB_run_query 'rename MATCHED_INSIGHT to MATCHED_INSIGHT_1;'

	DB_run_query_pipe<<!
	create index temp_j on IA_CHANGED_INSIGHT (ACCOUNT_NUMBER)
	tablespace USERS nologging pctfree 0;
!

	DB_run_query_pipe<<!
	Prompt Creating MATCHED_INSIGHT for unchanged records...
	create table MATCHED_INSIGHT 
	tablespace INPUT_SUPPRESSIONS
	storage (initial 50m next 50m pctincrease 0)
	pctfree 0 pctused 99 nologging
	as
	select m.ID,m.COMPANY_ID,m.ACCOUNT_NUMBER
			,c.WORST_STATUS,c.CURRENT_STATUS,m.MATCH_LEVEL
	from   MATCHED_INSIGHT_1 m , IA_CHANGED_INSIGHT c
	where  m.COMPANY_ID     = C.COMPANY_ID
	and    m.ACCOUNT_NUMBER = C.ACCOUNT_NUMBER
	and    c.TYPE !=1;
!
}


Ins()
{
	DB_run_query_pipe<<!
	Prompt Inserting data from CHANGED records....
	Insert /*+APPEND*/ into MATCHED_INSIGHT
	select ID,COMPANY_ID,ACCOUNT_NUMBER,WORST_STATUS,CURRENT_STATUS,MATCH_LEVEL
	from INPUT_XREF x, IA_CHANGED_INSIGHT s
	where s.SEQ = x.SEQ;
!
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 1 ] && [ $# != 2 ] ; then
   /usr/bin/echo "Wrong number of parameters passed ($#)"
   usage
fi

. ia_vars.sh

PEOPLE=$1

if DB_object_not_exists $PEOPLE ; then
	echo "Table ${PEOPLE} does not exist"
	exit
fi


if [ $# = 2 ] ; then
	${IA_SHELL}/resolve/type_b.sh ${PEOPLE}  IA_LOAD_INSIGHT
	join_resolve_output IA_LOAD_INSIGHT
else
	update_unchanged
	${IA_SHELL}/resolve/type_b.sh ${PEOPLE} IA_CHANGED_INSIGHT "and b.type =1"
	Ins
fi

create_final_table                        
${IA_BIN}/ia_reports.sh MATCH
# ============================[END]==================================
****************
* match_mov.sh *
****************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : 
#               
#
# Called by   : Script Controller Application xyz.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  people_table"
   exit 1
}



first_time_around ()
{
${IA_RESOLVE}/type_b.sh ${PEOPLE} $1

if DB_object_exists ${FILE};  then
	DB_run_query_pipe<<!
	drop table ${FILE};
!
fi
if DB_object_exists ${MATCH};  then
	DB_run_query_pipe<<!
	drop table ${MATCH};
!
fi

DB_run_query_pipe<<!
create table ${MATCH}
tablespace INPUT_SUPPRESSIONS
storage (initial 25m next 25m pctincrease 0)
pctfree 0 pctused 99 nologging
as
select 1 multiplier,i.id,i.match_level from input_xref i;
!
}

create_final_table ()
{
if DB_object_exists ${FILE} ; then
   DB_run_query_pipe<<!
	drop table ${FILE};
!
fi

DB_run_query_pipe<<!
whenever sqlerror exit failure
Prompt Creating final table ${FILE}...
Create table ${FILE}
tablespace INPUT_SUPPRESSIONS
storage (initial 1m next 1m pctincrease 0)
pctfree 0 pctused 99
nologging as
select id
,max(decode(match_level,'H',1,0)) H_MOV
,max(decode(match_level,'F',1,0)) F_MOV
,max(decode(match_level,'S',1,0)) S_MOV
from ${MATCH}
group by id;
!
}

normal_week ()
{
${IA_RESOLVE}/type_b.sh ${PEOPLE} CHANGED_${FILE}

if DB_object_exists ${MATCH}_1 ; then
	DB_run_query_pipe<<!
	drop table ${MATCH}_1;
!
fi

DB_run_query_pipe<<!
rename ${MATCH} to ${MATCH}_1;

insert into ${MATCH}_1 (multiplier , id,match_level)
select MULTIPLIER,id, match_level from input_xref i, CHANGED_${FILE} c
where i.seq = c.seq;

create table temP_MM
as
select id,match_level, sum(multiplier) multiplier from ${MATCH}_1
group by id,match_level;

create table ${MATCH}
as
select id,match_level,multiplier
from temp_mm
where multiplier!=0
;

drop table temp_MM;

!
}

rename_load ()
{
	DB_run_query_pipe<<!
	rename IA_LOAD_${FILE} to ALL_${FILE};
!
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 2 ] && [ $# != 3 ] ; then
   /usr/bin/echo "Wrong number of parameters passed."
   usage
fi

# Set up standard variables

. ia_vars.sh

PEOPLE=$2
if DB_object_not_exists ${PEOPLE} ; then
   echo "Table ${PEOPLE} does not exist"
   exit 2
fi

FILE=$1
MATCH=MATCHED_${FILE}

if [ $# = 3 ] ; then
	first_time_around   IA_LOAD_${FILE}
	rename_load
else
	normal_week
fi

create_final_table
${IA_BIN}/ia_reports.sh MATCH

# ============================[END]==================================
****************
* match_mps.sh *
****************
#!/bin/ksh
# =====================================================================
#
# Script Name : match_mps.sh
#
# Version     : 1.1 - 04/02/01
#
# Description : Matches MPS data to create MPS anmd ALL_MPS tables
#               
#
# Called by   : Script Controller Application run_mps.sh /
#               or can be run stand alone
#
# What Usage  : @(#)match_mps.sh	1.1 04/02/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  people_table"
   exit 1
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of parameters passed ($#)"
   usage
fi

# Set up standard variables

. ia_vars.sh

PEOPLE=$1
if DB_object_not_exists ${PEOPLE} ; then
   echo "Table ${PEOPLE} does not exist"
   exit 2
fi

${IA_RESOLVE}/type_b.sh ${PEOPLE} IA_LOAD_MPS
if [ $? != 0 ] ; then
	echo "ERROR $0"
	exit 1
fi

if DB_object_exists MPS ; then
	DB_run_query 'drop table MPS;'
fi

DB_run_query_pipe<<!
whenever sqlerror exit failure
Prompt Creating final table MPS...
Create table MPS
tablespace INPUT_SUPPRESSIONS 
storage (initial 10m next 10m pctincrease 0)
pctfree 0 pctused 99
nologging as
select id
,max(decode(match_level,'H',1,0)) H_MPS 
,max(decode(match_level,'F',1,0)) F_MPS 
,max(decode(match_level,'S',1,0)) S_MPS 
from input_xref 
group by id;
!

if DB_object_exists ALL_MPS ; then
	DB_run_query 'drop table ALL_MPS;'
fi

DB_run_query_pipe<<!
Prompt Renaming IA_LOAD_MPS to ALL_MPS...
Rename IA_LOAD_MPS to ALL_MPS;
!

${IA_BIN}/ia_reports.sh MATCH

# ============================[END]==================================
****************
* match_tps.sh *
****************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : 
#               
#
# Called by   : Script Controller Application xyz.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  people_table"
   exit 1
}



first_time_around ()
{
${IA_RESOLVE}/type_b.sh ${PEOPLE} $1

if DB_object_exists TPS;  then
	DB_run_query_pipe<<!
	drop table TPS;
!
fi
if DB_object_exists TPS;  then
	DB_run_query_pipe<<!
	drop table ${MATCH};
!
fi

DB_run_query_pipe<<!
create table ${MATCH}
tablespace LOAD_DATA
storage (initial 100m next 10m pctincrease 0)
pctfree 0 pctused 99 nologging
as
select 1 multiplier,i.id,i.match_level from input_xref i;
!
}

create_final_table ()
{
if DB_object_exists TPS ; then
   DB_run_query_pipe<<!
	drop table TPS;
!
fi

DB_run_query_pipe<<!
whenever sqlerror exit failure
Prompt Creating final table TPS...
Create table TPS
storage (initial 100m next 100m pctincrease 0)
tablespace INPUT_SUPPRESSIONS pctfree 0 pctused 99
nologging as
select id
,max(decode(match_level,'H',1,0)) H_TPS
,max(decode(match_level,'F',1,0)) F_TPS
,max(decode(match_level,'S',1,0)) S_TPS
from ${MATCH}
group by id;
!
}

normal_week ()
{
${IA_RESOLVE}/type_b.sh ${PEOPLE} CHANGED_TPS

if DB_object_exists ${MATCH}_1 ; then
	DB_run_query_pipe<<!
	drop table ${MATCH}_1;
!
fi

DB_run_query_pipe<<!
rename ${MATCH} to ${MATCH}_1;

insert into ${MATCH}_1 (multiplier , id,match_level)
select MULTIPLIER,id, match_level from input_xref i, CHANGED_TPS c
where i.seq = c.seq;

create table temP_MM
as
select id,match_level, sum(multiplier) multiplier from ${MATCH}_1
group by id,match_level;

create table ${MATCH}
as
select id,match_level,multiplier
from temp_mm
where multiplier!=0
;

drop table temp_MM;

!
}

rename_load ()
{
	DB_run_query_pipe<<!
	rename IA_LOAD_TPS to ALL_TPS;
!
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 2 ] && [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of parameters passed ($#)"
   usage
fi

. ia_vars.sh
PEOPLE=$1
if DB_object_not_exists ${PEOPLE} ; then
   echo "Table ${PEOPLE} does not exist"
   exit 2
fi

MATCH=MATCHED_TPS

if [ $# = 2 ] ; then
	first_time_around   IA_LOAD_TPS
	rename_load
else
	normal_week
fi

create_final_table
${IA_BIN}/ia_reports.sh MATCH

# ============================[END]==================================
***********
* nams.sh *
***********
#!/bin/ksh
#set -x
# =====================================================================
#
# Script Name : nams.sh  
#
# Version     : 1.1 - 04/05/01
#
# Usage       : nams.sh ia_home_dir client_code infile
#
# Description : wrapper for namsload.sh
#
# Exit Status : 
#
#       0       Successful run
#      >1       Job failed - derived from namsload 
#
# Called by   : Script Controller Application
#
# What Usage  : @(#)nams.sh	1.1 04/05/01
#
# =====================================================================

Usage ()
{
echo "Usage:\t$0 client_code infile" 
exit 1
}

if [ $# -ne 2 ] 
then
  Usage 
fi

NAMSAPP=namscontrol/namsload.sh
CLIENT_CODE=$1
INFILE=$2

. ia_vars.sh

# -------- check the program file is present
if [ ! -f ${IA_HOME}/shell/$NAMSAPP ] ; then
 echo "Can't find namsload program tried: ${IA_HOME}/shell${NAMSAPP}"
 exit 1
fi

echo "-------------------------------------------------------------------------
Starting NAMSLOAD at " `date`  
echo "-------------------------------------------------------------------------
using the following Parameters :-
> CLIENTCODE        : ${CLIENT_CODE}
> INFILE            : ${INFILE}
-------------------------------------------------------------------------"
${IA_SHELL}/${NAMSAPP} ${CLIENT_CODE} ${INFILE} 2>&1 | tee -i ${IA_LOG}/${CLIENT_CODE}.log

DB_object_exists CLIENT_LOAD_${CLIENT_CODE}
if [ $? -ne 0 ] ; then
  echo "FAILED: see logfile for full information" 
else
  echo "COMPLETED SUCCESSFULLY"
fi

echo "-------------------------------------------------------------------------"
echo "Load Log files present at location : ${IA_LOG}/${CLIENT_CODE}.log"
echo "Nams error log file                : ${IA_LOG}/IA_ERRORS.log"
echo "-------------------------------------------------------------------------
Finished - " `date`
echo "-------------------------------------------------------------------------"



# -------------------------------------------------------------------
# END
# -------------------------------------------------------------------
********************
* namsfilecheck.sh *
********************
#!/bin/ksh
#set -x
# =====================================================================
#
# Script Name : namsfilecheck.sh  
#
# Version     : 1.1 - 04/05/01
#
# Usage       : namsfilecheck.sh client_code infile [no_of_recs] 
#
# Description : This script enables Cobol layouts to be compared
#               against ASCII files on screen.
#
#               The Cobol layout (COB) files are held within the
#               Oracle tables FILE_INFO and FILE_DETAILS hence the
#               comparison only works for files REGISTERED within
#               these tables. 
#
# Exit Status : 
#
#       0       Successful run
#       1       Error in run parameters - see usage
#       2       Can't find IA variable file
#       5       Client Code Not Found
#       6       Template Record Length is invalid
#       7       Template File type is invalid
#       8       Template File type states Unblocked - try Blocked
#       9       Template File type states Blocked - try Unblocked        
#
# Called by   : Script Controller Application /
#               or can be run stand alone
#
# What Usage  : @(#)namsfilecheck.sh	1.1 04/05/01
#
# =====================================================================


# --------------------
# FUNCTIONS/PROCEDURES
# --------------------

Usage ()
{
echo "Usage:\t$0 client_code infile no_of_recs"
echo "\tclient_code\t\tclient code used to reference the template."
echo "\tinfile\t\t\tASCII file used to compare against the template."
echo "\t\t\t\tThis file must be present in IA's LOAD directory."
echo "\tno_of_recs\t\t[optional] number of recs to compare default=5"
exit 1
}



#----------------------------------------------------------------------
# FILECOBINFO - Extracts the CLIENT load file info from the database
#----------------------------------------------------------------------
FileCOBInfo ()
{
DB_run_query_pipe<<!
set heading off
set pages 0
set feedback off
select rtrim(field_name,20)||'~'||field_length||'~'||field_start
from file_details
where client_code = '${CLIENT_CODE}'
order by field_start
/
!
}

#----------------------------------------------------------------------
# FILELAYOUT - Extract the COB template from the database
#----------------------------------------------------------------------
FileLayout ()
{
DB_run_query_pipe<<!
set heading off
set pages 0
set feedback off
select client_code||' '||rec_length||' '||nvl(file_format,'notpresent')||' '||description
from file_info
where client_code = '${CLIENT_CODE}'
/
!
}

#----------------------------------------------------------------------
# LOAD_COB_ASCII_FILES = Load and verify template/file content 
#----------------------------------------------------------------------
Load_COB_ASCII_Files ()
{
# get the template file details
FileLayout | read FILECODE RECLEN FILETYPE FILEDESC


if [ -z $FILECODE ]; then
 echo "error  : template for client code [$CLIENT_CODE] not found" 
 exit 5
fi

if [ $RECLEN != +([0-9]) ]; then  
    if [ $RECLEN -lt 1 ]; then
       echo "error  : template attribute 'rec_length' =>[$RECLEN] must be greater than 0" 
       exit 6
    fi
else
    echo "error  : template attribute 'rec_length' => [$RECLEN] must be a numeric"
    exit 6
fi

if [ $FILETYPE = "notpresent" ]; then
 echo "error  : template attribute 'file_type' is unspecified"
 exit 7
fi

if [ $FILETYPE != "B" ] && [ $FILETYPE != "U" ]; then
 echo "error  : template attribute 'file_type' => [$FILETYPE] is invalid - must be U or B"
 exit 7
fi


echo "==================================================================="
echo "ASCII FILE versus COB Layout Verifier"
echo "==================================================================="
echo "FileInfo Parameters :- \n"
echo "   File/Client Code : " $FILECODE 
echo "   Record Length    : " $RECLEN
echo "   File Description : " $FILEDESC
echo "   File Type        : " $FILETYPE "  [B]locked|[U]nblocked\n"
echo "=[COB LAYOUT]=====================[Len]=[ASCII DATA]==============="

# load the cob file format received into an array
set -A _FILECOBLAYOUT `FileCOBInfo`

if [ $FILETYPE = "B" ]; then
   # need to cut (recordlen * recs) from the blocked file 
   GETCHARS=`echo "$RECLEN * $TESTRECS" | bc` 
   set -A _INFILE `cut -c1-$GETCHARS $INFILE | dd conv=unblock cbs=$RECLEN 2>/dev/null| sed "s/ /./g"`
else
   # load unblocked input file records into the array
   set -A _INFILE `head -$TESTRECS $INFILE | cut -c1-$RECLEN | sed "s/ /./g"`
fi 

LOADED=${#_INFILE[*]}


if [ $LOADED -lt 1 ]; then
 echo "error  : unable to parse the file structure, try flagging the file as [B]locked"
 exit 8 
fi

if [ $LOADED -gt $TESTRECS ]; then
 echo "error  : unable to parse the file structure, try flagging the file as [U]nblocked"
 exit 9 
fi 
}


# ===================================================================
# M A I N
# ===================================================================

if [ $# -lt 2 ] 
then
  Usage 
fi

CLIENT_CODE=$1
ASCIIFILE=$2
TESTRECS=$3

. ia_vars.sh # load ia environment defaults

INFILE=$IA_LOAD/$ASCIIFILE

if [[ $TESTRECS != +([0-9]) ]]; then
    TESTRECS=5
    echo "warning: [no_of_recs] not a valid number or not supplied - defaulting to 5"
else
   if [ $TESTRECS -lt 1 ]; then
      echo "warning: [no_of_recs] sample recs to small - defaulting to 5"
      TESTRECS=5 
   fi
fi

if [ ! -f ${INFILE} ] ; then
 echo "Can't find load file tried: ${INFILE}"
 exit 3
fi

Load_COB_ASCII_Files  #load the cob file template from Oracle    
                      #and sample recs from the ASCII file

ctr=0
for line in ${_INFILE[*]}
do
   for ctlline in ${_FILECOBLAYOUT[*]}
   do

      fieldname=`echo $ctlline | cut -f1 -d~` 
      fieldlength=`echo $ctlline | cut -f2 -d~`
      fieldstart=`echo $ctlline | cut -f3 -d~`

      if [ $ctr -eq "0" ]; then 
         fieldend=$fieldlength
      else
         fieldend=`echo "$fieldstart + ($fieldlength -1)" | bc` 
      fi

      fieldval=`echo $line | cut -c${fieldstart}-${fieldend}`
      cobval=${_FILECOBLAYOUT[$ctr]} 

      #format the screen layout
      echo "${cobval}~${fieldval}" | \
        awk 'BEGIN {FS = "~"}{flag = " "; reclen=length($4); \
                    if ( reclen != $2 ) {flag = "!"} \
                printf("03 %-18s PIC X(%3s). [%3s]%s%s\n",$1,$2,reclen,flag,$4)}'

      ctr=`echo "$ctr +1" | bc`
   done 
   ctr=0 
   echo "~~"
done

echo "${#_INFILE[*]} records processed - End."

# -------------------------------------------------------------[End]-
****************
* namsload.sh *
****************
#!/bin/ksh
#set -x
# =====================================================================
#
# Script Name : namsload.sh  
#
# Version     : 1.1 - 04/05/01
#
# Usage       : namsload.sh client_code infile
#
# Description : This script runs the NAMS processing on the file
#               <infile> and produces two outfiles one with nams keys and
#               another with failed key matches. 
#
# Exit Status : 
#
#       0       Successful run
#       1       Error in run parameters - see usage
#       2       Can't find IA variable file 
#
#    Input Parameter Error level:
#      35       Error in creating NAMS control template for client 
#      36       Bad <infile> specified
#
#    Syncsort Error level:
#     100       Syncsort PTCABS Split - failed
#     110       Failed to remove blank ptcabs from pass1 fail file
#               for reprocessing via low level nams key 
#    DCU:
#     200       Failed to load keyed file to load area [Dcu]
#
#    NAMS Program level:
#     211       Error in converting input file to COBOL VB format
#     212       Error in NAMS reformat program
#     213       Error in Address matching program
#     214       Error in Output reformat program
#
#    Internal Error level:
#     230       Address match code not catered for
#
#
# Called by   : Script Controller Application /
#               or can be run stand alone
#
# What Usage  : @(#)namsload.sh	1.1 04/05/01
#
# =====================================================================

# -------------
# GLOBAL PARAMS
# -------------

NAMS_CTL_EXT=nams



# -------
# EXPORTS
# -------

EXPORT_VARS ()
{
# Set up NAMS environment variables sourced from ia_vars.sh
# DO NOT CHANGE HERE!
export WS1=$IA_NAMS_WS1
export WS2=$IA_NAMS_WS2
export NAMS_BASE=$IA_NAMS_BASE
export NAMS_SID=$IA_NAMS_SID      #NAMS Oracle system Identifier
export ORACLE_SID=$IA_NAMS_SID    # using NAMS db first
export COBDIR=${IA_COBDIR}       # Full path to Micro Focus COBOL
export COBPATH=${IA_COBPATH}      # Cobrun dynamic load directories
}



# --------------------
# FUNCTIONS/PROCEDURES
# --------------------

Usage ()
{
echo "Usage:\t$0 client_code infile"
exit 1
}



#----------------------------------------------------------------------
# CHECK_CODE_EXISTS - checks the client data descriptors exist on IA
#----------------------------------------------------------------------
Check_Code_Exists ()
{
# returns record length of file and the file format B=blocked U=Unblocked
# if the client code exists in the FILE_INFO table, 
# otherwise null is returned

# out format e.g: 
#    <client_code>~<file_format B|U>~<rec_length>~<cob_rec_length>
#     CLIENT_A~B~99~0099

DB_run_query_pipe<<!
set heading off
set pages 0
set feedback off
select client_code||'~'||file_format||'~'||rec_length||'~'||lpad(to_char(rec_length),4,'0')
from file_info
where client_code = '${CLIENT_CODE}'
/
!
}


#----------------------------------------------------------------------
# ASSEMBLE_CONTROL - builds the NAMS control file
#----------------------------------------------------------------------
Assemble_Control ()
{
DB_run_query_pipe<<!
set heading off
set pages 0
set feedback off

-- CTL HEADER
select 'HDNMX219 INPUT RECORDS 99999999\n'||
       'HDNMX219 RECORD LENGTH IS '||lpad(to_char(rec_length),4,'0')||'\n'||
	   'HDNMX219 COMPANY CODE '||rtrim(client_code) control_file
from file_info
where client_code = '${CLIENT_CODE}'
/
-- ADDR COUNT
select 'HDNMX219 ADDRESS HAS '||lpad(to_char(count(*)),2,'0')||' LINES'
from file_details
where client_code = '${CLIENT_CODE}'
and type ='A'
/
-- ADDRESS LINES
select 'HDNMX219 ADDRESS LINE  '||rownum||
       ' STARTSFROM '||lpad(to_char(field_start),4,'0')||
       ' FOR '||lpad(to_char(field_length),3,'0')
from file_details
where client_code = '${CLIENT_CODE}'
and type = 'A' 
order by field_start
/
-- POST CODE
select 'HDNMX219 POSTCODE        STARTSFROM '||lpad(to_char(field_start),4,'0')||
	   ' FOR '||lpad(to_char(field_length),3,'0')	   
from file_details
where client_code = '${CLIENT_CODE}'
and type = 'P'
/
-- SURNAME
select 'HDNMX219 NAME IS SEPARATE\n'||
	   'HDNMX219 SURNAME         STARTSFROM '||
	   lpad(to_char(field_start),4,'0')||
       ' FOR '||lpad(least('020',to_char(field_length)),3,'0')||'\n'||
	   'HDNMX219 END OF PARAMETERS'
from file_details
where client_code = '${CLIENT_CODE}'
and type = 'N'
/
!
}


#----------------------------------------------------------------------
# ASSEMBLE_COB - builds the cob file body for DCU Loading
#----------------------------------------------------------------------
Assemble_COB ()
{
DB_run_query_pipe<<!
set heading off
set pages 0
set feedback off

select '03 '||rpad(field_name,25,' ')||'PIC X('||field_length||').'
from file_details
where client_code = '${CLIENT_CODE}'
order by field_start
/
!
}


#----------------------------------------------------------------------
# TIDYUP - removes unwanted NAMS work files
#----------------------------------------------------------------------
tidy_up () 
{
rm ${WS1}/${FNAMPREFIX}.* 2> /dev/null
rm ${WS2}/${FNAMPREFIX}.* 2> /dev/null
}


#----------------------------------------------------------------------
# TIME_STAMP - time stamps the runtime log 
#----------------------------------------------------------------------
time_stamp () 
{
echo "\n"
echo "-----------------------------------------------------------------"
echo "$1 started @ `date`" 
echo "-----------------------------------------------------------------"
}


#----------------------------------------------------------------------
# ERRORLEVEL - Controls exit status 
#----------------------------------------------------------------------
ERRORLEVEL () 
{
ERR=$1 #Error level code
EP=$2  #Error param message

case $ERR in 
    35) EM="Error in creating NAMS control template for ${EP}";;
    36) EM="Bad infile parameter specified => ${EP}";;
   100) EM="PTCABS Split syncsort failed";;
   110) EM="Failed to remove blank ptcabs from HIGH pass fail file";;
   200) EM="Failed to load keyed file to load area [Dcu]";;
   211) EM="HDNMX218 failed";;
   212) EM="HDNMX219 failed";;
   213) EM="${EP} failed";;
   214) EM="Error in Output reformat program";;
   230) EM="Address match code ${EP} not catered for";;
     *) EM="Unknown exit status :$ERR";;
esac

IA_ERROR_LOG "${APPNAME}" "${EM}" # send error to general log
echo ">>${EM}" # send back to nams wrapper
exit $ERR
}


#----------------------------------------------------------------------
# HDNMX218 - Cobol Exec: Reformat input to COBOL VB format
#----------------------------------------------------------------------
HDNMX218 ()
{
export INPUT01=$INFILE                    # Ascii input file
export OUTPUT01=${WS1}/${FNAMPREFIX}.vbo  # COBOL VB output

time_stamp "Program HDNMX218"

if [ -z $INFILE_REC_LENGTH ] ; then
   echo "Using UNBLOCKED file"
else
   echo "Using BLOCKED file $INFILE_REC_LENGTH"
fi 

# note: the rec length will be blank if mode is unblocked
$NAMS_BASE/pgms/MSGSF218 $INFILE_REC_LENGTH

if [ $? -ne 0 ] ;  then
        tidy_up
        ERRORLEVEL 211 
fi
}


#----------------------------------------------------------------------
# HDNMX219 - Cobol Exec: Reformat input
#----------------------------------------------------------------------
HDNMX219 ()
{
export INPUT01=${WS1}/${FNAMPREFIX}.vbo        # Client input file (vb)
export OUTPUT01=${WS2}/${FNAMPREFIX}.rfm       # Reformatted output
export OUTSTT01=${WS1}/${FNAMPREFIX}.sta       # Statistics file
export SYSIN=${IA_WORKSPACE}/${CLIENT_CODE}.${NAMS_CTL_EXT}    # NAMS Control File

# Assmble the NAMS Control File
Assemble_Control | grep HDNMX219 > ${SYSIN}

time_stamp "Program HDMNX219"

$NAMS_BASE/pgms/HDNMX219

if [ $? -ne 0 ] ; then
        tidy_up
        ERRORLEVEL 212 
fi
}


#----------------------------------------------------------------------
# ADDRESSMATCH - Cobol Exec: Address Matching
#----------------------------------------------------------------------
ADDRESSMATCH ()
{
export MASTERIN=${WS2}/${FNAMPREFIX}.rfm        # Reformatted file
export MASTR1OT=${WS2}/${FNAMPREFIX}.key        # Address matched file

case $1 in
   HIGH) # high pass using S1/S4/S6 keys i.e POSTCODE EXPECTED 
         PGADDMTCH="HDNMX237.gnt";
         PGOUTPUT="HDNMX280";;
    LOW) # low pass using S5 key i.e NO POSTCODE EXPECTED 
         PGADDMTCH="HDNMX235.gnt";
         PGOUTPUT="HDNMX276";;
      *) echo "Address Match Code $1 not catered for";
         ERRORLEVEL 230 $1;;
esac

time_stamp "Program $PGADDMTCH"

rtsora $COBPATH/${PGADDMTCH}

if [ $? -ne 0 ] ; then
        tidy_up
        ERRORLEVEL 213 ${PGADDMTCH} 
fi
rm ${WS2}/${FNAMPREFIX}.rfm
}


#----------------------------------------------------------------------
# OUTPUT_REFORMAT - Cobol Exec: Output reformat
#----------------------------------------------------------------------
OUTPUT_REFORMAT ()
{
export INPUT01=${WS2}/${FNAMPREFIX}.key
export INPUT02=${WS1}/${FNAMPREFIX}.vbo
export PARMS01=${WS1}/${FNAMPREFIX}.sta
export OUTPUT01=${OUTFILE}

time_stamp "Program ${PGOUTPUT}"

$NAMS_BASE/pgms/${PGOUTPUT}

if [ $? -ne 0 ] ; then
        echo "${PGOUTPUT} failed"
        tidy_up
        ERRORLEVEL 214 
fi

tidy_up
}


#----------------------------------------------------------------------
# MAKE_PASS_FAIL_FILES : Splits NAMS keyed file into pass and fails
#----------------------------------------------------------------------
MAKE_PASS_FAIL_FILES ()
{
# now prepare for LOW level key pass on fails

echo "syncsort << endofsort
/INFILE ${OUTFILE} new   500
/WORKSPACE ${IA_WORKSPACE} 
/FIELDS
         PTCABS 1 CHAR 11
        ,BODY   12 CHAR ${FI_REC_LENGTH} 
/KEYS BODY
/CONDITION FAIL PTCABS = \"           \"
/REFORMAT
         PTCABS
        ,BODY
/STATISTICS
/OUTFILE
       ${PASSFILE}   OVERWRITE
/OMIT   FAIL
/OUTFILE
       ${FAILFILE}  OVERWRITE
/INCLUDE   FAIL 
/END
endofsort" > ${IA_WORKSPACE}/${CLIENT_CODE}.ptcabs.ss

time_stamp "Creating pass/fail files"

chmod +x ${IA_WORKSPACE}/${CLIENT_CODE}.ptcabs.ss
${IA_WORKSPACE}/${CLIENT_CODE}.ptcabs.ss  

if [ $? -ne 0 ] ; then
   ERRORLEVEL 100
fi

rm ${IA_WORKSPACE}/${CLIENT_CODE}.ptcabs.ss   # tidy syncsort file

}


#----------------------------------------------------------------------
# NAMS - Run NAMS Processing using the Cobol Executables
#----------------------------------------------------------------------
NAMS ()
{
   HDNMX218                      # reformat to COBOL .vbo format
   HDNMX219                      # reformat input .rfm format
   ADDRESSMATCH $1               # run high/low level matching .key files
   OUTPUT_REFORMAT               # produce reformatted outfile

   # split the Nams output file into ptcabs pass/fail files
   MAKE_PASS_FAIL_FILES                

   # remove the NAMS output file 
   rm ${OUTFILE}
}


#----------------------------------------------------------------------
# REMOVE_PTCABS - Reorganises file layout
#----------------------------------------------------------------------
REMOVE_PTCABS ()
{

   time_stamp "Modifying file ready for reprocessing"

   # reorganise the .HIGH.fail file by removing ptcabs (chars1-11)
   # so the layout matches the nams control file for reprocessing

   RERUNFILE=${INFILE}.2
   cut -c12-9999 ${FAILFILE} > ${RERUNFILE}

   if [ $? -ne 0 ] ; then
        echo "Failed to remove blank ptcabs from the failed file => ${FAILFILE}"
        exit 110
   fi

}


#----------------------------------------------------------------------
# COMBINE_AND_MOVE - Combine pass and fail files and move to location 
#----------------------------------------------------------------------
COMBINE_AND_MOVE ()
{

#tidy the nams control file
rm ${IA_WORKSPACE}/${CLIENT_CODE}.${NAMS_CTL_EXT}

if [ $1 -eq 1 ] ; then
   # Deal with combing the files from a two pass run

   # tidy up
   rm ${OLDFAILFILE} # <infile>.HIGH.fail
   rm ${RERUNFILE}   # <infile>.2

   ## below if two seperate outcome files required
   ##cat ${OLDPASSFILE} ${PASSFILE} > ${CLIENT_CODE}.pass
   ##mv ${FAILFILE} ${CLIENT_CODE}.fail

   # merge the .pass and .fail files to create the .dat file
   cat ${OLDPASSFILE} ${PASSFILE} ${FAILFILE} > ${IA_WORKSPACE}/${CLIENT_CODE}.dat

   # tidy up
   rm ${OLDPASSFILE}             # <infile>.HIGH.pass
   rm ${PASSFILE} ${FAILFILE}    # <infile>.2.LOW.pass <infile.2.LOW.fail>

else
   # no combining required - just move

   # below if two seperate outcome files required
   ##mv ${PASSFILE} ${CLIENT_CODE}.pass
   ##mv ${FAILFILE} ${CLIENT_CODE}.fail

   # merge the .pass and .fail files to create the .dat file
   cat ${PASSFILE} ${FAILFILE} > ${IA_WORKSPACE}/${CLIENTCODE}.dat 
   rm  ${PASSFILE} ${FAILFILE}
fi

}


#----------------------------------------------------------------------
# LOAD_DATA - LOAD the NAMS keyed <infile>.dat to the database 
#----------------------------------------------------------------------
LOAD_DATA ()
{

# Assemble the COB File used by DCU for loading
echo "01 ${CLIENT_CODE}.\n03 HOUSE_ID                   PIC X(11)." > ${IA_WORKSPACE}/${CLIENT_CODE}.cob
Assemble_COB | grep 03 >> ${IA_WORKSPACE}/${CLIENT_CODE}.cob 
echo "03 FILLER                   PIC X(1).\n" >> ${IA_WORKSPACE}/${CLIENT_CODE}.cob

#need to check if table exists already and remove!!!
#and sort out the workspace/log/bad file areas

TABLESPACE=PP_DATA  #need to derive this
TABLE=CLIENT_LOAD_${CLIENT_CODE}
RECCOUNT=`wc -l ${IA_WORKSPACE}/${CLIENT_CODE}.dat | awk '{print $1}'`
DCU_INIT=`echo "${FI_REC_LENGTH} * ${RECCOUNT} / 1024 / 2" | bc` 
DCU_NEXT=$DCU_INIT

# create the dcu file
echo "/opt/mki/utils/bin/dcu \\
   -pc ${IA_WORKSPACE}/${CLIENT_CODE}.cob \\
   -i ${IA_WORKSPACE}/${CLIENT_CODE}.dat \\
   -sid ${IA_ORA_SID} \\
   -s ${IA_WORKSPACE}/create.sql \\
   -t ${TABLE} \\
   -ts ${TABLESPACE}  \\
   -b ${IA_BAD}/${CLIENT_CODE}.bad \\
   -log ${IA_LOG}/${CLIENT_LOAD}.log \\
   -opt 'OPTIONS (DIRECT=TRUE, ERRORS=100)' \\
   -ftype ASC -disksplitmb 400 \\
   -stoini ${DCU_INIT}K \\
   -stonxt ${DCU_NEXT}K \\
   -stomin 1 \\
   -stomax 200 \\
   -stopct 0 \\
   -stopctf 0 \\
	-seqname SEQ \\
	-seqstart 1 \\
	-seqinc   1 \\
	-seqsize 11 \\
   -sync " > ${IA_WORKSPACE}/${CLIENT_CODE}.dcu


chmod +x ${IA_WORKSPACE}/${CLIENT_CODE}.dcu
${IA_WORKSPACE}/${CLIENT_CODE}.dcu 

if [ $? != 0 ] ; then
   /usr/bin/echo "Error loading ${IA_WORKSPACE}/${CLIENT_CODE}.dat data"
   exit 200 
fi

#remove dcu's temp files
rm ${IA_WORKSPACE}/${CLIENT_CODE}.dcu
rm ${IA_WORKSPACE}/${CLIENT_CODE}.cob.wide
rm ${IA_WORKSPACE}/${CLIENT_CODE}.cob
rm ${IA_WORKSPACE}/create.sql 
rm c.c c.out nohup.out colinfofile rec.h ldr.ctl
}



# ===================================================================
# MAIN
# ===================================================================
#set -x
if [ $# -lt 2 ] 
then
  Usage 
fi


APPNAME="NAMSLOAD"   # used for general IA error pool identification


# -------- verify paramter ia_home_dir


. ia_vars.sh # load IA environment defaults

EXPORT_VARS # export all /static/ NAMS vars



# -------- verify paramater client_code 

CLIENT_CODE=$1


RETVAL=`Check_Code_Exists|awk '{print $1}'`

if [ -z ${RETVAL} ] ; then
  ERRORLEVEL 35 ${CLIENT_CODE}
fi

FI_MODE=`echo ${RETVAL} | cut -f2 -d~`
FI_REC_LENGTH=`echo ${RETVAL} | cut -f3 -d~`

# if blocked mode then we need the length
if [ $FI_MODE = "B" ] ; then
    INFILE_REC_LENGTH=`echo ${RETVAL} | cut -f4 -d~`
fi

# -------- verify paramater input_file 

export INFILE=${IA_LOAD}/$2   

if [ ! -f ${INFILE} ] ; then
        ERRORLEVEL 36 ${INFILE}
fi



# the following variables will change - these are the initial
# settings for the first High level NAMS matching

OUTFILE=${INFILE}.HIGH.nams    # Nams output file
PASSFILE=${INFILE}.HIGH.pass   # records with ptcabs  
FAILFILE=${INFILE}.HIGH.fail   # records without ptcabs


# the following vars remain constant

export FNAMPREFIX=${CLIENT_CODE}      # nams var



# run through NAMS High Pass Matching
NAMS HIGH 

# if we end up with a .HIGH.fail file then we attempt to
# match records within this file using NAMS low level 
# matching routine

if [ -f ${FAILFILE} ] ; then

   # reorganise the .HIGH.fail file so the layout 
   # matches the nams control file for reprocessing
   REMOVE_PTCABS 

   # remember previous .HIGH.pass .HIGH.fail files for final 
   # tidy up and pass file combining

   OLDFAILFILE=${FAILFILE}
   OLDPASSFILE=${PASSFILE}

   # reset the env vars ready for the second pass 
   # of the fails/rerun file

   export INFILE=${RERUNFILE}      # reformatted file created by REMOVE_PTCABS
   OUTFILE=${INFILE}.LOW.nams      # Nams output file for previous fails 
   PASSFILE=${INFILE}.LOW.pass
   FAILFILE=${INFILE}.LOW.fail

   # run through NAMS High Pass Matching
   unset INFILE_REC_LENGTH     #ensure we are now running in unblocked mode
   NAMS LOW 

   # combine high and low pass files and keep latest fail file
   COMBINE_AND_MOVE 1

else
   # move pass and fail files only
   COMBINE_AND_MOVE 2
fi


echo "\nNAMS completed at `date`" 


# load the data to a temporary table
LOAD_DATA 

# compress and store the keyed data and the input file
#pkzip ${PP_LOAD}/${INFILE}.zip ${IA_WORKSPACE}/${CLIENT_CODE}.dat ${INFILE}
#rm ${IA_WORKSPACE}/${CLIENT_CODE}.dat ${INFILE}

# -------------------------------------------------------------------
# END
# -------------------------------------------------------------------
*****************
* paf_update.sh *
*****************
#!/bin/ksh
#set -x
# =====================================================================
#
# Script Name : paf_update.sh  
#
# Version     : 1.1 - 04/05/01
#
# Usage       : paf_update.sh 
#
# Description : This script updates the IA house keys table to
#               reflect changes from PAF_FEEDBACK
#
# Exit Status : 
#
#       0       Successful run
#       1       Error in run parameters - see usage
#
# Called by   : Script Controller Application /
#               or can be run stand alone
#
# What Usage  : @(#)paf_update.sh	1.1 04/05/01
#
# =====================================================================

# -------------
# GLOBAL PARAMS
# -------------



# --------------------
# FUNCTIONS/PROCEDURES
# --------------------

Usage ()
{
echo "Usage:$0"
exit 1
}


#----------------------------------------------------------------------
# RUN_PAF_UPDATE_STAGE_1 - Creates the Links 
#----------------------------------------------------------------------
Run_PAF_Update_Stage_1 ()
{

echo "STAGE1 => Creating PTCABS chains at " `date`

DB_run_query_pipe<<!
set feedback off
set serveroutput on size 1000000
exec PAF_UPDATE.EXPAND_LINKS;
!
}



#----------------------------------------------------------------------
# RUN_PAF_UPDATE_STAGE_2 - Updates the House_Keys table to reflect any
#                          PTCABS links
#----------------------------------------------------------------------
Run_PAF_Update_Stage_2 ()
{
echo "STAGE2 => Updating House_Keys at " `date`

DB_run_query_pipe<<!
set feedback off
set serveroutput on size 1000000
exec PAF_UPDATE.UPDATE_IA_HOUSEKEYS;
!
}

#----------------------------------------------------------------------
# INITIALISE_PAF_LINK - creates the link table
#----------------------------------------------------------------------
Initialise_PAF_Link ()
{

# --- check if PAF_LINK already exists

DB_object_exists PAF_LINK
if [ $? -eq 0 ]; then 
echo "PAF_LINK table detected.. removing PAF_LINK table"
DB_run_query_pipe<<!
Drop table PAF_LINK;
!
fi


# --- get current size of PAF_FEEDBACK table

RETVAL=`DB_run_query_pipe<<!
set feedback off
set pages 0
set heading off
select bytes from user_segments where segment_name = 'PAF_FEEDBACK';
!`

INITKB=`echo $RETVAL|awk '{print $1}'`
INIT=`echo "$INITKB / 1024 /1024" | bc`

if [ $INIT -gt 0 ]; then 
echo "Creating PAF_LINK table at " `date`

  ########################################################
  # PCTFREE needs to cater for adding the link_id column #
  ########################################################

RETVAL=`DB_run_query_pipe<<!
set feedback off
CREATE TABLE PAF_LINK
  TABLESPACE IA_INDEX 
  STORAGE (INITIAL ${INIT}M NEXT ${INIT}M PCTINCREASE 0 )
   PCTUSED 95 PCTFREE 5 NOLOGGING
AS
Select old_ptcabs,new_ptcabs,rownum seqno  
from paf_feedback;
!`
else

 echo "bad sizing paramters received from PAF_FEEDBACK =>$INIT"
 exit 40

fi

# did the table create ok?
DB_object_exists PAF_LINK
if [ $? -eq 1 ]; then
   echo "Aborted: Paf_Link table failed to create:"
   echo $RETVAL
   exit 20
fi


# --- add the link_id column / used for deriving ptcabs chains
DB_run_query_pipe<<!
set feedback off
alter table paf_link add (link_id number(10));
!

IDX_INIT=`echo "$INIT / 10 " | bc`

# --- build the three indexes
echo "Creating PAF_LINK indexes at " `date`
DB_run_query_pipe<<!
set feedback off

CREATE UNIQUE INDEX PAF_LINK_SEQ ON
  PAF_LINK(SEQNO)
  NOLOGGING TABLESPACE IA_INDEX PCTFREE 0
  STORAGE(INITIAL ${IDX_INIT}M NEXT ${IDX_INIT}M PCTINCREASE 0 );

CREATE INDEX PAF_LINK_OLD ON 
  PAF_LINK(OLD_PTCABS) 
  NOLOGGING TABLESPACE IA_INDEX PCTFREE 0
  STORAGE(INITIAL ${IDX_INIT}M NEXT ${IDX_INIT}M PCTINCREASE 0 ); 

CREATE INDEX PAF_LINK_NEW ON 
  PAF_LINK(NEW_PTCABS) 
  NOLOGGING TABLESPACE IA_INDEX PCTFREE 0
  STORAGE(INITIAL ${IDX_INIT}M NEXT ${IDX_INIT}M PCTINCREASE 0 ); 
  
  CREATE INDEX PAF_LINK_ID ON 
  PAF_LINK(LINK_ID) 
  NOLOGGING TABLESPACE IA_INDEX PCTFREE 0
  STORAGE(INITIAL ${IDX_INIT}M NEXT ${IDX_INIT}M PCTINCREASE 0 ); 
!

# --- recreate the link_id sequence
DB_run_query_pipe<<!
set feedback off

drop sequence paf_link_seq;  
  
create sequence PAF_LINK_SEQ
start with 1
increment by 1
nomaxvalue
minvalue 1
nocycle
cache 20000;
!

}

#--------------------------------------------------------------------
# M A I N
#--------------------------------------------------------------------


APPNAME="PAFUPDATE"   # used for general IA error pool identification

# load IA environment vars
. ia_vars.sh 

Initialise_PAF_Link     # build the temp table used for identifying chains
Run_PAF_Update_Stage_1  # create the PTCABS links table
Run_PAF_Update_Stage_2  # update house_keys with the linked PTCABS info

echo "Finished PAF Update at " `date`

# -------------------------------------------------------------[End]-
*******************
* range_update.sh *
*******************
COUNT=1
START=6000001
while [ $COUNT -lt 91 ] ; do

DB_run_query_pipe<<!
whenever sqlerror exit failure
set timing on
update dim2k a
set HOUSE_ID = (select house_id
              from HOUSE_KEYS b
              where a.house_id = b.ptcabs)
where SEQ >= ${START}
and rownum < 500001;
!
if [ $? != 0 ] ; then
	echo "ERROR"
	exit
fi

START=`expr $START + 500000`
COUNT=`expr $COUNT + 1` 
			  
done
------------------------------------------------------------------------------------------------------
**************
* run_ccj.sh *
**************
FEED=CCJ ; export FEED
. ia_vars.sh

${IA_BIN}/ia_reports.sh INIT 


if [ $# = 0 ] ; then
	${IA_SHELL}/ccj/sort_ccj.sh   
	if [ $? != 0 ] ; then
		exit
	fi
	TARGET=CHANGED_CCJ
else
	echo "Initial Load..."
	TARGET=LOAD_CCJ
fi

${IA_SHELL}/ccj/load_ccj.sh   $1

${IA_SHELL}/house_keys/gen_hkeys.sh  $TARGET

${IA_SHELL}/ccj/match_ccj.sh   $1


${IA_BIN}/ia_reports.sh END
---------------------------------------------------------------------------------------------------
*********************
* run_complaints.sh *
*********************
#!/bin/ksh
# =====================================================================
#
# Script Name : run_complaints.sh
#
# Version     : 1.4 - 03/30/01
#
# Description : Runs the Complaints data through the system
#               
#
# Called by   : ia_daemon.sh
#               or can be run stand alone
#
# What Usage  : @(#)run_complaints.sh	1.4 03/30/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

FEED=COMPLAINTS ; export FEED   

. ia_vars.sh

${IA_BIN}/ia_reports.sh INIT 

if DB_object_exists ALL_COMPLAINTS ; then
	DB_run_query 'drop table ALL_COMPLAINTS;'
fi

##########
# Load data to LOAD_COMPLAINTS

load_complaints.sh   
if [ $? != 0 ] ; then
	exit
fi

##########
# Remove duplicates

dedupe_complaints.sh LOAD_COMPLAINTS
if [ $? != 0 ] ; then
	exit
fi

##########
# Swap PTCABS to HOUSE_ID

${IA_SHELL}/house_keys/gen_hkeys.sh LOAD_COMPLAINTS
if [ $? != 0 ] ; then
	exit
fi

##########
# Match data

match_complaints.sh  DIM2K
if [ $? != 0 ] ; then
	exit
fi

${IA_BIN}/ia_reports.sh END  

# ============================[END]==================================
*******************
* run_deceased.sh *
*******************
#!/bin/ksh
# =====================================================================
#
# Script Name : run_deceased.sh
#
# Version     : 1.2 - 04/02/01
#
# Description : Runs the deceased scripts
#
#
# Called by   : Called by ia_daemon.sh 
#               or can be run stand alone
#
# What Usage  : @(#)run_deceased.sh	1.2 04/02/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  "
   exit 1
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

FEED=DECEASED ; export FEED

. ia_vars.sh

${IA_BIN}/ia_reports.sh INIT 

##########
# Load data to LOAD_DECEASED  

load_deceased.sh 
if [ $? != 0 ] ; then
	echo "Error loading deceased."
	exit 1
fi

##########
# Remove duplicates

dedupe_deceased.sh LOAD_DECEASED
if [ $? != 0 ] ; then
	echo "Error deduping deceased"
	exit 2
fi

#########
# Swap PTCABS to HOUSE_ID

${IA_SHELL}/house_keys/gen_hkeys.sh LOAD_DECEASED  
if [ $? != 0 ] ; then
	echo "Error swapping HOUSE_ID"
	exit 3
fi

##########
# Match data

match_deceased.sh DIM2K
if [ $? != 0 ] ; then
	echo "Error matching deceased"
	exit 4
fi

${IA_BIN}/ia_reports.sh END  

# ============================[END]==================================
****************
* run_dim2k.sh *
****************
#!/usr/bin/ksh


log()
{
  echo "$(date +%Y-%m-%d-%H:%M:%S): "$* | tee -a ${IA_HOME}/log/$(basename $0)".$$" 2>/dev/null
}

error_chk(){

ES=$1
MOD=$2

if [[ $ES != "0" ]]
then
    log "*****************************************************"
    log "$MOD : Failed"
    log "*****************************************************"
    exit 1
else
    log "*****************************************************"
    log "$MOD : Finished Successfully"
    log "*****************************************************"
fi
}

chk_index_exists()
{

if [[ $# != 2 ]]
then
    log "Error wrong parameters passed"
    log "Usage: chk_index_exists <<TABLE>> <<COL>>"
    exit 2
fi

TABLENAME=$1
COL=$2

# check index exists
DB_run_query_pipe<<!
set heading off
set feedback off
set pages 0
select index_name
from all_ind_columns
where table_name = '$TABLENAME'
and column_name = '$COL';
!
}

create_index()
{
TABLENAME=$1
COL=$2
TABLESPACE=$3
INI=$4
NXT=$5
IDX_NAME=${TABLENAME}_${COL}_IDX

if [[ $# != 5 ]]
then
   log "\n
   I need 3 parameters for this function in the following order:
   TABLENAME      # eg house
   COL			   # eg ptcabs
   TABLESPACE     # eg users
   INI
	NXT"
	exit 1
fi


log "Creating index $IDX_NAME..."
DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
create  index $IDX_NAME on
  		  ${TABLENAME}($COL)
  		  nologging tablespace $TABLESPACE pctfree 0
        storage(initial ${INI} next ${NXT} pctincrease 0);
exit sql.sqlcode
!
CE=$?
error_chk $CE create_index
}


index_wrap()
{

TAB=$1
COL=$2
TSPACE=$3
INI=$4
NXT=$5
IDX_NAME=${TAB}_${COL}_IDX

CHK=$(chk_index_exists $TAB $COL | awk '{print $1}')
if [ -z $CHK ]; then
   log "Index not detected, building..."
   create_index $TAB $COL $TSPACE $INI $NXT
else
   log "Index ${INX_NAME} detected"
fi
}


create_dim2k()
{

if DB_object_not_exists load_dim2k ; then
DB_run_query_pipe <<!
whenever sqlerror exit sql.sqlcode
prompt creating table load_dim2k from dim2k ...
create table load_dim2k
tablespace load_data
pctfree 0 pctused 99
storage (initial 50M next 50M pctincrease 0)
nologging as select
HOUSE_ID,
STREET_CODE,
SURNAME,
FIRST_INITIAL,
TITLE_CODE,
FORENAME,
SECOND_INITIAL,
PERSON_RESIDENCY,
GENDER,
PERSON_MARRIED_FLAG,
PERSON_HOH_FLAG,
PERSON_ATTAINER_FLAG,
PERSON_DECEASED_FLAG,
PERSON_MOVER,
PERSON_DATE_OF_BIRTH_DATE,
PERSON_INVESTOR,
PERSON_WESCORE,
PERSON_WESCORE_INSIGHT,
PERSON_WESCORE_BAD,
PERSON_WESC_PC,
PERSON_WESC_PC_INSIGHT,
PERSON_WESC_PC_BAD,
PERSON_CCJ_DATE,
PERSON_CCJ_VALUE,
PERSON_INSIGHT_WS,
PERSON_INSIGHT_DATE_WS,
PERSON_INSIGHT_VALUE_WS,
PERSON_INSIGHT_WE,
PERSON_INSIGHT_DATE_WE,
PERSON_INSIGHT_VALUE_WE,
PERSON_SURKEY,
HOUSE_POSTSORT,
HOUSE_SOURCE,
HOUSE_GB,
HOUSE_MPS,
HOUSE_HH_COMPOSITION,
HOUSE_NO_SURNAMES,
HOUSE_NO_PEOPLE,
HOUSE_NO_ADULTS,
HOUSE_NO_ATTAINERS,
HOUSE_NO_RESIDENCY,
HOUSE_NO_MR,
HOUSE_NO_MRS,
HOUSE_NO_MISS,
HOUSE_NO_MS,
HOUSE_NO_OTHER,
HOUSE_SRH6,
HOUSE_SRH12,
HOUSE_SRH24,
HOUSE_CCJ6,
HOUSE_CCJ12,
HOUSE_CCJ24,
POSTCODE_POSTCODE,
POSTCODE_CAMEO_MATCH_FLAG,
POSTCODE_CAMEO_UK,
POSTCODE_CAMEO_UK_GROUP,
POSTCODE_CAMEO_PROP,
POSTCODE_CAMEO_INCC,
POSTCODE_CAMEO_INVV,
POSTCODE_CAMEO_FINC,
POSTCODE_TV_REGION,
POSTCODE_DIRECTOR_FLAG,
POSTCODE_DEFINE,
POSTCODE_INCOME_NATIONAL,
POSTCODE_INCOME_REGIONAL,
POSTCODE_MICROVISION,
HOUSE_TELEPHONE_FLAG,
PERSON_YEAR_OF_BIRTH,
PERSON_AGE_18_24,
PERSON_AGE_25_34,
PERSON_AGE_35_44,
PERSON_AGE_45_54,
PERSON_AGE_55_64,
PERSON_AGE_65_PLUS,
PERSON_FRUIT,
PERSON_FRUIT_SCORE_VALUE,
POSTCODE_CAMEO_UNEMPLOYMENT,
POSTCODE_CAMEO_INTL,
HOUSE_DPS,
POSTCODE_WEALTH_INDICATOR,
PERSON_MM_DOM_TYPE,
PERSON_MM_DOM_SCORE,
PERSON_MM_SCORE_A,
PERSON_MM_SCORE_F,
PERSON_MM_SCORE_T,
PERSON_MM_SCORE,
PERSON_NEW_YEAR_OF_BIRTH,
PERSON_DE_MATCH_FLAG,
PERSON_DE_DATE_OF_BIRTH,
PERSON_DE_OCCUPATION,
PERSON_DE_INCOME,
PERSON_DE_GENDER,
PERSON_DE_CHILDREN,
PERSON_DE_CHILD_AGE,
PERSON_DE_CH1_DATE_OF_BIRTH,
PERSON_DE_CH2_DATE_OF_BIRTH,
PERSON_DE_CH3_DATE_OF_BIRTH,
PERSON_DE_BANK_ACCOUNT,
PERSON_DE_LIFE_INSURANCE,
PERSON_DE_CREDIT_CARD,
PERSON_DE_CAR_OWNER,
PERSON_DE_MAIL_ORDER_BUYER,
PERSON_DE_RESPONDER,
PERSON_DE_BLUE_CHIP,
PERSON_DE_PRIVATE,
PERSON_DE_MULTI,
PERSON_DE_HOLIDAY,
PERSON_DE_DAILY,
PERSON_DE_SUNDAY,
PERSON_DE_PROPERTY_INSURANCE,
PERSON_DE_MOTOR_INSURANCE,
PERSON_DE_DIRECTORS_FLAG,
ID,
SEQ
from dim2k where rownum <100001;
exit sql.sqlcode
!
fi
ES=$?
error_chk $ES create_load_dim2k
}


update_id_and_dedupe()
{
log "updating id column on table ia_load_dim2k ..."
DB_run_query_pipe<<!
whenever sqlerror exit sql.sqlcode
update ia_dim2k
set id = (select id from match_temp where match_temp.seq = ia_dim2k.seq);
exit sql.sqlcode
!
ES=$?
error_chk $ES update_dim2k

log deduping table ia_dim2k 
dedupe.sh $HOME/prod ia_load_dim2k
ES=$?
error_chk $ES dedupe_dim2k
}


####
# Main
####

. $HOME/prod/bin/ia_vars.sh
log Started

# testing removed in final version
#log creating a small test table dim2k ...
#create_dim2k
# swap ptcabs for house_id against table dim2k
log "running Jari's swapping routine ..."
$IA_HKEYS/gen_hkeys.sh $IA_BIN DIM2K HOUSE_ID

ES=$?
error_chk $ES gen_hkeys.sh

# Tablespace might need to be changed in final version
log "runnning index_wrap on match_temp to create seq index ..."
index_wrap MATCH_TEMP SEQ IA_INDEX 100M 100M
ES=$?
error_chk $ES index_wrap_matchtemp

# now run against type_a matching to insert data
# to candidate_a from table ia_dim2k
log "running type_a.sh script ..."
$IA_RESOLVE/type_a.sh IA_DIM2K
ES=$?
error_chk $ES type_a.sh
log "running update and deduping ..."
update_id_and_dedupe
log "End of program"
####
# END
####
-----------------------------------------------------------------------------------------------------------
******************
* run_insight.sh *
******************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : Drives INSIGHT data through system
#               
#
# Called by   : ia_daemon.sh
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

FEED=INSIGHT ; export FEED
. ia_vars.sh

${IA_BIN}/ia_reports.sh INIT 

if [ $# = 0 ] ; then
	${IA_SHELL}/insight/sort_insight.sh   
	if [ $? != 0 ] ; then
  	 exit 1
	fi
	TARGET=CHANGED_INSIGHT
else
	echo "Initial Load..."
	TARGET=LOAD_INSIGHT
	TARGET1=IA_LOAD_INSIGHT
fi
    
${IA_SHELL}/insight/load_insight.sh   $1
if [ $? != 0 ] ; then
   exit 2
fi

${IA_SHELL}/insight/dedupe_insight.sh ${TARGET}
if [ $? != 0 ] ; then
   exit 3
fi

${IA_SHELL}/house_keys/gen_hkeys.sh ${TARGET}
if [ $? != 0 ] ; then
   exit 4
fi

${IA_SHELL}/insight/match_insight.sh   DIM2K ${TARGET1}
if [ $? != 0 ] ; then
   exit 5
fi

${IA_BIN}/ia_reports.sh END

# ============================[END]==================================
**************
* run_mov.sh *
**************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : 
#               
#
# Called by   : ia_daemon.sh
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

if [ $# != 1 ] && [ $# != 2 ] ; then
	echo "Wrong number of parameters passed ($#)"
	exit
fi

FEED=`echo $1 | tr '[a-z]' '[A-Z]'` ; export FEED
. ia_vars.sh

${IA_BIN}/ia_reports.sh INIT 

if [ $# = 1 ] ; then
	${IA_SHELL}/movers/sort_mov.sh   $FEED
	if [ $? != 0 ] ; then
	   exit 1
	fi
	TARGET=CHANGED_${FEED}
else
	echo "Initial load..."
	TARGET=LOAD_${FEED}
fi
       
${IA_SHELL}/movers/load_mov.sh   $FEED $2
if [ $? != 0 ] ; then
   exit 2
fi

${IA_SHELL}/movers/dedupe_mov.sh ${TARGET}
if [ $? != 0 ] ; then
   exit 3
fi

#########
# Swap PTCABS to HOUSE_ID

${IA_SHELL}/house_keys/gen_hkeys.sh ${TARGET} 
if [ $? != 0 ] ; then
	exit 4
fi

match_mov.sh  ${FEED} DIM2K $2
if [ $? != 0 ] ; then
   exit 5
fi


if [ $# = 1 ] ; then
	${IA_SHELL}/movers/combine_mov.sh ${FEED}
fi

${IA_BIN}/ia_reports.sh END

# ============================[END]==================================
**************
* run_mps.sh *
**************
#!/bin/ksh
# =====================================================================
#
# Script Name : run_mps.sh
#
# Version     : 1.1 - 04/02/01
#
# Description : Runs the MPS data through system
#
#
# Called by   : Run stand alone
#
#
# What Usage  : @(#)run_mps.sh	1.1 04/02/01
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"


FEED=MPS ; export FEED
. ia_vars.sh

${IA_BIN}/ia_reports.sh INIT 

${IA_SHELL}/mps/load_mps.sh   
if [ $? != 0 ] ; then
   echo "Error Loading mps."
   exit 1
fi

${IA_SHELL}/mps/dedupe_mps.sh LOAD_MPS         
if [ $? != 0 ] ; then
   echo "Error deduping ${TABLE}."
   exit 2
fi

#########
# Swap PTCABS to HOUSE_ID

${IA_SHELL}/house_keys/gen_hkeys.sh LOAD_MPS  
if [ $? != 0 ] ; then
	echo "Error swapping house-id"
	exit 3
fi

${IA_SHELL}/mps/match_mps.sh  DIM2K
if [ $? != 0 ] ; then
   echo "Error matching ${TABLE}."
   exit 4
fi

${IA_BIN}/ia_reports.sh END

# ============================[END]==================================
**************
* run_tps.sh *
**************
FEED=TPS ; export FEED
. ia_vars.sh

${IA_BIN}/ia_reports.sh INIT 

if [ $# = 1 ] ; then
	${IA_SHELL}/tps/sort_tps.sh   
	if [ $? != 0 ] ; then
  	 exit 1
	fi
	TARGET=CHANGED_TPS 
else
	echo "Initial Load..."
	TARGET=LOAD_TPS 
fi
    
${IA_SHELL}/tps/load_tps.sh  $2
if [ $? != 0 ] ; then
   exit 1
fi

${IA_SHELL}/tps/dedupe_tps.sh ${TARGET}         
if [ $? != 0 ] ; then
   exit 1
fi
exit

${IA_SHELL}/tps/match_tps.sh  DIM2k $2
if [ $? != 0 ] ; then
   exit 1
fi

${IA_BIN}/ia_reports.sh END
----------------------------------------------------------------------------------------------------
***************
* sort_ccj.sh *
***************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M% 
#
# Version     : %I% - %G%
#
# Description : Sorts differences between 2 weeks CCJ files
#
#
# Called by   : Script Controller Application run_ccj.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0"
   exit 1
}


check_files ()
{

for files in ${IA_OLD}/ccj ${IA_NEW}/ccj
do
	if [ ! -f ${files} ] ; then
		echo "File ${files} is not present."
		exit 1
	fi

	SIZE=`ls -ltr ${files} | awk '{print $5}'`
	RECS=`expr ${SIZE} / ${REC_LEN}`
	if [ `expr ${SIZE} % ${REC_LEN}` != 0 ] ; then
		echo "Size of file ${files} does not divide by ${REC_LEN}"
		exit 2
	else
		echo "${files} contains ${RECS} records."
		${IA_SHELL}/ia_reports.sh SORT "File contains ${RECS} records."
	fi
done

}

do_sort ()
{
syncsort<<!
/INFILE ${IA_NEW}/ccj new ${REC_LEN} FIXED 
/INFILE ${IA_OLD}/ccj old ${REC_LEN} FIXED

/FIELDS                         /* Definitions of fields we will be using */
 PTCABS         1 CHAR 11
,COURT-DATE    12 CHAR 03
,CASE-NUMBER   19 CHAR 14
,SURNAME      73 CHAR 20
,FORENAME      93 CHAR 15
,SECOND-NAME  108 CHAR 15
,TITLE-CODE   123 CHAR 02
,ID_NO        165 CHAR 10

/KEYS PTCABS,COURT-DATE,CASE-NUMBER,SURNAME,FORENAME,SECOND-NAME,TITLE-CODE,ID_NO

/STATISTICS

/DERIVEDFIELD COUNTER 1 pd 2     /* Counter field that will be used to sum identical records */

/WORKSPACE /workspace01          /* Temp working files go here */

/SUMMARIZE TOTAL COUNTER         /* Sum counter on identical records */

/CONDITION newrecord  alias=new 
/CONDITION droprecord alias=old 
/CONDITION dupes   counter > 2

/DERIVEDFIELD ind  
	if newrecord  then x"40f1" else 
	if droprecord then x"60f1" else "  "

/REFORMAT
 PTCABS,COURT-DATE,CASE-NUMBER,SURNAME,FORENAME,SECOND-NAME,TITLE-CODE,IND,COUNTER

/OUTFILE ccj    overwrite
/include dupes
!

}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------


if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of paramters passed ($#)"
   usage
fi

. ia_vars.sh

REC_LEN=212
check_files
do_sort

# ============================[END]==================================
*******************
* sort_insight.sh *
*******************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : Counts up the 'type' of records in two Insight feeds,
#               giving all records from new feed.
#
# Called by   : Script Controller Application run_insight.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0 "
   exit 1
}

check_files ()
{
#Check files are present and have suitable size

for files in ${IA_OLD}/insight ${IA_NEW}/insight
do
	if [ ! -f ${files} ] ; then
		echo "File ${files} is not present."
		exit 1
	fi

	SIZE=`ls -ltr ${files} | awk '{print $5}'`
	RECS=`expr ${SIZE} / ${REC_LEN}`
	if [ `expr ${SIZE} % ${REC_LEN}` != 0 ] ; then
		echo "Size of file ${files} does not divide by ${REC_LEN}"
		exit 2
	else
		echo "${files} contains ${RECS} records."
	fi
	
done

}

do_sort ()
{
# The Counter derived field has datatype PD (packed decimal). 
# Although not ascii readable, syncsort considers it to be a numberic (and so 
# can summarize on it) and DCU can load it.

# ACCOUNT_NUMBER and COMPANY_ID should be unique, so there are no worries
# about duplicates on the input files

syncsort<<!
/INFILE ${IA_NEW}/insight new ${REC_LEN} FIXED
/INFILE ${IA_OLD}/insight old ${REC_LEN} FIXED

/FIELDS                         /* Definitions of fields we will use.*/
 PTCABS	         1 CHAR 11
,COMPANY-ID      14 CHAR  8
,ACCT-NUM        26 CHAR 20
,DOB             58 CHAR  4
,CURR-STAT       84 CHAR  1
,WORST-STAT      85 CHAR  1
,TITLE-CODE     136 CHAR  2
,FORENAME       138 CHAR 15
,SECOND-INITIAL 153 CHAR  2
,SURNAME	       155 CHAR 20

/KEYS PTCABS,COMPANY-ID,ACCT-NUM,TITLE-CODE,FORENAME,SECOND-INITIAL,SURNAME

/DERIVEDFIELD COUNTER 1 pd 2    /* Counter to sum identical records */

/STABLE                         /* Ensures survivor record is from 1st input*/

/WORKSPACE /workspace01

/STATISTICS

/SUMMARIZE TOTAL COUNTER        /* Sum counter on identical records */

/CONDITION nothanks alias=old   /* Drop records from old file only */

/REFORMAT
 PTCABS,COMPANY-ID,ACCT-NUM,DOB,CURR-STAT,WORST-STAT
,TITLE-CODE,FORENAME,SECOND-INITIAL,SURNAME,COUNTER

/OUTFILE insight overwrite
/OMIT nothanks
!

}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of parameters passed ($#)"
   usage
fi

# Set up standard variables

. ia_vars.sh

REC_LEN=387
check_files
do_sort

# ============================[END]==================================
***************
* sort_mov.sh *
***************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : Sorts differences between 2 weeks worth of Mover files.
#               
#
# Called by   : Script Controller Application xyz.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  mover/movin"
   exit 1
}

check_files ()
{

#Check files are present and have suitable size

for files in ${IA_OLD}/${FILE} ${IA_NEW}/${FILE}
	do
	if [ ! -f ${files} ] ; then
		echo "File ${files} is not present."
		exit 1
	fi

	SIZE=`ls -ltr ${files} | awk '{print $5}'`
	RECS=`expr ${SIZE} / ${REC_LEN}`
	if [ `expr ${SIZE} % ${REC_LEN}` != 0 ] ; then
		echo "Size of file ${files} does not divide by ${REC_LEN}"
		exit 2
	else
		echo "${files} contains ${RECS} records."
		${IA_BIN}/ia_reports.sh SORT "File has ${RECS} records"
	fi
        
done
}

do_sort ()
{
syncsort<<!  > /tmp/$$_mov_sort.log 2>&1
/INFILE ${IA_NEW}/${FILE} new ${REC_LEN} FIXED
/INFILE ${IA_OLD}/${FILE} old ${REC_LEN} FIXED

/FIELDS                         /* Definitions of the fields we are interested in */
 MOVE_DATE        1 CHAR  6
,TITLE            7 CHAR 20
,FORENAME        27 CHAR 15
,SECOND_INITIAL  42 CHAR 01
,SURNAME	        44 CHAR 20
,TO-PTCABS       64 CHAR 11
,FROM-PTCABS     75 CHAR 11

/STATISTICS

/DERIVEDFIELD COUNTER 1 pd 2     /* Counter to sum identical records */
/KEYS TITLE,FORENAME,SECOND_INITIAL,SURNAME,FROM-PTCABS,TO-PTCABS,MOVE_DATE

/WORKSPACE /workspace01

/SUMMARIZE TOTAL COUNTER /* Add up the counter field on identical records */

/CONDITION newrecord  alias=new 
/CONDITION droprecord alias=old
/CONDITION dupes   counter > 1

/DERIVEDFIELD ind  
	if newrecord  then x"40f1" else 
	if droprecord then x"60f1" else x"60f2"

/REFORMAT
 FROM-PTCABS
,TO-PTCABS
,MOVE_DATE
,TITLE
,FORENAME
,SECOND_INITIAL
,SURNAME
,IND 
,COUNTER

/OUTFILE ${FILE}    overwrite
/omit dupes
!

}
# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 1 ] ; then
   /usr/bin/echo "Wrong number of parameters passed ($#)"
   usage
fi

. ia_vars.sh

TYPE=`echo $1 | tr '[A-Z]' '[a-z]'`  # MOVER or MOVIN

if [ ${TYPE} != 'mover' ] && [ ${TYPE} != 'movin' ] ; then
	echo "Must pass er or in."
	usage
else
	FILE=${TYPE}
fi

REC_LEN=85 
check_files
do_sort

cat /tmp/$$_mov_sort.log
TMP=`grep -i "Records output" /tmp/$$_mov_sort.log` 
TMP=`echo $TMP| awk '{print $1" "$2 " "$3}'`
${IA_BIN}/ia_reports.sh SORT "$TMP"
# ============================[END]==================================
***************
* sort_tps.sh *
***************
#!/bin/ksh
# =====================================================================
#
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : 
#               
#
# Called by   : Script Controller Application xyz.sh /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================

/usr/bin/echo "\nSTART_TIME = `/usr/bin/date` $0"

usage ()
{
   /usr/bin/echo "Usage : $0  "
   exit 1
}

check_files ()
{
#Check files are present and have suitable size

	for files in ${IA_OLD}/tps ${IA_NEW}/tps
	do
		if [ ! -f ${files} ] ; then
			echo "File ${files} is not present."
		exit 1
		fi
		SIZE=`ls -ltr ${files} | awk '{print $5}'`
		RECS=`expr ${SIZE} / ${REC_LEN}`
		if [ `expr ${SIZE} % ${REC_LEN}` != 0 ] ; then
			echo "Size of file ${files} does not divide by ${REC_LEN}"
			exit 2
		else
			echo "${files} contains ${RECS} records."
			${IA_BIN}/ia_reports.sh SORT "File contains ${RECS} records."
		fi
        
	done

}

do_sort ()
{
syncsort<<! > /tmp/$$_tps_sort.log 2>&1
/INFILE ${IA_NEW}/tps new ${REC_LEN} FIXED
/INFILE ${IA_OLD}/tps old ${REC_LEN} FIXED

/FIELDS                         /* Definitions of the fields we are interested in */
 PTCABS	       1 CHAR 11
,SURNAME	      12 CHAR 20
,FIRST-INITIAL	32 CHAR 1

/KEYS PTCABS,SURNAME,FIRST-INITIAL

/DERIVEDFIELD COUNTER 1 pd 2    /* Counter field that will be used to sum identical records */

/DERIVEDFIELD ind  
	if newrecord  then x"40f1" else 
	if droprecord then x"60f1" else x"60f2"

/WORKSPACE /workspace01
/STATISTICS

/SUMMARIZE TOTAL COUNTER /* Add up the counter field on identical records */

/CONDITION newrecord  alias=new 
/CONDITION droprecord alias=old
/CONDITION dupes   counter > 1

/REFORMAT
 PTCABS,SURNAME,FIRST-INITIAL,IND,COUNTER

/OUTFILE tps    overwrite
/omit dupes
!
cat /tmp/$$_tps_sort.log 
}

# -------------------------------------------------------------------
# M A I N
# -------------------------------------------------------------------

if [ $# != 0 ] ; then
   /usr/bin/echo "Wrong number of parameters passed ($#)"
   usage
fi

. ia_vars.sh

REC_LEN=81
check_files
do_sort

TMP=`grep -i "Records output" /tmp/$$_tps_sort.log` 
TMP=`echo $TMP| awk '{print $1" "$2 " "$3}'`
${IA_BIN}/ia_reports.sh SORT "$TMP"

# ============================[END]==================================

*******************
* suppressions.sh *
*******************
#!/bin/ksh
set -x
# =====================================================================
#
# Script Name : %M%  
#
# Version     : %I% - %G%
#
# Usage       : %M% 
#
# Description : This script creates the widened suppressions table
#
# Exit Status : 
#
#       0       Successful run
#
#      20       One of the required suppression tables
#               does not exist 
#      21       Index build failure on one of the 
#               individual suppression tables
#
#      30       Failed to build suppression driver table
#
#      40       Failed to build suppressions table 
#      41       Failed to build suppressions index
# 
#      60       User not found within IA
#
# Called by   : Script Controller Application /
#               or can be run stand alone
#
# What Usage  : %W% %G%
#
# =====================================================================


# --------------------
# FUNCTIONS/PROCEDURES
# --------------------

Usage ()
{
echo "Usage:$0\t user 
\tuser\toracle user name to generate suppressions for"
exit 1
}


#----------------------------------------------------------------------
# USER_VERIFY - returns username if exists, null if not exists
#----------------------------------------------------------------------
User_Verify ()
{
USR=$1

DB_run_query_pipe<<!
set heading off
set feedback off
set pages 0
select username  
from all_users
where username = '$USR';
!
}

#----------------------------------------------------------------------
# SUBSCRIBED - outputs 0 = subscriber, 1 = non subscriber
#----------------------------------------------------------------------
Subscribed ()
{
SUB=$1

DB_run_query_pipe<<!
set heading off
set feedback off
set pages 0
select decode(insight_member,'Y',0,'N',1,1) 
from ia_subscriptions
where username = '$SUB';
!
}

#----------------------------------------------------------------------
# CHECK_INDEX - returns index name if present / Null if not present
#----------------------------------------------------------------------
Check_Index ()
{
DB_run_query_pipe<<!
set heading off
set feedback off
set pages 0
select index_name
from all_ind_columns
where table_name = '$1'
and column_name = '$2';
!
}


#----------------------------------------------------------------------
# CREATE_INDEX - 
#----------------------------------------------------------------------
Create_Index ()
{
TB=$1 #table
IX=$2 #column to index
SZ=$3 #init/next size in Mb

echo "Creating index ${TB}_ID_I on table ${TB}.${IX} init=${SZ} next=${SZ}"
DB_run_query_pipe<<!
CREATE UNIQUE INDEX ${TB}_ID_I ON 
  ${TB} ($IX) 
  TABLESPACE IA_INDEX NOLOGGING PCTFREE 0
  STORAGE(INITIAL ${SZ}M NEXT ${SZ}M PCTINCREASE 0 ) ;  
!
}


#----------------------------------------------------------------------
# VERIFY_SUPPRESSION_TABS -  ensures all key tables exist within index
#----------------------------------------------------------------------
Verify_Suppression_Tabs ()
{

if [ $SUB = '0' ]; then
   TABLEREQMT="MPS TPS INSIGHT MOVIN MOVER CCJ DECEASED COMPLAINTS"
else
   TABLEREQMT="MPS TPS MOVER CCJ DECEASED COMPLAINTS"
fi

for TABLE in ${TABLEREQMT} 
do

   # check suppression table exists

   DB_object_exists $TABLE
   if [ $? -eq 1 ]; then
      echo "$TABLE does not exist - aborted"
      exit 20 
   else

      # table present so check index exists

      IDXSTAT=`Check_Index $TABLE ID`
      if [ -z $IDXSTAT ]; then
         # no index found - need to build one

         #set the init/next for the index > TPS/CCJ currently biggest

         case $TABLE in
           TPS) SIZE=40;;
           CCJ) SIZE=20;;
           *)   SIZE=10;;
         esac 

         IDXREP=`Create_Index $TABLE ID $SIZE`

         # did the index build ok?

         IDXSTAT=`Check_Index $TABLE ID`
         if [ -z $IDXSTAT ]; then
            echo "Aborted - Index build failed with the following error:-" 
            echo $IDXREP
            exit 21
         else 
            echo "$Index $IDXREP built"
         fi

      else
         echo "Index $TABLE.$ID found"
      fi
   fi
 
done
}



#----------------------------------------------------------------------
# CREATE_SUPPRESSION_DRIVER - generates the master ID table used for
#                             creating the complete suppressions build
#----------------------------------------------------------------------

Create_Suppression_Driver ()
{

#check if driver table already exists

DB_object_exists SUPPRESSION_DRIVER 
if [ $? -eq 0 ]; then
   echo "Dropping existing Suppression Driver table"
DB_run_query_pipe<<!
drop table SUPPRESSION_DRIVER;
!
fi

echo "creating suppressions driver table " `date`

if [ $SUB = '0' ]; then
  INSIGHT="union
select id from movin
union
select id from insight"
else
 INSIGHT=
fi

RETVAL=`DB_run_query_pipe<<!
set serveroutput on size 1000000
CREATE TABLE SUPPRESSION_DRIVER
  TABLESPACE USERS     
  STORAGE (INITIAL 40M NEXT 40M PCTINCREASE 0 )
   PCTUSED 99 PCTFREE 0 NOLOGGING
As   
select id from tps
union
select id from mps
union
select id from complaints
union
select id from ccj
union
select id from deceased
union
select id from mover
${INSIGHT}
/
!`

# was the build successful?
if DB_object_not_exists SUPPRESSION_DRIVER ; then
   echo "Aborted - SUPPRESSION_DRIVER table build failed"
   echo $RETVAL
   exit 30
fi
}


#----------------------------------------------------------------------
# CREATE_SUPPRESSIONS - merges all suppression tables into one big table 
#----------------------------------------------------------------------

Create_Suppressions ()
{

#check if suppressions table already exists

DB_object_exists SUPPRESSIONS
if [ $? -eq 0 ]; then
   echo "Dropping existing Suppressions table"
DB_run_query_pipe<<!
drop table SUPPRESSIONS;
!
fi

echo "creating suppressions table -  start time " `date`


if [ $SUB = '0' ]; then
  echo "Member of insight - including INSIGHT/MOVIN suppressions"
  SELECT=",i.H_INS, i.F_INS, i.S_INS, i.S_WORST, i.S_CURRENT
          ,mi.H_MOV H_MOVIN, mi.F_MOV F_MOVIN, mi.S_MOV S_MOVIN"
  FROM=",insight i, movin mi"
  WHERE=" and   s.id = i.id (+)
          and   s.id = mi.id (+)"
else
  SELECT=
  FROM=
  WHERE=
  echo "Not a member of insight - excluding INSIGHT/MOVIN suppressions"
fi

RETVAL=`DB_run_query_pipe<<!
set serveroutput on size 1000000
create table ${USER}.SUPPRESSIONS
tablespace SUPPRESSIONS pctfree 0
storage ( initial 150M next 150M pctincrease 0) nologging
as
select /*+ RULE */ 
       s.ID
      ,t.H_TPS, t.F_TPS, t.S_TPS
      ,m.H_MPS, m.F_MPS, m.S_MPS
      ,co.H_COM, co.F_COM, co.S_COM
      ,c.H_CCJ_6, c.H_CCJ_12, c.H_CCJ_24, c.H_CCJ_36, c.H_CCJ_72
           ,c.F_CCJ_6, c.F_CCJ_12, c.F_CCJ_24, c.F_CCJ_36, c.F_CCJ_72
           ,c.S_CCJ_6, c.S_CCJ_12, c.S_CCJ_24, c.S_CCJ_36, c.S_CCJ_72
      ,d.H_DEC, d.F_DEC, d.S_DEC
      ,mo.H_MOV, mo.F_MOV, mo.S_MOV
      ${SELECT} from suppression_driver s,
     tps t,
     mps m,
     complaints co,
     ccj c,
     deceased d,
     mover mo ${FROM}
where s.id = m.id (+)
and   s.id = t.id (+)
and   s.id = co.id (+)
and   s.id = c.id (+)
and   s.id = d.id (+)
and   s.id = mo.id (+)
${WHERE}
/
!`

# did the suppressions table build ok?
if DB_object_not_exists SUPPRESSIONS ; then
   echo "Aborted - Suppressions table does not exist after create phase"
   echo $RETVAL
   exit 40
fi
echo "suppressions build end time " `date`

# now create index on ID

echo "creating SUPPRESSIONS index"
RETVAL=`Create_Index ${USER}.SUPPRESSIONS ID 40`

# did the index build?
IDXSTAT=`Check_Index SUPPRESSIONS ID`
if [ -z $IDXSTAT ]; then
   echo "Index build failed with the following error:-"
   echo $RETVAL
   exit 41
else
   echo "Index $IDXREP built"
fi

}


#--------------------------------------------------------------------
# M A I N
#--------------------------------------------------------------------


if [ $# -lt 1 ] 
then
  Usage 
fi


typeset -u USER

USER=$1


# is the user a valid Oracle User?
RETVAL=`User_Verify $USER`
if [ "$RETVAL" != "$USER" ]; then
 echo "User $USER does not exist on Oracle IA"
 exit 10
fi

#is the user subscribed to insight?
SUB=`Subscribed $USER`
if [ -z $SUB ]; then
   echo "$USER not found within IA - user must be registered with IA_SUBSCRIPTIONS" 
   exit 60
fi
echo $SUB


Verify_Suppression_Tabs   # ensures all individual suppression tables    
                          # exists and are indexe

Create_Suppression_Driver # creates the main query driving table

Create_Suppressions       # performs the big join using the above table

echo "Completed " `date`
# --------------------------------------------------------------[END]-
**************
* 1%dim2k.sh *
**************
#!/bin/ksh

create_view()
{
if DB_object_not_exists dim2k_view; then
DB_run_query_pipe<<!
Prompt creating view over dim2k ...
whenever sqlerror exit sql.sqlcode
create view dim2k_view
as select d.*, rownum my_id from dim2k d;
exit sql.sqlcode
!
else echo "View exists ..."
fi

if [ $? -ne 0 ]; then
  echo "Failed generating view"
fi
}

create_table()
{
DB_run_query_pipe<<!
Prompt creating 1% sample ...
whenever sqlerror exit sql.sqlcode
create table dim2k_sample
TABLESPACE USERS
   PCTFREE 0   PCTUSED 99
 STORAGE ( 
   INITIAL 40M NEXT 40M PCTINCREASE 0)
as select v.*
from dim2k_view v
where mod(my_id,100)=0;
!

if [ $? -ne 0 ]; then
   echo "Failed creating table"
fi
}

##
# Main
##

START=$(date "+%Y-%m-%d-%H:%M:%S")
echo "Started $START ..."

create_view
create_table

END=$(date "+%Y-%m-%d-%H:%M:%S")
echo "Finished at $END"
--------------------------------------------------------------------------------------------------------------------
*********************
* DB_run_query_pipe *
*********************

#! /usr/bin/sh

. ${MKI_HOME}/utils/bin/DB_env_reqmts

USAGE="\
DB_run_query_pipe - Runs a SQL COMMAND from stdin \n\
\n\
Usage: /usr/bin/echo \"command;\" | $0 \n\
"

if [ $# -ne 0 ]; then
	/usr/bin/echo "Error: Incorrect number of arguments" >&2
	/usr/bin/echo "${USAGE}" >&2
	exit 1
fi

if [ -z "${SQLPLUS}" ]; then
	SQLPLUS="sqlplus -s"
	#SQLPLUS="sqlplus"
fi

#/usr/bin/cat - | ${SQLPLUS} ${DB_LOGIN}
# Note: do NOT use /usr/bin/echo as this limits the size of the script file
#	causing the error "sh: /usr/bin/echo: arg list too long"
#	whereas using the shell built-in echo allows larger files
echo "${DB_LOGIN}\n `/usr/bin/cat -`" | ${SQLPLUS}

--------------------------------------------------------------------------------------------------------------------
**********************
* PAF UPDATE PACKAGE *
**********************
PACKAGE  PAF_UPDATE IS
/* =======================================================
   Title        : %M%

   Version      : %I% - %G%

   Description  : Updates the IA House Keys table with
                  PAF changes

   What Usage   : %W% %G%

   ======================================================= */

  Function Exists_Ptcabs (w_ptcabs varchar2,w_exclude_rowid rowid) Return number
;

  Procedure Expand_Links;
  Procedure Update_IA_HouseKeys;


END PAF_UPDATE;
PACKAGE BODY PAF_UPDATE IS

   -- -1 PTCABS not found
   -- 0  PTCABS found with no link id
   -- >0 PTCABS found, returning link id

   Function Exists_Ptcabs (w_ptcabs varchar2,w_exclude_rowid rowid)
   Return Number Is

       w_link_id   number(10);

       Cursor CurGetPtabs (w_pt varchar2,w_rowid rowid) Is
       Select nvl(link_id,0)
       From   Paf_link
       Where  (old_ptcabs = w_pt Or new_ptcabs = w_pt)
           And    rowid != w_rowid;

   Begin

       Open CurGetPtabs(w_ptcabs,w_exclude_rowid);
       Fetch CurGetPtabs Into w_link_id;

       If CurGetPtabs%NotFound Then
           Return -1;
       Else
               -- only need one id value as they would be
                   -- both identicle or one of them null. Should
                   -- never have two different link id's.
               If w_link_id > 0 Then
               Return w_link_id;
                   Else
                       Return 0;
                   End If;
       End If;

           Close CurGetPtabs;

   Exception
   When Others Then
       Dbms_Output.Put_Line('Lookup PTCABS :'||w_ptcabs);
       Dbms_Output.Put_Line(SqlErrm);

   End Exists_Ptcabs;


   ----------------------------------------------------------------------------


   Procedure Expand_Links Is

   w_commit                number(10) := 50000;
   w_cmt_ctr               number(10) := 0;

   w_link_ptr              number(10);
   w_old_exists_ptcabs_id  number(10);
   w_new_exists_ptcabs_id  number(10);

   w_chunks number(10) := 1;
   w_tot_recs number(10);

   w_rowid rowid;

   w_start_seqno number(10) := 0;
   w_end_seqno   number(10) := 0;

   -- below used for summary report info
   wCondJ      number(10) := 0;
   wCondI      number(10) := 0;
   wCondH      number(10) := 0;
   wCondG      number(10) := 0;
   wCondF      number(10) := 0;
   wCondE      number(10) := 0;
   wCondD      number(10) := 0;
   wCondC      number(10) := 0;
   wCondB      number(10) := 0;
   wCondA      number(10) := 0;
   w_rec_count number(10) := 1; -- processed record counter

   PAFRecord    Paf_Link%Rowtype;

   -- driving cursor
   Cursor CurPAFLink(w_rid rowid,w_cm number) Is
   Select link_id,old_ptcabs,new_ptcabs,rowid
   From Paf_Link
   Where seqno > w_start_seqno
   and seqno < w_end_seqno + 1;



   Begin

      select count(*)
      into w_tot_recs
      from paf_link;

      w_chunks := ceil(w_tot_recs / w_commit);
          w_end_seqno := w_commit;

      dbms_output.put_line(w_chunks||' to process of size '||w_commit||' recs');



          -- get some more records to process
      For chunk in 1..w_chunks
          Loop

          For PAFRecord in CurPAFLink(w_rowid,w_commit)
          Loop

                     w_old_exists_ptcabs_id := -1;
                 w_new_exists_ptcabs_id := -1;

                     -- get next link pointer value
                     select PAF_LINK_SEQ.nextval
                     into w_link_ptr
                     from Dual;

                 -- search paf_link for OLD/NEW_PTCABS to see if exists
                 w_old_exists_ptcabs_id := Exists_Ptcabs(PAFRecord.old_ptcabs
                                                            ,PAFRecord.rowid);
                 w_new_exists_ptcabs_id := Exists_Ptcabs(PAFRecord.new_ptcabs
                                                                ,PAFRecord.rowid);


                         -- [Condition J] --

                        -- if old link id AND new link id does exist
                            -- and they differ, then we need to merge both id's
                            -- into one id

                         If  w_old_exists_ptcabs_id > 0 And
                             w_new_exists_ptcabs_id > 0 And
                                 w_old_exists_ptcabs_id <> w_new_exists_ptcabs_id
                         Then

                            wCondJ := wCondJ + 1;

                                -- set current record to old ptcabs link id
                                update paf_link
                                set link_id = w_old_exists_ptcabs_id
                                where rowid = PAFRecord.rowid;

                                -- set all recs poinitng to new ptcabs link id
                                -- to old ptcabs link id
                                update paf_link
                                set link_id = w_old_exists_ptcabs_id
                                where link_id = w_new_exists_ptcabs_id;

                         End If;

                         -- [Condition I] --

                            -- New ptcabs has link set and Old ptcabs
                            -- does exists elsewhere but with no link id set
                            -- so update *all* ptcabs where new ptcabs value
                            -- is present to the new link id
                         if w_old_exists_ptcabs_id = 0 and
                            w_new_exists_ptcabs_id > 0 Then

                                wCondI := wCondI + 1;

                                update paf_link
                                set link_id = w_new_exists_ptcabs_id
                                where old_ptcabs = PAFRecord.old_ptcabs
                                or    new_ptcabs = PAFRecord.old_ptcabs;
                         End If;

                         -- [Condition H] --

                            -- Old ptcabs has link set and New ptcabs
                            -- does exists elsewhere but with no link id set
                            -- so update *all* ptcabs where old ptcabs value
                            -- is present to the old link id
                         if w_old_exists_ptcabs_id > 0 and
                            w_new_exists_ptcabs_id = 0 Then

                                wCondH := wCondH + 1;

                                update paf_link
                                set link_id = w_old_exists_ptcabs_id
                                where old_ptcabs = PAFRecord.new_ptcabs
                                or    new_ptcabs = PAFRecord.new_ptcabs;
                         End If;


                         -- [Condition G] --

                         -- if old does not exist but the new does exist
                         -- and it *has* a link id set, then we point this record
                         -- to the id from the existing new ptcabs
                         If w_old_exists_ptcabs_id = -1 and
                            w_new_exists_ptcabs_id > 0 Then

                                wCondG := wCondG + 1;

                                update paf_link
                                set link_id = w_new_exists_ptcabs_id
                                where rowid = PAFRecord.rowid;
                         End If;


                         -- [Condition F] --

                         -- if new does not exist but the old does exist
                         -- and it *has* a link id set, then we point this record
                         -- to the id from the existing old ptcabs
                         If w_old_exists_ptcabs_id > 0 and
                            w_new_exists_ptcabs_id = -1 Then

                                wCondF := wCondF + 1;

                                update paf_link
                                set link_id = w_old_exists_ptcabs_id
                                where rowid = PAFRecord.rowid;
                         End If;


                         -- [Condition E] --
                         -- no processing necessary

                         -- [Condition D] --

                    -- if old and new exists with no link id,
                            -- i.e Record link_id will be null, then
                            -- set new link ptr to all ptcabs = old or new
                 If w_old_exists_ptcabs_id = 0 and
                            w_new_exists_ptcabs_id = 0 Then

                                wCondD := wCondD + 1;

                                update paf_link
                                set link_id  = w_link_ptr
                                where old_ptcabs = PAFRecord.new_ptcabs
                                or    old_ptcabs = PAFRecord.old_ptcabs
                                or    new_ptcabs = PAFRecord.new_ptcabs
                                or    new_ptcabs = PAFRecord.old_ptcabs;
                         End If;

                         -- [Condition C] --

                            -- if old does not exist anywhere else but the
                            -- new does exist *but* it has no link id set
                            -- then set new link ptr to all records
                            -- containing the new ptcabs
                         If w_old_exists_ptcabs_id = -1 and
                            w_new_exists_ptcabs_id = 0 Then

                                wCondC := wCondC + 1;

                                update paf_link
                                set link_id  = w_link_ptr
                                where old_ptcabs = PAFRecord.new_ptcabs
                                or    new_ptcabs = PAFRecord.new_ptcabs;

                         End If;

                         -- [Condition B] --

                    -- if old ptcabs exists with no link set and
                            -- new ptcabs does not exist elsewhere
                            -- then set new link ptr for all ptcabs = old_ptcabs
                 If w_old_exists_ptcabs_id = 0 and
                            w_new_exists_ptcabs_id = -1 Then

                                wCondB := wCondB + 1;

                                update paf_link
                                set link_id  = w_link_ptr
                                where old_ptcabs = PAFRecord.old_ptcabs
                                or    new_ptcabs = PAFRecord.old_ptcabs;
                         End If;

                         -- [Condition A] --

                            -- neither have dependancies so ok to give a new id
                         If w_old_exists_ptcabs_id = -1 And
                            w_new_exists_ptcabs_id = -1 Then

                                wCondA := wCondA + 1;

                                update paf_link
                                set link_id = w_link_ptr
                                where rowid = PAFRecord.rowid;
                         End If;

                     w_rec_count := w_rec_count + 1;



                  End Loop; -- PAFRecord

                  w_start_seqno := w_end_seqno;
                  w_end_seqno   := w_end_seqno + w_commit;

                  dbms_output.put_line('Chunk '||chunk||' Committed '||to_char(sysdate,'DD/MM/
YYYY HH:MI:SS'));


                  commit; -- commit; the chunk


        End Loop; -- chunk

    -- commit recs outside commit point
        commit;

    -- produce stats on the level of processing
    dbms_output.put_line('Condition A :'||wCondA);
    dbms_output.put_line('Condition B :'||wCondB);
    dbms_output.put_line('Condition C :'||wCondC);
    dbms_output.put_line('Condition D :'||wCondD);
    dbms_output.put_line('Condition E :'||wCondE);
    dbms_output.put_line('Condition F :'||wCondF);
    dbms_output.put_line('Condition G :'||wCondG);
        dbms_output.put_line('Condition H :'||wCondH);
        dbms_output.put_line('Condition I :'||wCondI);
        dbms_output.put_line('Condition J :'||wCondJ);

   Exception
      When Others Then
         Dbms_Output.Put_Line('Debug=> Old:'||PAFRecord.old_ptcabs||
                                      ' - New:'||PAFRecord.new_ptcabs||
                                                  ' - Link ID'||PAFRecord.link_id);
                 Dbms_Output.Put_Line('Current rec num:'||w_rec_count);
         Dbms_Output.Put_Line(SqlErrm);
         Rollback;

   End Expand_Links;


   ----------------------------------------------------------------------------


   Procedure Update_IA_HouseKeys Is

   w_commit              number(10) := 40000;
   --w_cmt_ctr           number(10) := 1;
   w_tot_links           number(10);
   w_chunks              number(10) := 1;
   w_last_link_processed number(10);
   w_ptcabs_reg          number(10) := 0;
   w_ptcabs_unreg        number(10) := 0;
   w_rec_count           number(10) := 0;

   w_max_house_id        house_keys.house_id%type;
   w_next_ia_house_id    house_keys.house_id%type;

   -- get list of links to process
   Cursor CurLink (w_link_last number) Is
   Select distinct link_id
   From Paf_link
   where link_id > w_link_last
   and link_id < w_link_last + w_commit;

   LinkRecord  CurLink%rowtype;

   -- get max house id for any PTCABS that exist
   -- within the selected group

   Cursor CurMaxHouseID(w_LinkId Number) Is
   Select max(house_id)
   From (Select old_ptcabs as ptcabs
         From Paf_Link
         Where link_id = w_LinkId
         Union All
         Select new_ptcabs as ptcabs
                 From Paf_Link
         Where link_id = w_LinkId) pl
                 ,house_keys hk
   Where pl.ptcabs = hk.ptcabs;


   Begin

      Select max(link_id)
          Into w_tot_links
          From Paf_Link;

      w_chunks := ceil(w_tot_links / w_commit);

      dbms_output.put_line(w_chunks||' to process of size '||w_commit||' recs');


      w_last_link_processed := 0;

          -- get some more records to process
      For chunk in 1..w_chunks
          Loop

         For LinkRecord in CurLink (w_last_link_processed)
         Loop

                    -- do any ptcabs have an id already, if so
                    -- we take the highest.

            Open CurMaxHouseID(LinkRecord.link_id);
                    Fetch CurMaxHouseID Into w_max_house_id;
                        If CurMaxHouseID%NotFound Then
                            w_max_house_id := Null;
                        End If;
                    Close CurMaxHouseId;

                    If w_max_house_id is not null Then

                                -- redirect any matching PTCABS within the group
                                -- to point to latest IA House ID
                update house_keys
                                set house_id = w_max_house_id
                                where ptcabs in (
                                   Select old_ptcabs
                           From Paf_Link
                           Where link_id = LinkRecord.link_id
                           Union
                           Select new_ptcabs
                                   From Paf_Link
                           Where link_id = LinkRecord.link_id);


                                -- insert and assign latest IA House ID to
                                -- ptcabs in the current group Link ID that dont
                                -- currently reside in House_Keys
                    insert  into HOUSE_KEYS
                        select  ptcabs,w_max_house_id
                        From  (select old_ptcabs as ptcabs
                           from paf_link
                                   where link_id = LinkRecord.link_id
                                   union
                                   select new_ptcabs as ptcabs
                                   from paf_link
                                   where link_id = LinkRecord.link_id) pl
                        where not exists (select '1'
                                          from house_keys hk
                                      where hk.ptcabs = pl.ptcabs);


                            w_ptcabs_reg := w_ptcabs_reg + 1;
                    Else
                       -- not PTCABS within the group are present in the
                           -- house_keys table. Need to create new house_key
                           -- records for all ptcabs within group and assign
                           -- the *same* *new* IA house id to them.

                           -- get next IA house key
                           select house_keys_SEQ.nextval
                           into w_next_ia_house_id
                           from dual;

                       insert into HOUSE_KEYS
                   select  ptcabs,w_next_ia_house_id
                   From  (select old_ptcabs as ptcabs
                       from paf_link
                               where link_id = LinkRecord.link_id
                               union
                               select new_ptcabs as ptcabs
                               from paf_link
                               where link_id = LinkRecord.link_id) pl
                   where not exists (select '1'
                                  from house_keys hk
                                  where hk.ptcabs = pl.ptcabs);

                       w_ptcabs_unreg := w_ptcabs_unreg + 1;
                    End If;



                    w_last_link_processed := LinkRecord.link_id;

                    w_rec_count := w_rec_count + 1;
         End Loop; -- LinkRecord

         commit;

          End Loop; -- chunk

          commit;

          dbms_output.put_line('Total PAF_LINKS recs processed: '||w_rec_count);
          dbms_output.put_line('PTCABS registered             : '||w_ptcabs_reg);
          dbms_output.put_line('PTCABS non-registered         : '||w_ptcabs_unreg);

   Exception
      When Others Then
         --Dbms_Output.Put_Line('Current Rec = Old:'||PAFRecord.old_ptcabs||
                 --              ' - New:'||PAFRecord.new_ptcabs);
         Dbms_Output.Put_Line(SqlErrm);
         Rollback;

   End Update_IA_HouseKeys;


END PAF_UPDATE;
----------------------------------------------------------------------------------------------------------------
****************
* flash_gordon *
****************
# A routine that takes a single parameter ( a valid table name) and a piece of SQL that does
# the following:
#
# For all the numeric columns:
#	min(COL)
#	max(COL)
#	count(COL)
#	count(distinct COL)
#	stddev(COL)
#
# Store this information in a table with the following structure:
#	TABLE_NAME
#	COLUMN_NAME
#	MINIMUM
#	MAXIMUM
#	ROW_COUNT
#	DISTINCT
#	STANDARD_DEV
#	TIMESTAMP
# Also generate the output in csv format.
#
#
#!/bin/ksh
# =====================================================================
#
# Script Name : flash_gordon.sh  [%M%]
#
# Version     : 1.2 - 06/06/01   [%I% - %G%]
#
# Description : Audit statistics info on numeric columns for the target table.
#
#
# Called by   : Run stand alone
#
#
# What Usage  : @(#)flash_gordon.sh	1.2 06/06/01    %W% %G%
#
# =====================================================================


chk_table()
{
if DB_object_not_exists ${TABLENAME}; then
	echo "Tablename : ${TABLENAME} does not exists. Aborting ..."
	exit 2
fi
}

create_table()
{
if DB_object_not_exists IA_AUDIT_STATS; then
	DB_run_query_pipe<<-!
	whenever sqlerror exit sql.sqlcode
	create table IA_AUDIT_STATS
	(table_name	varchar2(30),
	column_name	varchar2(30),
	minimum		number(11),
	maximum		number(11),
	row_count	number(11),
	distinct_count		number(11),
	standard_dev	number(11,2),
	time_stamp	date)
	tablespace users
	pctused 99
	pctfree 0
	storage(initial 1M next 1M pctincrease 0);
	!
else
	echo "Table IA_AUDIT_STATS exists ..."
fi
}


insert_columns()
{
echo "Inserting column names ..."

cat <<! > $T1
set heading off pages 0
set feedback off verify off
whenever sqlerror exit sql.sqlcode

!

DB_desc ${TABLENAME} | awk '$2 ~ /NUMBER/ {printf("insert into IA_AUDIT_STATS values (@MYTB@,@%s@,@@,@@,@@,@@,@@,sysdate);\n",$1)}' | sed -e s/@/\'/g -e s/MYTB/$TABLENAME/g >> $T1 
	

DB_run_query_pipe < $T1
}


update_columns()
{
echo "Updating table columns this may takes awhile..."

ROWCNT=$(DB_run_query_pipe<<!
whenever sqlerror exit sql.sqlcode
set heading off pages 0 feedback off verify off
select count(*) from ${TABLENAME};
exit sql.sqlcode
!)

ROWCNT=$(echo $ROWCNT | awk '{print $1}')

cat <<! > $T2
whenever sqlerror exit sql.sqlcode
set heading off pages 0
set feedback off verify off

!

DB_desc ${TABLENAME} | awk '$2 ~ /NUMBER/ {
printf("update IA_AUDIT_STATS set minimum=(select min(%s) from MYTB) where column_name=@%s@;\n",$1,$1); 
printf("update IA_AUDIT_STATS set maximum = (select max(%s) from MYTB) where column_name=@%s@;\n",$1,$1); 
printf("update IA_AUDIT_STATS set row_count = MYCOUNT where column_name=@%s@;\n",$1); 
printf("update IA_AUDIT_STATS set distinct_count = (select count(distinct %s) from MYTB) where column_name=@%s@;\n",$1,$1);
printf("update IA_AUDIT_STATS set standard_dev = (select stddev(%s) from MYTB) where column_name=@%s@;\n",$1,$1); 
printf("commit;\n") }' | sed -e s/@/\'/g -e s/MYTB/$TABLENAME/g -e s/MYCOUNT/$ROWCNT/g >> $T2 

DB_run_query_pipe < $T2
}

csv_format()
{
echo "Format output ..."
echo "TABLE_NAME,COLUMN_NAME,MINIMUM,MAXIMUM,ROW_COUNT,DISTINCT_COUNT,STANDARD_DEV,TIME_STAMP" > $OUT

DB_run_query_pipe<<! >> $OUT
whenever sqlerror exit sql.sqlcode
set heading off pages 0
set feedback off verify off

select 	TABLE_NAME || ',' || COLUMN_NAME ||',' ||
			MINIMUM || ',' || MAXIMUM || ',' || 
			ROW_COUNT || ',' || DISTINCT_COUNT || ',' ||
			STANDARD_DEV || ',' || TIME_STAMP
from ia_audit_stats
where table_name=${TABLENAME};
exit sql.sqlcode
!
}


######
# Main
######


if [ $# != 1 ]; then
	echo "ERROR: incorrect parameters passed"
	echo "Usage: $(basename $0) <<table_name>>"
	exit 1
fi

TABLENAME=$1
T1=/tmp/$$.tmp1
T2=/tmp/$$.tmp2
OUT=gordon.csv  # flash gordon for now

TIME1=$(date "+%H:%M:%S %d-%m-%Y")
echo "Start at $TIME1"
chk_table
create_table
insert_columns
update_columns
csv_format
rm -f $T1 $T2
TIME2=$(date "+%H:%M:%S %d-%m-%Y")
echo "End at $TIME2 see $OUT for output"
____________________________________________________________________________________________________________
************************
* timing_with_index.sh *
************************
#!/bin/ksh
# =====================================================================
#
# Script Name : %M%
#
# Version     : %I% - %G%
#
# Description : Script to measure how long it takes to update dim2k table
#					 with data from the suppression tables.
#
#
# Called by   : Run stand alone
#
#
# What Usage  : %W% %G%
#
# =====================================================================


prepare_data()
{
##
# Table DL is a copy of COMPLAINTS with an additional
# column House_ID added, which will be updated from dim2k
# This step is needed so that I can use the index on dim2k(house_id)
# for the timing of update process
##

START_TIME=$(date "+%H:%M:%S %d-%m-%Y")
echo "Prepare data - Start time : $START_TIME"

DB_run_query_pipe<<!
BEGIN
	DECLARE CURSOR get_data IS
	select d.house_id, c.id
	from   dl c, dim2k d
	where  c.id=d.id;

	v_id            dl.id%TYPE;
	v_house_id      dim2k.house_id%TYPE;


	BEGIN
		OPEN get_data;
		LOOP
   		FETCH get_data INTO v_house_id, v_id;
   		EXIT WHEN get_data%NOTFOUND;
   		update dl
   		set house_id = v_house_id 
			where id = v_id;
		END LOOP;
		CLOSE get_data;
		commit;
	END;
END;
/
exit;
!
END_TIME=$(date "+%H:%M:%S %d-%m-%Y")
echo "Prepare data - End time : $END_TIME"
}


time_with_index()
{
START_TIME=$(date "+%H:%M:%S %d-%m-%Y")
echo "Index Start time : $START_TIME"

DB_run_query_pipe<<!
BEGIN
	DECLARE CURSOR get_data IS
	select c.house_id, to_char(c.h_com),c.id
	from   dl c;

	v_h_com         dl.h_com%TYPE;
	v_house_id      dl.house_id%TYPE;
	v_id      		 dl.id%TYPE;


	BEGIN
		OPEN get_data;
		LOOP
   		FETCH get_data INTO v_house_id, v_h_com,v_id;
   		EXIT WHEN get_data%NOTFOUND;
   		update dim2k
			set postcode_wealth_indicator = v_h_com
   	   where id = v_id
			and house_id = v_house_id;
		END LOOP;
		CLOSE get_data;
		commit;
	END;
END;
/
exit;
!
END_TIME=$(date "+%H:%M:%S %d-%m-%Y")
echo "Index End time : $END_TIME"
}

######
# Main
######

prepare_data
time_with_index
